if (typeof global !== 'undefined') {
  var Buffer = require('buffer').Buffer; 
}
var utils = require('./parser/utils');
function Binary(buffer, subType) {
  if (!(this instanceof Binary)) return new Binary(buffer, subType);
  if (
    buffer != null &&
    !(typeof buffer === 'string') &&
    !Buffer.isBuffer(buffer) &&
    !(buffer instanceof Uint8Array) &&
    !Array.isArray(buffer)
  ) {
    throw new Error('only String, Buffer, Uint8Array or Array accepted');
  }
  this._bsontype = 'Binary';
  if (buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }
  if (buffer != null && !(buffer instanceof Number)) {
    if (typeof buffer === 'string') {
      if (typeof Buffer !== 'undefined') {
        this.buffer = utils.toBuffer(buffer);
      } else if (
        typeof Uint8Array !== 'undefined' ||
        Object.prototype.toString.call(buffer) === '[object Array]'
      ) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error('only String, Buffer, Uint8Array or Array accepted');
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if (typeof Buffer !== 'undefined') {
      this.buffer = utils.allocBuffer(Binary.BUFFER_SIZE);
    } else if (typeof Uint8Array !== 'undefined') {
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    this.position = 0;
  }
}
Binary.prototype.put = function put(byte_value) {
  if (byte_value['length'] != null && typeof byte_value !== 'number' && byte_value.length !== 1)
    throw new Error('only accepts single character String, Uint8Array or Array');
  if ((typeof byte_value !== 'number' && byte_value < 0) || byte_value > 255)
    throw new Error('only accepts number in a valid unsigned byte range 0-255');
  var decoded_byte = null;
  if (typeof byte_value === 'string') {
    decoded_byte = byte_value.charCodeAt(0);
  } else if (byte_value['length'] != null) {
    decoded_byte = byte_value[0];
  } else {
    decoded_byte = byte_value;
  }
  if (this.buffer.length > this.position) {
    this.buffer[this.position++] = decoded_byte;
  } else {
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {
      var buffer = utils.allocBuffer(Binary.BUFFER_SIZE + this.buffer.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    } else {
      buffer = null;
      if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
      } else {
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
      }
      for (var i = 0; i < this.buffer.length; i++) {
        buffer[i] = this.buffer[i];
      }
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    }
  }
};
Binary.prototype.write = function write(string, offset) {
  offset = typeof offset === 'number' ? offset : this.position;
  if (this.buffer.length < offset + string.length) {
    var buffer = null;
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {
      buffer = utils.allocBuffer(this.buffer.length + string.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
    } else if (Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
      for (var i = 0; i < this.position; i++) {
        buffer[i] = this.buffer[i];
      }
    }
    this.buffer = buffer;
  }
  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
    string.copy(this.buffer, offset, 0, string.length);
    this.position = offset + string.length > this.position ? offset + string.length : this.position;
  } else if (
    typeof Buffer !== 'undefined' &&
    typeof string === 'string' &&
    Buffer.isBuffer(this.buffer)
  ) {
    this.buffer.write(string, offset, 'binary');
    this.position = offset + string.length > this.position ? offset + string.length : this.position;
  } else if (
    Object.prototype.toString.call(string) === '[object Uint8Array]' ||
    (Object.prototype.toString.call(string) === '[object Array]' && typeof string !== 'string')
  ) {
    for (i = 0; i < string.length; i++) {
      this.buffer[offset++] = string[i];
    }
    this.position = offset > this.position ? offset : this.position;
  } else if (typeof string === 'string') {
    for (i = 0; i < string.length; i++) {
      this.buffer[offset++] = string.charCodeAt(i);
    }
    this.position = offset > this.position ? offset : this.position;
  }
};
Binary.prototype.read = function read(position, length) {
  length = length && length > 0 ? length : this.position;
  if (this.buffer['slice']) {
    return this.buffer.slice(position, position + length);
  } else {
    var buffer =
      typeof Uint8Array !== 'undefined'
        ? new Uint8Array(new ArrayBuffer(length))
        : new Array(length);
    for (var i = 0; i < length; i++) {
      buffer[i] = this.buffer[position++];
    }
  }
  return buffer;
};
Binary.prototype.value = function value(asRaw) {
  asRaw = asRaw == null ? false : asRaw;
  if (
    asRaw &&
    typeof Buffer !== 'undefined' &&
    Buffer.isBuffer(this.buffer) &&
    this.buffer.length === this.position
  )
    return this.buffer;
  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {
    return asRaw
      ? this.buffer.slice(0, this.position)
      : this.buffer.toString('binary', 0, this.position);
  } else {
    if (asRaw) {
      if (this.buffer['slice'] != null) {
        return this.buffer.slice(0, this.position);
      } else {
        var newBuffer =
          Object.prototype.toString.call(this.buffer) === '[object Uint8Array]'
            ? new Uint8Array(new ArrayBuffer(this.position))
            : new Array(this.position);
        for (var i = 0; i < this.position; i++) {
          newBuffer[i] = this.buffer[i];
        }
        return newBuffer;
      }
    } else {
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
    }
  }
};
Binary.prototype.length = function length() {
  return this.position;
};
Binary.prototype.toJSON = function() {
  return this.buffer != null ? this.buffer.toString('base64') : '';
};
Binary.prototype.toString = function(format) {
  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
};
var BSON_BINARY_SUBTYPE_DEFAULT = 0;
var writeStringToArray = function(data) {
  var buffer =
    typeof Uint8Array !== 'undefined'
      ? new Uint8Array(new ArrayBuffer(data.length))
      : new Array(data.length);
  for (var i = 0; i < data.length; i++) {
    buffer[i] = data.charCodeAt(i);
  }
  return buffer;
};
var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
  var result = '';
  for (var i = startIndex; i < endIndex; i++) {
    result = result + String.fromCharCode(byteArray[i]);
  }
  return result;
};
Binary.BUFFER_SIZE = 256;
Binary.SUBTYPE_DEFAULT = 0;
Binary.SUBTYPE_FUNCTION = 1;
Binary.SUBTYPE_BYTE_ARRAY = 2;
Binary.SUBTYPE_UUID_OLD = 3;
Binary.SUBTYPE_UUID = 4;
Binary.SUBTYPE_MD5 = 5;
Binary.SUBTYPE_USER_DEFINED = 128;
module.exports = Binary;
module.exports.Binary = Binary;
