'use strict';
var writeIEEE754 = require('../float_parser').writeIEEE754,
  Long = require('../long').Long,
  Map = require('../map'),
  Binary = require('../binary').Binary;
var normalizedFunctionString = require('./utils').normalizedFunctionString;
var regexp = /\x00/; 
var ignoreKeys = ['$db', '$ref', '$id', '$clusterTime'];
var isDate = function isDate(d) {
  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
};
var isRegExp = function isRegExp(d) {
  return Object.prototype.toString.call(d) === '[object RegExp]';
};
var serializeString = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_STRING;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes + 1;
  buffer[index - 1] = 0;
  var size = buffer.write(value, index + 4, 'utf8');
  buffer[index + 3] = ((size + 1) >> 24) & 0xff;
  buffer[index + 2] = ((size + 1) >> 16) & 0xff;
  buffer[index + 1] = ((size + 1) >> 8) & 0xff;
  buffer[index] = (size + 1) & 0xff;
  index = index + 4 + size;
  buffer[index++] = 0;
  return index;
};
var serializeNumber = function(buffer, key, value, index, isArray) {
  if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
    if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
      buffer[index++] = BSON.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, 'utf8')
        : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value & 0xff;
      buffer[index++] = (value >> 8) & 0xff;
      buffer[index++] = (value >> 16) & 0xff;
      buffer[index++] = (value >> 24) & 0xff;
    } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
      buffer[index++] = BSON.BSON_DATA_NUMBER;
      numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, 'utf8')
        : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      writeIEEE754(buffer, value, index, 'little', 52, 8);
      index = index + 8;
    } else {
      buffer[index++] = BSON.BSON_DATA_LONG;
      numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, 'utf8')
        : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var longVal = Long.fromNumber(value);
      var lowBits = longVal.getLowBits();
      var highBits = longVal.getHighBits();
      buffer[index++] = lowBits & 0xff;
      buffer[index++] = (lowBits >> 8) & 0xff;
      buffer[index++] = (lowBits >> 16) & 0xff;
      buffer[index++] = (lowBits >> 24) & 0xff;
      buffer[index++] = highBits & 0xff;
      buffer[index++] = (highBits >> 8) & 0xff;
      buffer[index++] = (highBits >> 16) & 0xff;
      buffer[index++] = (highBits >> 24) & 0xff;
    }
  } else {
    buffer[index++] = BSON.BSON_DATA_NUMBER;
    numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, 'utf8')
      : buffer.write(key, index, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    writeIEEE754(buffer, value, index, 'little', 52, 8);
    index = index + 8;
  }
  return index;
};
var serializeNull = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_NULL;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
};
var serializeBoolean = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_BOOLEAN;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  buffer[index++] = value ? 1 : 0;
  return index;
};
var serializeDate = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_DATE;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var dateInMilis = Long.fromNumber(value.getTime());
  var lowBits = dateInMilis.getLowBits();
  var highBits = dateInMilis.getHighBits();
  buffer[index++] = lowBits & 0xff;
  buffer[index++] = (lowBits >> 8) & 0xff;
  buffer[index++] = (lowBits >> 16) & 0xff;
  buffer[index++] = (lowBits >> 24) & 0xff;
  buffer[index++] = highBits & 0xff;
  buffer[index++] = (highBits >> 8) & 0xff;
  buffer[index++] = (highBits >> 16) & 0xff;
  buffer[index++] = (highBits >> 24) & 0xff;
  return index;
};
var serializeRegExp = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_REGEXP;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.source && value.source.match(regexp) != null) {
    throw Error('value ' + value.source + ' must not contain null bytes');
  }
  index = index + buffer.write(value.source, index, 'utf8');
  buffer[index++] = 0x00;
  if (value.global) buffer[index++] = 0x73; 
  if (value.ignoreCase) buffer[index++] = 0x69; 
  if (value.multiline) buffer[index++] = 0x6d; 
  buffer[index++] = 0x00;
  return index;
};
var serializeBSONRegExp = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_REGEXP;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.pattern.match(regexp) != null) {
    throw Error('pattern ' + value.pattern + ' must not contain null bytes');
  }
  index = index + buffer.write(value.pattern, index, 'utf8');
  buffer[index++] = 0x00;
  index =
    index +
    buffer.write(
      value.options
        .split('')
        .sort()
        .join(''),
      index,
      'utf8'
    );
  buffer[index++] = 0x00;
  return index;
};
var serializeMinMax = function(buffer, key, value, index, isArray) {
  if (value === null) {
    buffer[index++] = BSON.BSON_DATA_NULL;
  } else if (value._bsontype === 'MinKey') {
    buffer[index++] = BSON.BSON_DATA_MIN_KEY;
  } else {
    buffer[index++] = BSON.BSON_DATA_MAX_KEY;
  }
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
};
var serializeObjectId = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_OID;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (typeof value.id === 'string') {
    buffer.write(value.id, index, 'binary');
  } else if (value.id && value.id.copy) {
    value.id.copy(buffer, index, 0, 12);
  } else {
    throw new Error('object [' + JSON.stringify(value) + '] is not a valid ObjectId');
  }
  return index + 12;
};
var serializeBuffer = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_BINARY;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var size = value.length;
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8) & 0xff;
  buffer[index++] = (size >> 16) & 0xff;
  buffer[index++] = (size >> 24) & 0xff;
  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
  value.copy(buffer, index, 0, size);
  index = index + size;
  return index;
};
var serializeObject = function(
  buffer,
  key,
  value,
  index,
  checkKeys,
  depth,
  serializeFunctions,
  ignoreUndefined,
  isArray,
  path
) {
  for (var i = 0; i < path.length; i++) {
    if (path[i] === value) throw new Error('cyclic dependency detected');
  }
  path.push(value);
  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var endIndex = serializeInto(
    buffer,
    value,
    checkKeys,
    index,
    depth + 1,
    serializeFunctions,
    ignoreUndefined,
    path
  );
  path.pop();
  return endIndex;
};
var serializeDecimal128 = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_DECIMAL128;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  value.bytes.copy(buffer, index, 0, 16);
  return index + 16;
};
var serializeLong = function(buffer, key, value, index, isArray) {
  buffer[index++] = value._bsontype === 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var lowBits = value.getLowBits();
  var highBits = value.getHighBits();
  buffer[index++] = lowBits & 0xff;
  buffer[index++] = (lowBits >> 8) & 0xff;
  buffer[index++] = (lowBits >> 16) & 0xff;
  buffer[index++] = (lowBits >> 24) & 0xff;
  buffer[index++] = highBits & 0xff;
  buffer[index++] = (highBits >> 8) & 0xff;
  buffer[index++] = (highBits >> 16) & 0xff;
  buffer[index++] = (highBits >> 24) & 0xff;
  return index;
};
var serializeInt32 = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_INT;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  buffer[index++] = value & 0xff;
  buffer[index++] = (value >> 8) & 0xff;
  buffer[index++] = (value >> 16) & 0xff;
  buffer[index++] = (value >> 24) & 0xff;
  return index;
};
var serializeDouble = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_NUMBER;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  writeIEEE754(buffer, value, index, 'little', 52, 8);
  index = index + 8;
  return index;
};
var serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {
  buffer[index++] = BSON.BSON_DATA_CODE;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var functionString = normalizedFunctionString(value);
  var size = buffer.write(functionString, index + 4, 'utf8') + 1;
  buffer[index] = size & 0xff;
  buffer[index + 1] = (size >> 8) & 0xff;
  buffer[index + 2] = (size >> 16) & 0xff;
  buffer[index + 3] = (size >> 24) & 0xff;
  index = index + 4 + size - 1;
  buffer[index++] = 0;
  return index;
};
var serializeCode = function(
  buffer,
  key,
  value,
  index,
  checkKeys,
  depth,
  serializeFunctions,
  ignoreUndefined,
  isArray
) {
  if (value.scope && typeof value.scope === 'object') {
    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, 'utf8')
      : buffer.write(key, index, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var startIndex = index;
    var functionString = typeof value.code === 'string' ? value.code : value.code.toString();
    index = index + 4;
    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;
    buffer[index] = codeSize & 0xff;
    buffer[index + 1] = (codeSize >> 8) & 0xff;
    buffer[index + 2] = (codeSize >> 16) & 0xff;
    buffer[index + 3] = (codeSize >> 24) & 0xff;
    buffer[index + 4 + codeSize - 1] = 0;
    index = index + codeSize + 4;
    var endIndex = serializeInto(
      buffer,
      value.scope,
      checkKeys,
      index,
      depth + 1,
      serializeFunctions,
      ignoreUndefined
    );
    index = endIndex - 1;
    var totalSize = endIndex - startIndex;
    buffer[startIndex++] = totalSize & 0xff;
    buffer[startIndex++] = (totalSize >> 8) & 0xff;
    buffer[startIndex++] = (totalSize >> 16) & 0xff;
    buffer[startIndex++] = (totalSize >> 24) & 0xff;
    buffer[index++] = 0;
  } else {
    buffer[index++] = BSON.BSON_DATA_CODE;
    numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, 'utf8')
      : buffer.write(key, index, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    functionString = value.code.toString();
    var size = buffer.write(functionString, index + 4, 'utf8') + 1;
    buffer[index] = size & 0xff;
    buffer[index + 1] = (size >> 8) & 0xff;
    buffer[index + 2] = (size >> 16) & 0xff;
    buffer[index + 3] = (size >> 24) & 0xff;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
  }
  return index;
};
var serializeBinary = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_BINARY;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var data = value.value(true);
  var size = value.position;
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8) & 0xff;
  buffer[index++] = (size >> 16) & 0xff;
  buffer[index++] = (size >> 24) & 0xff;
  buffer[index++] = value.sub_type;
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    buffer[index++] = size & 0xff;
    buffer[index++] = (size >> 8) & 0xff;
    buffer[index++] = (size >> 16) & 0xff;
    buffer[index++] = (size >> 24) & 0xff;
  }
  data.copy(buffer, index, 0, value.position);
  index = index + value.position;
  return index;
};
var serializeSymbol = function(buffer, key, value, index, isArray) {
  buffer[index++] = BSON.BSON_DATA_SYMBOL;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var size = buffer.write(value.value, index + 4, 'utf8') + 1;
  buffer[index] = size & 0xff;
  buffer[index + 1] = (size >> 8) & 0xff;
  buffer[index + 2] = (size >> 16) & 0xff;
  buffer[index + 3] = (size >> 24) & 0xff;
  index = index + 4 + size - 1;
  buffer[index++] = 0x00;
  return index;
};
var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {
  buffer[index++] = BSON.BSON_DATA_OBJECT;
  var numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, 'utf8')
    : buffer.write(key, index, 'ascii');
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var startIndex = index;
  var endIndex;
  if (null != value.db) {
    endIndex = serializeInto(
      buffer,
      {
        $ref: value.namespace,
        $id: value.oid,
        $db: value.db
      },
      false,
      index,
      depth + 1,
      serializeFunctions
    );
  } else {
    endIndex = serializeInto(
      buffer,
      {
        $ref: value.namespace,
        $id: value.oid
      },
      false,
      index,
      depth + 1,
      serializeFunctions
    );
  }
  var size = endIndex - startIndex;
  buffer[startIndex++] = size & 0xff;
  buffer[startIndex++] = (size >> 8) & 0xff;
  buffer[startIndex++] = (size >> 16) & 0xff;
  buffer[startIndex++] = (size >> 24) & 0xff;
  return endIndex;
};
var serializeInto = function serializeInto(
  buffer,
  object,
  checkKeys,
  startingIndex,
  depth,
  serializeFunctions,
  ignoreUndefined,
  path
) {
  startingIndex = startingIndex || 0;
  path = path || [];
  path.push(object);
  var index = startingIndex + 4;
  if (Array.isArray(object)) {
    for (var i = 0; i < object.length; i++) {
      var key = '' + i;
      var value = object[i];
      if (value && value.toBSON) {
        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');
        value = value.toBSON();
      }
      var type = typeof value;
      if (type === 'string') {
        index = serializeString(buffer, key, value, index, true);
      } else if (type === 'number') {
        index = serializeNumber(buffer, key, value, index, true);
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, key, value, index, true);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index, true);
      } else if (value === undefined) {
        index = serializeNull(buffer, key, value, index, true);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index, true);
      } else if (Buffer.isBuffer(value)) {
        index = serializeBuffer(buffer, key, value, index, true);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index, true);
      } else if (type === 'object' && value['_bsontype'] == null) {
        index = serializeObject(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
          true,
          path
        );
      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
        index = serializeLong(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Double') {
        index = serializeDouble(buffer, key, value, index, true);
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          true
        );
      } else if (value['_bsontype'] === 'Code') {
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
          true
        );
      } else if (value['_bsontype'] === 'Binary') {
        index = serializeBinary(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Symbol') {
        index = serializeSymbol(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
      } else if (value['_bsontype'] === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Int32') {
        index = serializeInt32(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index, true);
      }
    }
  } else if (object instanceof Map) {
    var iterator = object.entries();
    var done = false;
    while (!done) {
      var entry = iterator.next();
      done = entry.done;
      if (done) continue;
      key = entry.value[0];
      value = entry.value[1];
      type = typeof value;
      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {
        if (key.match(regexp) != null) {
          throw Error('key ' + key + ' must not contain null bytes');
        }
        if (checkKeys) {
          if ('$' === key[0]) {
            throw Error('key ' + key + " must not start with '$'");
          } else if (~key.indexOf('.')) {
            throw Error('key ' + key + " must not contain '.'");
          }
        }
      }
      if (type === 'string') {
        index = serializeString(buffer, key, value, index);
      } else if (type === 'number') {
        index = serializeNumber(buffer, key, value, index);
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === null || (value === undefined && ignoreUndefined === false)) {
        index = serializeNull(buffer, key, value, index);
      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (Buffer.isBuffer(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if (type === 'object' && value['_bsontype'] == null) {
        index = serializeObject(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
          false,
          path
        );
      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Code') {
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined
        );
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Symbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value['_bsontype'] === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      }
    }
  } else {
    if (object.toBSON) {
      if (typeof object.toBSON !== 'function') throw new Error('toBSON is not a function');
      object = object.toBSON();
      if (object != null && typeof object !== 'object')
        throw new Error('toBSON function did not return an object');
    }
    for (key in object) {
      value = object[key];
      if (value && value.toBSON) {
        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');
        value = value.toBSON();
      }
      type = typeof value;
      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {
        if (key.match(regexp) != null) {
          throw Error('key ' + key + ' must not contain null bytes');
        }
        if (checkKeys) {
          if ('$' === key[0]) {
            throw Error('key ' + key + " must not start with '$'");
          } else if (~key.indexOf('.')) {
            throw Error('key ' + key + " must not contain '.'");
          }
        }
      }
      if (type === 'string') {
        index = serializeString(buffer, key, value, index);
      } else if (type === 'number') {
        index = serializeNumber(buffer, key, value, index);
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === undefined) {
        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index);
      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (Buffer.isBuffer(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if (type === 'object' && value['_bsontype'] == null) {
        index = serializeObject(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
          false,
          path
        );
      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Code') {
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined
        );
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Symbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value['_bsontype'] === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      }
    }
  }
  path.pop();
  buffer[index++] = 0x00;
  var size = index - startingIndex;
  buffer[startingIndex++] = size & 0xff;
  buffer[startingIndex++] = (size >> 8) & 0xff;
  buffer[startingIndex++] = (size >> 16) & 0xff;
  buffer[startingIndex++] = (size >> 24) & 0xff;
  return index;
};
var BSON = {};
BSON.BSON_DATA_NUMBER = 1;
BSON.BSON_DATA_STRING = 2;
BSON.BSON_DATA_OBJECT = 3;
BSON.BSON_DATA_ARRAY = 4;
BSON.BSON_DATA_BINARY = 5;
BSON.BSON_DATA_UNDEFINED = 6;
BSON.BSON_DATA_OID = 7;
BSON.BSON_DATA_BOOLEAN = 8;
BSON.BSON_DATA_DATE = 9;
BSON.BSON_DATA_NULL = 10;
BSON.BSON_DATA_REGEXP = 11;
BSON.BSON_DATA_CODE = 13;
BSON.BSON_DATA_SYMBOL = 14;
BSON.BSON_DATA_CODE_W_SCOPE = 15;
BSON.BSON_DATA_INT = 16;
BSON.BSON_DATA_TIMESTAMP = 17;
BSON.BSON_DATA_LONG = 18;
BSON.BSON_DATA_DECIMAL128 = 19;
BSON.BSON_DATA_MIN_KEY = 0xff;
BSON.BSON_DATA_MAX_KEY = 0x7f;
BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
BSON.BSON_BINARY_SUBTYPE_UUID = 3;
BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
BSON.BSON_INT32_MAX = 0x7fffffff;
BSON.BSON_INT32_MIN = -0x80000000;
BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
BSON.BSON_INT64_MIN = -Math.pow(2, 63);
BSON.JS_INT_MAX = 0x20000000000000; 
BSON.JS_INT_MIN = -0x20000000000000; 
module.exports = serializeInto;
