const minimatch = require('minimatch');
const path = require('path');
const fs = require('fs');
const debug = require('debug')('nodemon:match');
const utils = require('../utils');
module.exports = match;
module.exports.rulesToMonitor = rulesToMonitor;
function rulesToMonitor(watch, ignore, config) {
  var monitor = [];
  if (!Array.isArray(ignore)) {
    if (ignore) {
      ignore = [ignore];
    } else {
      ignore = [];
    }
  }
  if (!Array.isArray(watch)) {
    if (watch) {
      watch = [watch];
    } else {
      watch = [];
    }
  }
  if (watch && watch.length) {
    monitor = utils.clone(watch);
  }
  if (ignore) {
    [].push.apply(monitor, (ignore || []).map(function (rule) {
      return '!' + rule;
    }));
  }
  var cwd = process.cwd();
  monitor = monitor.map(function (rule) {
    var not = rule.slice(0, 1) === '!';
    if (not) {
      rule = rule.slice(1);
    }
    if (rule === '.' || rule === '.*') {
      rule = '*.*';
    }
    var dir = path.resolve(cwd, rule);
    try {
      var stat = fs.statSync(dir);
      if (stat.isDirectory()) {
        rule = dir;
        if (rule.slice(-1) !== '/') {
          rule += '/';
        }
        rule += '*** and not *.*
        if (rule.slice(-4) !== '***';
      }
    }
    return (not ? '!' : '') + rule;
  });
  return monitor;
}
function tryBaseDir(dir) {
  var stat;
  if (/[?*\{\[]+/.test(dir)) { 
    try {
      var base = path.dirname(dir.replace(/([?*\{\[]+.*$)/, 'foo'));
      stat = fs.statSync(base);
      if (stat.isDirectory()) {
        return base;
      }
    } catch (error) {
    }
  } else {
    try {
      stat = fs.statSync(dir);
      if (stat.isFile() || stat.isDirectory()) {
        return dir;
      }
    } catch (e) { }
  }
  return false;
}
function match(files, monitor, ext) {
  const cwd = process.cwd();
  var rules = monitor.sort(function (a, b) {
    var r = b.split(path.sep).length - a.split(path.sep).length;
    var aIsIgnore = a.slice(0, 1) === '!';
    var bIsIgnore = b.slice(0, 1) === '!';
    if (aIsIgnore || bIsIgnore) {
      if (aIsIgnore) {
        return -1;
      }
      return 1;
    }
    if (r === 0) {
      return b.length - a.length;
    }
    return r;
  }).map(function (s) {
    var prefix = s.slice(0, 1);
    if (prefix === '!') {
      if (s.indexOf('!' + cwd) === 0) {
        return s;
      }
      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);
    }
    if (s.indexOf('.') === 0) {
      return path.resolve(cwd, s);
    }
    if (s.indexOf(cwd) === 0) {
      return s;
    }
    return '**' + (prefix !== path.sep ? path.sep : '') + s;
  });
  debug('rules', rules);
  var good = [];
  var whitelist = []; 
  var ignored = 0;
  var watched = 0;
  var usedRules = [];
  var minimatchOpts = {
    dot: true,
  };
  if (utils.isWindows) {
    minimatchOpts.nocase = true;
  }
  files.forEach(function (file) {
    file = path.resolve(cwd, file);
    var matched = false;
    for (var i = 0; i < rules.length; i++) {
      if (rules[i].slice(0, 1) === '!') {
        if (!minimatch(file, rules[i], minimatchOpts)) {
          ignored++;
          matched = true;
          break;
        }
      } else {
        debug('match', file, minimatch(file, rules[i], minimatchOpts));
        if (minimatch(file, rules[i], minimatchOpts)) {
          watched++;
          if (usedRules.indexOf(rules[i]) === -1) {
            usedRules.push(rules[i]);
            utils.log.detail('matched rule: ' + rules[i]);
          }
          if (rules[i] !== '**' + path.sep + '*.*' &&
            rules[i].slice(-3) === '*.*') {
            whitelist.push(file);
          } else if (path.basename(file) === path.basename(rules[i])) {
            whitelist.push(file);
          } else {
            good.push(file);
          }
          matched = true;
          break;
        } else {
        }
      }
    }
    if (!matched) {
      ignored++;
    }
  });
  debug('good', good)
  if (ext) {
    if (ext.indexOf(',') === -1) {
      ext = '***.{' + ext + '}';
    }
    good = good.filter(function (file) {
      return minimatch(path.basename(file), ext, minimatchOpts);
    });
  } 
  var result = good.concat(whitelist);
  if (utils.isWindows) {
    result = result.map(function (file) {
      return file.slice(0, 1).toLowerCase() + file.slice(1);
    });
  }
  return {
    result: result,
    ignored: ignored,
    watched: watched,
    total: files.length,
  };
}
