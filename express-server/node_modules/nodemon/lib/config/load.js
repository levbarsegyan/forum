var debug = require('debug')('nodemon');
var fs = require('fs');
var path = require('path');
var exists = fs.exists || path.exists;
var utils = require('../utils');
var rules = require('../rules');
var parse = require('../rules/parse');
var exec = require('./exec');
var defaults = require('./defaults');
module.exports = load;
module.exports.mutateExecOptions = mutateExecOptions;
var existsSync = fs.existsSync || path.existsSync;
function findAppScript() {
  if (existsSync('./index.js')) {
    return 'index.js';
  }
}
function load(settings, options, config, callback) {
  config.loaded = [];
  loadFile(options, config, utils.home, function (options) {
    if (settings.configFile) {
      options.configFile = path.resolve(settings.configFile);
    }
    loadFile(options, config, process.cwd(), function (options) {
      options = utils.merge(settings, options);
      if (!Array.isArray(options.ignore)) {
        options.ignore = [options.ignore];
      }
      if (!options.ignoreRoot) {
        options.ignoreRoot = defaults.ignoreRoot;
      }
      if (options.ignoreRoot && options.ignore) {
        if (!Array.isArray(options.ignoreRoot)) {
          options.ignoreRoot = [options.ignoreRoot];
        }
        options.ignore = options.ignoreRoot.concat(options.ignore);
      } else {
        options.ignore = defaults.ignore.concat(options.ignore);
      }
      options = utils.merge(options, defaults);
      if (!options.script && !options.exec) {
        var found = findAppScript();
        if (found) {
          if (!options.args) {
            options.args = [];
          }
          const n = options.scriptPosition || options.args.length;
          options.execArgs = (options.execArgs || [])
            .concat(options.args.splice(0, n));
          options.scriptPosition = null;
          options.script = found;
        }
      }
      mutateExecOptions(options);
      if (options.quiet) {
        utils.quiet();
      }
      if (options.verbose) {
        utils.debug = true;
      }
      var ready = function (options) {
        normaliseRules(options, callback);
      };
      if (config.loaded.length === 0) {
        var legacy = loadLegacyIgnore.bind(null, options, config, ready);
        return legacy('.nodemonignore', function () {
          legacy('nodemon-ignore', function (options) {
            ready(options);
          });
        });
      }
      ready(options);
    });
  });
}
function loadLegacyIgnore(options, config, success, filename, fail) {
  var ignoreFile = path.join(process.cwd(), filename);
  exists(ignoreFile, function (exists) {
    if (exists) {
      config.loaded.push(ignoreFile);
      return parse(ignoreFile, function (error, rules) {
        options.ignore = rules.raw;
        success(options);
      });
    }
    if (fail) {
      fail(options);
    } else {
      success(options);
    }
  });
}
function normaliseRules(options, ready) {
  rules.watch.add(options.watch);
  rules.ignore.add(options.ignore);
  options.watch = options.watch === false ? false : rules.rules.watch;
  options.ignore = rules.rules.ignore;
  ready(options);
}
function loadFile(options, config, dir, ready) {
  if (!ready) {
    ready = function () { };
  }
  var callback = function (settings) {
    ready(utils.merge(settings, options));
  };
  if (!dir) {
    return callback({});
  }
  var filename = options.configFile || path.join(dir, 'nodemon.json');
  if (config.loaded.indexOf(filename) !== -1) {
    return callback({});
  }
  fs.readFile(filename, 'utf8', function (err, data) {
    if (err) {
      if (err.code === 'ENOENT') {
        if (!options.configFile && dir !== utils.home) {
          return loadPackageJSON(config, callback);
        }
      }
      return callback({});
    }
    var settings = {};
    try {
      settings = JSON.parse(data.toString('utf8').replace(/^\uFEFF/, ''));
      if (!filename.endsWith('package.json') || settings.nodemonConfig) {
        config.loaded.push(filename);
      }
    } catch (e) {
      utils.log.fail('Failed to parse config ' + filename);
      console.error(e);
      process.exit(1);
    }
    callback(settings);
  });
}
function loadPackageJSON(config, ready) {
  if (!ready) {
    ready = () => { };
  }
  const dir = process.cwd();
  const filename = path.join(dir, 'package.json');
  const packageLoadOptions = { configFile: filename };
  return loadFile(packageLoadOptions, config, dir, settings => {
    ready(settings.nodemonConfig || {});
  });
}
function mutateExecOptions(options) {
  options.execOptions = exec({
    script: options.script,
    exec: options.exec,
    args: options.args,
    scriptPosition: options.scriptPosition,
    nodeArgs: options.nodeArgs,
    execArgs: options.execArgs,
    ext: options.ext,
    env: options.env,
  }, options.execMap);
  delete options.scriptPosition;
  delete options.script;
  delete options.args;
  delete options.ext;
  return options;
}
