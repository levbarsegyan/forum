var should  = require('should'),
    needle  = require('./../'),
    Q       = require('q'),
    chardet = require('jschardet');
describe('character encoding', function() {
  var url;
  this.timeout(5000);
  describe('test A', function() {
    before(function() {
      url = 'http:
    })
    describe('with decode = false', function() {
      it('does not decode', function(done) {
        needle.get(url, { decode: false }, function(err, resp) {
          resp.body.should.be.a.String;
          chardet.detect(resp.body).encoding.should.eql('windows-1252');
          resp.body.indexOf('EUCを使う').should.eql(-1);
          done();
        })
      })
    })
    describe('with decode = true', function() {
      it('decodes', function(done) {
        needle.get(url, { decode: true }, function(err, resp) {
          resp.body.should.be.a.String;
          chardet.detect(resp.body).encoding.should.eql('ascii');
          resp.body.indexOf('EUCを使う').should.not.eql(-1);
          done();
        })
      })
    })
  })
  describe('test B', function() {
    it('encodes to UTF-8', function(done) {
      var task    = Q.nbind(needle.get, needle, 'http:
      var tasks   = [Q.fcall(task, {decode: true}),
                     Q.fcall(task, {decode: false})];
      var results = tasks.map(function(task) {
        return task.then(function(obj) {
          return obj[0].body;
        });
      });
      Q.all(results).done(function(bodies) {
        var charsets = [
          chardet.detect(bodies[0]).encoding,
          chardet.detect(bodies[1]).encoding,
        ]
        charsets[0].should.equal('ascii');
        bodies[0].indexOf('全球中文网站前二十强').should.not.equal(-1);
        charsets[1].should.equal('windows-1252');
        bodies[1].indexOf('全球中文网站前二十强').should.equal(-1);
        done();
      });
    })
  })
})
