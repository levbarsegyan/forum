'use strict';
var inherits = require('util').inherits,
  f = require('util').format,
  diff = require('./shared').diff,
  EventEmitter = require('events').EventEmitter,
  Logger = require('../connection/logger'),
  ReadPreference = require('./read_preference'),
  MongoError = require('../error').MongoError,
  Buffer = require('safe-buffer').Buffer;
var TopologyType = {
  Single: 'Single',
  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',
  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',
  Sharded: 'Sharded',
  Unknown: 'Unknown'
};
var ServerType = {
  Standalone: 'Standalone',
  Mongos: 'Mongos',
  PossiblePrimary: 'PossiblePrimary',
  RSPrimary: 'RSPrimary',
  RSSecondary: 'RSSecondary',
  RSArbiter: 'RSArbiter',
  RSOther: 'RSOther',
  RSGhost: 'RSGhost',
  Unknown: 'Unknown'
};
var ReplSetState = function(options) {
  options = options || {};
  EventEmitter.call(this);
  this.topologyType = TopologyType.ReplicaSetNoPrimary;
  this.setName = options.setName;
  this.set = {};
  this.id = options.id;
  this.setName = options.setName;
  this.logger = options.logger || Logger('ReplSet', options);
  this.index = 0;
  this.acceptableLatency = options.acceptableLatency || 15;
  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;
  this.primary = null;
  this.secondaries = [];
  this.arbiters = [];
  this.passives = [];
  this.ghosts = [];
  this.unknownServers = [];
  this.set = {};
  this.maxElectionId = null;
  this.maxSetVersion = 0;
  this.replicasetDescription = {
    topologyType: 'Unknown',
    servers: []
  };
  this.logicalSessionTimeoutMinutes = undefined;
};
inherits(ReplSetState, EventEmitter);
ReplSetState.prototype.hasPrimaryAndSecondary = function() {
  return this.primary != null && this.secondaries.length > 0;
};
ReplSetState.prototype.hasPrimaryOrSecondary = function() {
  return this.hasPrimary() || this.hasSecondary();
};
ReplSetState.prototype.hasPrimary = function() {
  return this.primary != null;
};
ReplSetState.prototype.hasSecondary = function() {
  return this.secondaries.length > 0;
};
ReplSetState.prototype.get = function(host) {
  var servers = this.allServers();
  for (var i = 0; i < servers.length; i++) {
    if (servers[i].name.toLowerCase() === host.toLowerCase()) {
      return servers[i];
    }
  }
  return null;
};
ReplSetState.prototype.allServers = function(options) {
  options = options || {};
  var servers = this.primary ? [this.primary] : [];
  servers = servers.concat(this.secondaries);
  if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);
  servers = servers.concat(this.passives);
  return servers;
};
ReplSetState.prototype.destroy = function(options, callback) {
  const serversToDestroy = this.secondaries
    .concat(this.arbiters)
    .concat(this.passives)
    .concat(this.ghosts);
  if (this.primary) serversToDestroy.push(this.primary);
  let serverCount = serversToDestroy.length;
  const serverDestroyed = () => {
    serverCount--;
    if (serverCount > 0) {
      return;
    }
    this.secondaries = [];
    this.arbiters = [];
    this.passives = [];
    this.ghosts = [];
    this.unknownServers = [];
    this.set = {};
    this.primary = null;
    emitTopologyDescriptionChanged(this);
    if (typeof callback === 'function') {
      callback(null, null);
    }
  };
  if (serverCount === 0) {
    serverDestroyed();
    return;
  }
  serversToDestroy.forEach(server => server.destroy(options, serverDestroyed));
};
ReplSetState.prototype.remove = function(server, options) {
  options = options || {};
  var serverName = server.name.toLowerCase();
  var servers = this.primary ? [this.primary] : [];
  servers = servers.concat(this.secondaries);
  servers = servers.concat(this.arbiters);
  servers = servers.concat(this.passives);
  for (var i = 0; i < servers.length; i++) {
    if (
      !options.force &&
      servers[i].equals(server) &&
      servers[i].isConnected &&
      servers[i].isConnected()
    ) {
      return;
    }
  }
  if (this.set[serverName]) {
    this.set[serverName].type = ServerType.Unknown;
    this.set[serverName].electionId = null;
    this.set[serverName].setName = null;
    this.set[serverName].setVersion = null;
  }
  var removeType = null;
  if (this.primary && this.primary.equals(server)) {
    this.primary = null;
    this.topologyType = TopologyType.ReplicaSetNoPrimary;
    removeType = 'primary';
  }
  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;
  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;
  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;
  removeFrom(server, this.ghosts);
  removeFrom(server, this.unknownServers);
  this.unknownServers.push(serverName);
  if (removeType) {
    this.emit('left', removeType, server);
  }
};
const isArbiter = ismaster => ismaster.arbiterOnly && ismaster.setName;
ReplSetState.prototype.update = function(server) {
  var self = this;
  var ismaster = server.lastIsMaster();
  var serverName = server.name.toLowerCase();
  if (ismaster) {
    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
    hosts = hosts.map(function(s) {
      return s.toLowerCase();
    });
    for (var i = 0; i < hosts.length; i++) {
      if (
        this.unknownServers.indexOf(hosts[i]) === -1 &&
        (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)
      ) {
        this.unknownServers.push(hosts[i].toLowerCase());
      }
      if (!this.set[hosts[i]]) {
        this.set[hosts[i]] = {
          type: ServerType.Unknown,
          electionId: null,
          setName: null,
          setVersion: null
        };
      }
    }
  }
  if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
    self.set[serverName] = {
      type: ServerType.Unknown,
      setVersion: null,
      electionId: null,
      setName: null
    };
    self.set[serverName].type = ServerType.Unknown;
    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
    if (self.unknownServers.indexOf(server.name) === -1) {
      self.unknownServers.push(serverName);
    }
    return false;
  }
  if (ismaster.logicalSessionTimeoutMinutes !== undefined && !isArbiter(ismaster)) {
    if (
      self.logicalSessionTimeoutMinutes === undefined ||
      ismaster.logicalSessionTimeoutMinutes === null
    ) {
      self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
    } else {
      self.logicalSessionTimeoutMinutes = Math.min(
        self.logicalSessionTimeoutMinutes,
        ismaster.logicalSessionTimeoutMinutes
      );
    }
  }
  if (ismaster && ismaster.msg === 'isdbgrid') {
    if (this.primary && this.primary.name === serverName) {
      this.primary = null;
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
    }
    return false;
  }
  if (ismaster.isreplicaset) {
    self.set[serverName] = {
      type: ServerType.RSGhost,
      setVersion: null,
      electionId: null,
      setName: ismaster.setName
    };
    if (this.primary && this.primary.name === serverName) {
      this.primary = null;
    }
    this.topologyType = this.primary
      ? TopologyType.ReplicaSetWithPrimary
      : TopologyType.ReplicaSetNoPrimary;
    if (ismaster.setName) this.setName = ismaster.setName;
    return false;
  }
  if (
    (ismaster.setName && ismaster.hidden) ||
    (ismaster.setName &&
      !ismaster.ismaster &&
      !ismaster.secondary &&
      !ismaster.arbiterOnly &&
      !ismaster.passive)
  ) {
    self.set[serverName] = {
      type: ServerType.RSOther,
      setVersion: null,
      electionId: null,
      setName: ismaster.setName
    };
    this.topologyType = this.primary
      ? TopologyType.ReplicaSetWithPrimary
      : TopologyType.ReplicaSetNoPrimary;
    if (ismaster.setName) this.setName = ismaster.setName;
    return false;
  }
  if (ismaster && ismaster.ismaster && !ismaster.setName) {
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
    this.remove(server, { force: true });
    return false;
  }
  if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
    this.remove(server, { force: true });
    return false;
  }
  if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
    if (this.logger.isWarn()) {
      this.logger.warn(
        f(
          'the seedlist server was removed due to its address %s not matching its ismaster.me address %s',
          server.name,
          ismaster.me
        )
      );
    }
    delete this.set[serverName];
    removeFrom(server, self.unknownServers);
    server.destroy();
    if (this.primary && !this.primary.equals(server)) {
      this.topologyType = TopologyType.ReplicaSetWithPrimary;
    } else {
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
    }
    if (!this.primary && ismaster.primary) {
      this.set[ismaster.primary.toLowerCase()] = {
        type: ServerType.PossiblePrimary,
        setName: null,
        electionId: null,
        setVersion: null
      };
    }
    return false;
  }
  if (!this.primary && ismaster.ismaster && ismaster.setName) {
    var ismasterElectionId = server.lastIsMaster().electionId;
    if (this.setName && this.setName !== ismaster.setName) {
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      return new MongoError(
        f(
          'setName from ismaster does not match provided connection setName [%s] != [%s]',
          ismaster.setName,
          this.setName
        )
      );
    }
    if (!this.maxElectionId && ismasterElectionId) {
      this.maxElectionId = ismasterElectionId;
    } else if (this.maxElectionId && ismasterElectionId) {
      var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
      var ismasterSetVersion = server.lastIsMaster().setVersion;
      if (result === 1) {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      } else if (result === 0 && ismasterSetVersion) {
        if (ismasterSetVersion < this.maxSetVersion) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return false;
        }
      }
      this.maxSetVersion = ismasterSetVersion;
      this.maxElectionId = ismasterElectionId;
    }
    var normalizedHosts = ismaster.hosts.map(function(x) {
      return x.toLowerCase();
    });
    var locationIndex = normalizedHosts.indexOf(serverName);
    if (locationIndex !== -1) {
      self.primary = server;
      self.set[serverName] = {
        type: ServerType.RSPrimary,
        setVersion: ismaster.setVersion,
        electionId: ismaster.electionId,
        setName: ismaster.setName
      };
      this.topologyType = TopologyType.ReplicaSetWithPrimary;
      if (ismaster.setName) this.setName = ismaster.setName;
      removeFrom(server, self.unknownServers);
      removeFrom(server, self.secondaries);
      removeFrom(server, self.passives);
      self.emit('joined', 'primary', server);
    } else {
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
    }
    emitTopologyDescriptionChanged(self);
    return true;
  } else if (ismaster.ismaster && ismaster.setName) {
    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;
    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;
    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;
    ismasterElectionId = server.lastIsMaster().electionId;
    ismasterSetVersion = server.lastIsMaster().setVersion;
    var ismasterSetName = server.lastIsMaster().setName;
    if (this.primary.equals(server) && currentSetName === ismasterSetName) {
      return false;
    }
    if (currentSetName && currentSetName !== ismasterSetName) {
      if (!this.primary.equals(server)) {
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
      } else {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      return false;
    }
    if (currentElectionId && ismasterElectionId) {
      result = compareObjectIds(currentElectionId, ismasterElectionId);
      if (result === 1) {
        return false;
      } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
        return false;
      }
    } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
      if (ismasterSetVersion < this.maxSetVersion) {
        return false;
      }
    }
    if (!this.maxElectionId && ismasterElectionId) {
      this.maxElectionId = ismasterElectionId;
    } else if (this.maxElectionId && ismasterElectionId) {
      result = compareObjectIds(this.maxElectionId, ismasterElectionId);
      if (result === 1) {
        return false;
      } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
        if (ismasterSetVersion < this.maxSetVersion) {
          return false;
        }
      } else {
        if (ismasterSetVersion < this.maxSetVersion) {
          return false;
        }
      }
      this.maxElectionId = ismasterElectionId;
      this.maxSetVersion = ismasterSetVersion;
    } else {
      this.maxSetVersion = ismasterSetVersion;
    }
    self.set[self.primary.name.toLowerCase()] = {
      type: ServerType.Unknown,
      setVersion: null,
      electionId: null,
      setName: null
    };
    self.emit('left', 'primary', this.primary);
    self.primary.destroy();
    self.primary = server;
    self.set[serverName] = {
      type: ServerType.RSPrimary,
      setVersion: ismaster.setVersion,
      electionId: ismaster.electionId,
      setName: ismaster.setName
    };
    this.topologyType = TopologyType.ReplicaSetWithPrimary;
    if (ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);
    removeFrom(server, self.secondaries);
    removeFrom(server, self.passives);
    self.emit('joined', 'primary', server);
    emitTopologyDescriptionChanged(self);
    return true;
  }
  if (!this.primary && ismaster.primary) {
    self.set[ismaster.primary.toLowerCase()] = {
      type: ServerType.PossiblePrimary,
      setVersion: null,
      electionId: null,
      setName: null
    };
  }
  if (
    ismaster.secondary &&
    ismaster.setName &&
    !inList(ismaster, server, this.secondaries) &&
    this.setName &&
    this.setName === ismaster.setName
  ) {
    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);
    this.topologyType = this.primary
      ? TopologyType.ReplicaSetWithPrimary
      : TopologyType.ReplicaSetNoPrimary;
    if (ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);
    if (this.primary && this.primary.name.toLowerCase() === serverName) {
      server.destroy();
      this.primary = null;
      self.emit('left', 'primary', server);
    }
    self.emit('joined', 'secondary', server);
    emitTopologyDescriptionChanged(self);
    return true;
  }
  if (
    isArbiter(ismaster) &&
    !inList(ismaster, server, this.arbiters) &&
    this.setName &&
    this.setName === ismaster.setName
  ) {
    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);
    this.topologyType = this.primary
      ? TopologyType.ReplicaSetWithPrimary
      : TopologyType.ReplicaSetNoPrimary;
    if (ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);
    self.emit('joined', 'arbiter', server);
    emitTopologyDescriptionChanged(self);
    return true;
  }
  if (
    ismaster.passive &&
    ismaster.setName &&
    !inList(ismaster, server, this.passives) &&
    this.setName &&
    this.setName === ismaster.setName
  ) {
    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);
    this.topologyType = this.primary
      ? TopologyType.ReplicaSetWithPrimary
      : TopologyType.ReplicaSetNoPrimary;
    if (ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);
    if (this.primary && this.primary.name.toLowerCase() === serverName) {
      server.destroy();
      this.primary = null;
      self.emit('left', 'primary', server);
    }
    self.emit('joined', 'secondary', server);
    emitTopologyDescriptionChanged(self);
    return true;
  }
  if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
    self.emit('left', 'primary', this.primary);
    this.primary.destroy();
    this.primary = null;
    this.topologyType = TopologyType.ReplicaSetNoPrimary;
    return false;
  }
  this.topologyType = this.primary
    ? TopologyType.ReplicaSetWithPrimary
    : TopologyType.ReplicaSetNoPrimary;
  return false;
};
ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
  var max = 0;
  for (var i = 0; i < this.secondaries.length; i++) {
    max = Math.max(max, this.secondaries[i].lastWriteDate);
  }
  if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
    server.staleness =
      server.lastUpdateTime -
      server.lastWriteDate -
      (this.primary.lastUpdateTime - this.primary.lastWriteDate) +
      haInterval;
  } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
    server.staleness = max - server.lastWriteDate + haInterval;
  }
};
ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
  for (var i = 0; i < this.secondaries.length; i++) {
    this.updateServerMaxStaleness(this.secondaries[i], haInterval);
  }
};
ReplSetState.prototype.pickServer = function(readPreference) {
  readPreference = readPreference || ReadPreference.primary;
  if (readPreference.preference === 'primary' && readPreference.maxStalenessSeconds != null) {
    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');
  }
  var allservers = this.primary ? [this.primary] : [];
  allservers = allservers.concat(this.secondaries);
  if (readPreference.maxStalenessSeconds != null) {
    for (var i = 0; i < allservers.length; i++) {
      if (allservers[i].ismaster.maxWireVersion < 5) {
        return new MongoError(
          'maxStalenessSeconds not supported by at least one of the replicaset members'
        );
      }
    }
  }
  if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds == null) {
    return pickNearest(this, readPreference);
  } else if (
    readPreference.preference === 'nearest' &&
    readPreference.maxStalenessSeconds != null
  ) {
    return pickNearestMaxStalenessSeconds(this, readPreference);
  }
  var secondaries = this.secondaries;
  if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
    return new MongoError('no secondary server available');
  }
  if (
    readPreference.equals(ReadPreference.secondaryPreferred) &&
    secondaries.length === 0 &&
    this.primary == null
  ) {
    return new MongoError('no secondary or primary server available');
  }
  if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
    return new MongoError('no primary server available');
  }
  if (
    readPreference.equals(ReadPreference.secondaryPreferred) ||
    readPreference.equals(ReadPreference.secondary)
  ) {
    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
      var server = pickNearest(this, readPreference);
      if (server) {
        return server;
      }
    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
      server = pickNearestMaxStalenessSeconds(this, readPreference);
      if (server) {
        return server;
      }
    }
    if (readPreference.equals(ReadPreference.secondaryPreferred)) {
      return this.primary;
    }
    return null;
  }
  if (readPreference.equals(ReadPreference.primaryPreferred)) {
    server = null;
    if (this.primary) {
      return this.primary;
    }
    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
      server = pickNearest(this, readPreference);
    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
      server = pickNearestMaxStalenessSeconds(this, readPreference);
    }
    if (server) return server;
  }
  return this.primary;
};
var filterByTags = function(readPreference, servers) {
  if (readPreference.tags == null) return servers;
  var filteredServers = [];
  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
  for (var j = 0; j < tagsArray.length; j++) {
    var tags = tagsArray[j];
    for (var i = 0; i < servers.length; i++) {
      var serverTag = servers[i].lastIsMaster().tags || {};
      var found = true;
      for (var name in tags) {
        if (serverTag[name] !== tags[name]) {
          found = false;
        }
      }
      if (found) {
        filteredServers.push(servers[i]);
      }
    }
  }
  return filteredServers;
};
function pickNearestMaxStalenessSeconds(self, readPreference) {
  var servers = [];
  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;
  if (maxStalenessMS < 90 * 1000) {
    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');
  }
  if (
    self.primary &&
    readPreference.preference !== 'secondary' &&
    readPreference.preference !== 'secondaryPreferred'
  ) {
    servers.push(self.primary);
  }
  for (var i = 0; i < self.secondaries.length; i++) {
    servers.push(self.secondaries[i]);
  }
  if (self.primary && servers.length === 0 && readPreference.preference !== 'secondaryPreferred') {
    servers.push(self.primary);
  }
  servers = filterByTags(readPreference, servers);
  servers = servers.filter(function(s) {
    return s.staleness <= maxStalenessMS;
  });
  servers.sort(function(a, b) {
    return a.lastIsMasterMS - b.lastIsMasterMS;
  });
  if (servers.length === 0) {
    return null;
  }
  self.index = self.index % servers.length;
  var server = servers[self.index];
  self.index = self.index + 1;
  return server;
}
function pickNearest(self, readPreference) {
  var servers = [];
  if (
    self.primary &&
    readPreference.preference !== 'secondary' &&
    readPreference.preference !== 'secondaryPreferred'
  ) {
    servers.push(self.primary);
  }
  for (var i = 0; i < self.secondaries.length; i++) {
    servers.push(self.secondaries[i]);
  }
  if (servers.length === 0 && self.primary && readPreference.preference !== 'secondaryPreferred') {
    servers.push(self.primary);
  }
  servers = filterByTags(readPreference, servers);
  servers.sort(function(a, b) {
    return a.lastIsMasterMS - b.lastIsMasterMS;
  });
  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
  servers = servers.filter(function(s) {
    return s.lastIsMasterMS <= lowest + self.acceptableLatency;
  });
  if (servers.length === 0) {
    return null;
  }
  self.index = self.index % servers.length;
  var server = servers[self.index];
  self.index = self.index + 1;
  return server;
}
function inList(ismaster, server, list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
      return true;
  }
  return false;
}
function addToList(self, type, ismaster, server, list) {
  var serverName = server.name.toLowerCase();
  self.set[serverName].type = type;
  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
  list.push(server);
}
function compareObjectIds(id1, id2) {
  var a = Buffer.from(id1.toHexString(), 'hex');
  var b = Buffer.from(id2.toHexString(), 'hex');
  if (a === b) {
    return 0;
  }
  if (typeof Buffer.compare === 'function') {
    return Buffer.compare(a, b);
  }
  var x = a.length;
  var y = b.length;
  var len = Math.min(x, y);
  for (var i = 0; i < len; i++) {
    if (a[i] !== b[i]) {
      break;
    }
  }
  if (i !== len) {
    x = a[i];
    y = b[i];
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function removeFrom(server, list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].equals && list[i].equals(server)) {
      list.splice(i, 1);
      return true;
    } else if (typeof list[i] === 'string' && list[i].toLowerCase() === server.name.toLowerCase()) {
      list.splice(i, 1);
      return true;
    }
  }
  return false;
}
function emitTopologyDescriptionChanged(self) {
  if (self.listeners('topologyDescriptionChanged').length > 0) {
    var topology = 'Unknown';
    var setName = self.setName;
    if (self.hasPrimaryAndSecondary()) {
      topology = 'ReplicaSetWithPrimary';
    } else if (!self.hasPrimary() && self.hasSecondary()) {
      topology = 'ReplicaSetNoPrimary';
    }
    var description = {
      topologyType: topology,
      setName: setName,
      servers: []
    };
    if (self.hasPrimary()) {
      var desc = self.primary.getDescription();
      desc.type = 'RSPrimary';
      description.servers.push(desc);
    }
    description.servers = description.servers.concat(
      self.secondaries.map(function(x) {
        var description = x.getDescription();
        description.type = 'RSSecondary';
        return description;
      })
    );
    description.servers = description.servers.concat(
      self.arbiters.map(function(x) {
        var description = x.getDescription();
        description.type = 'RSArbiter';
        return description;
      })
    );
    description.servers = description.servers.concat(
      self.passives.map(function(x) {
        var description = x.getDescription();
        description.type = 'RSSecondary';
        return description;
      })
    );
    var diffResult = diff(self.replicasetDescription, description);
    var result = {
      topologyId: self.id,
      previousDescription: self.replicasetDescription,
      newDescription: description,
      diff: diffResult
    };
    self.emit('topologyDescriptionChanged', result);
    self.replicasetDescription = description;
  }
}
module.exports = ReplSetState;
