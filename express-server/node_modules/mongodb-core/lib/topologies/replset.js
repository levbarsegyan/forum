'use strict';
const inherits = require('util').inherits;
const f = require('util').format;
const EventEmitter = require('events').EventEmitter;
const ReadPreference = require('./read_preference');
const BasicCursor = require('../cursor');
const retrieveBSON = require('../connection/utils').retrieveBSON;
const Logger = require('../connection/logger');
const MongoError = require('../error').MongoError;
const Server = require('./server');
const ReplSetState = require('./replset_state');
const clone = require('./shared').clone;
const Timeout = require('./shared').Timeout;
const Interval = require('./shared').Interval;
const createClientInfo = require('./shared').createClientInfo;
const SessionMixins = require('./shared').SessionMixins;
const isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;
const relayEvents = require('../utils').relayEvents;
const isRetryableError = require('../error').isRetryableError;
const BSON = retrieveBSON();
var DISCONNECTED = 'disconnected';
var CONNECTING = 'connecting';
var CONNECTED = 'connected';
var UNREFERENCED = 'unreferenced';
var DESTROYED = 'destroyed';
function stateTransition(self, newState) {
  var legalTransitions = {
    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
    unreferenced: [UNREFERENCED, DESTROYED],
    destroyed: [DESTROYED]
  };
  var legalStates = legalTransitions[self.state];
  if (legalStates && legalStates.indexOf(newState) !== -1) {
    self.state = newState;
  } else {
    self.s.logger.error(
      f(
        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',
        self.id,
        self.state,
        newState,
        legalStates
      )
    );
  }
}
var id = 1;
var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];
var ReplSet = function(seedlist, options) {
  var self = this;
  options = options || {};
  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array');
  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry');
  seedlist.forEach(function(e) {
    if (typeof e.host !== 'string' || typeof e.port !== 'number')
      throw new MongoError('seedlist entry must contain a host and port');
  });
  EventEmitter.call(this);
  this.id = id++;
  var localThresholdMS = options.localThresholdMS || 15;
  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency;
  var logger = Logger('ReplSet', options);
  this.s = {
    options: Object.assign({}, options),
    bson:
      options.bson ||
      new BSON([
        BSON.Binary,
        BSON.Code,
        BSON.DBRef,
        BSON.Decimal128,
        BSON.Double,
        BSON.Int32,
        BSON.Long,
        BSON.Map,
        BSON.MaxKey,
        BSON.MinKey,
        BSON.ObjectId,
        BSON.BSONRegExp,
        BSON.Symbol,
        BSON.Timestamp
      ]),
    Cursor: options.cursorFactory || BasicCursor,
    logger: logger,
    seedlist: seedlist,
    replicaSetState: new ReplSetState({
      id: this.id,
      setName: options.setName,
      acceptableLatency: localThresholdMS,
      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,
      logger: logger
    }),
    connectingServers: [],
    haInterval: options.haInterval ? options.haInterval : 10000,
    minHeartbeatFrequencyMS: 500,
    disconnectHandler: options.disconnectHandler,
    index: 0,
    connectOptions: {},
    debug: typeof options.debug === 'boolean' ? options.debug : false,
    clientInfo: createClientInfo(options)
  };
  this.s.replicaSetState.on('topologyDescriptionChanged', function(r) {
    self.emit('topologyDescriptionChanged', r);
  });
  if (
    this.s.logger.isWarn() &&
    this.s.options.socketTimeout !== 0 &&
    this.s.options.socketTimeout < this.s.haInterval
  ) {
    this.s.logger.warn(
      f(
        'warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts',
        this.s.options.socketTimeout,
        this.s.haInterval
      )
    );
  }
  var types = ['joined', 'left'];
  types.forEach(function(x) {
    self.s.replicaSetState.on(x, function(t, s) {
      self.emit(x, t, s);
    });
  });
  this.initialConnectState = {
    connect: false,
    fullsetup: false,
    all: false
  };
  this.state = DISCONNECTED;
  this.haTimeoutId = null;
  this.ismaster = null;
  this.intervalIds = [];
  this.clusterTime = null;
};
inherits(ReplSet, EventEmitter);
Object.assign(ReplSet.prototype, SessionMixins);
Object.defineProperty(ReplSet.prototype, 'type', {
  enumerable: true,
  get: function() {
    return 'replset';
  }
});
Object.defineProperty(ReplSet.prototype, 'parserType', {
  enumerable: true,
  get: function() {
    return BSON.native ? 'c++' : 'js';
  }
});
Object.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {
  enumerable: true,
  get: function() {
    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
  }
});
function rexecuteOperations(self) {
  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {
    self.s.disconnectHandler.execute();
  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {
    self.s.disconnectHandler.execute({ executePrimary: true });
  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {
    self.s.disconnectHandler.execute({ executeSecondary: true });
  }
}
function connectNewServers(self, servers, callback) {
  var count = servers.length;
  var error = null;
  var _handleEvent = function(self, event) {
    return function(err) {
      var _self = this;
      count = count - 1;
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        return this.destroy({ force: true });
      }
      if (event === 'connect') {
        if (self.state === DESTROYED || self.state === UNREFERENCED) {
          return _self.destroy({ force: true });
        }
        var result = self.s.replicaSetState.update(_self);
        if (result) {
          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
            self.ismaster = _self.lastIsMaster();
          }
          for (let i = 0; i < handlers.length; i++) {
            _self.removeAllListeners(handlers[i]);
          }
          _self.on('error', handleEvent(self, 'error'));
          _self.on('close', handleEvent(self, 'close'));
          _self.on('timeout', handleEvent(self, 'timeout'));
          _self.on('parseError', handleEvent(self, 'parseError'));
          monitorServer(_self.lastIsMaster().me, self, {});
          rexecuteOperations(self);
        } else {
          _self.destroy({ force: true });
        }
      } else if (event === 'error') {
        error = err;
      }
      rexecuteOperations(self);
      if (count === 0) {
        callback(error);
      }
    };
  };
  if (count === 0) return callback();
  function execute(_server, i) {
    setTimeout(function() {
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        return;
      }
      var server = new Server(
        Object.assign({}, self.s.options, {
          host: _server.split(':')[0],
          port: parseInt(_server.split(':')[1], 10),
          reconnect: false,
          monitoring: false,
          parent: self,
          clientInfo: clone(self.s.clientInfo)
        })
      );
      server.once('connect', _handleEvent(self, 'connect'));
      server.once('close', _handleEvent(self, 'close'));
      server.once('timeout', _handleEvent(self, 'timeout'));
      server.once('error', _handleEvent(self, 'error'));
      server.once('parseError', _handleEvent(self, 'parseError'));
      server.on('serverOpening', e => self.emit('serverOpening', e));
      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));
      server.on('serverClosed', e => self.emit('serverClosed', e));
      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);
      server.connect(self.s.connectOptions);
    }, i);
  }
  for (var i = 0; i < servers.length; i++) {
    execute(servers[i], i);
  }
}
var pingServer = function(self, server, cb) {
  var start = new Date().getTime();
  emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: server.name });
  server.command(
    'admin.$cmd',
    {
      ismaster: true
    },
    {
      monitoring: true,
      socketTimeout: self.s.options.connectionTimeout || 2000
    },
    function(err, r) {
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        server.destroy({ force: true });
        return cb(err, r);
      }
      var latencyMS = new Date().getTime() - start;
      var hrTime = process.hrtime();
      server.lastUpdateTime = hrTime[0] * 1000 + Math.round(hrTime[1] / 1000);
      if (err) {
        emitSDAMEvent(self, 'serverHeartbeatFailed', {
          durationMS: latencyMS,
          failure: err,
          connectionId: server.name
        });
        self.s.replicaSetState.remove(server);
      } else {
        server.ismaster = r.result;
        if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
          server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
        }
        if (server.lastIsMasterMS === -1) {
          server.lastIsMasterMS = latencyMS;
        } else if (server.lastIsMasterMS) {
          server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
        }
        if (self.s.replicaSetState.update(server)) {
          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
            self.ismaster = server.lastIsMaster();
          }
        }
        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {
          durationMS: latencyMS,
          reply: r.result,
          connectionId: server.name
        });
      }
      self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);
      cb(err, r);
    }
  );
};
var monitorServer = function(host, self, options) {
  if (!options.haInterval) {
    for (var i = 0; i < self.intervalIds.length; i++) {
      if (self.intervalIds[i].__host === host) {
        return;
      }
    }
  }
  var _process = options.haInterval ? Timeout : Interval;
  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;
  var intervalId = new _process(function() {
    if (self.state === DESTROYED || self.state === UNREFERENCED) {
      intervalId.stop();
      return;
    }
    var _server = self.s.replicaSetState.get(host);
    if (_server) {
      return pingServer(self, _server, function(err) {
        if (err) {
          return;
        }
        if (self.state === DESTROYED || self.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        self.intervalIds = self.intervalIds.filter(function(intervalId) {
          return intervalId.isRunning();
        });
        if (_process === Timeout) {
          if (
            self.state === CONNECTING &&
            ((self.s.replicaSetState.hasSecondary() &&
              self.s.options.secondaryOnlyConnectionAllowed) ||
              self.s.replicaSetState.hasPrimary())
          ) {
            self.state = CONNECTED;
            process.nextTick(function() {
              self.emit('connect', self);
            });
            topologyMonitor(self, {});
          }
        } else {
          if (
            self.state === DISCONNECTED &&
            ((self.s.replicaSetState.hasSecondary() &&
              self.s.options.secondaryOnlyConnectionAllowed) ||
              self.s.replicaSetState.hasPrimary())
          ) {
            self.state = CONNECTED;
            rexecuteOperations(self);
            process.nextTick(function() {
              self.emit('reconnect', self);
            });
          }
        }
        if (
          self.initialConnectState.connect &&
          !self.initialConnectState.fullsetup &&
          self.s.replicaSetState.hasPrimaryAndSecondary()
        ) {
          self.initialConnectState.fullsetup = true;
          self.initialConnectState.all = true;
          process.nextTick(function() {
            self.emit('fullsetup', self);
            self.emit('all', self);
          });
        }
      });
    }
  }, _haInterval);
  intervalId.start();
  intervalId.__host = host;
  self.intervalIds.push(intervalId);
};
function topologyMonitor(self, options) {
  if (self.state === DESTROYED || self.state === UNREFERENCED) return;
  options = options || {};
  var servers = Object.keys(self.s.replicaSetState.set);
  var _process = options.haInterval ? Timeout : Interval;
  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;
  if (_process === Timeout) {
    return connectNewServers(self, self.s.replicaSetState.unknownServers, function(err) {
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        return;
      }
      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {
        if (err) {
          return self.emit('error', err);
        }
        self.emit(
          'error',
          new MongoError('no primary found in replicaset or invalid replica set name')
        );
        return self.destroy({ force: true });
      } else if (
        !self.s.replicaSetState.hasSecondary() &&
        self.s.options.secondaryOnlyConnectionAllowed
      ) {
        if (err) {
          return self.emit('error', err);
        }
        self.emit(
          'error',
          new MongoError('no secondary found in replicaset or invalid replica set name')
        );
        return self.destroy({ force: true });
      }
      for (var i = 0; i < servers.length; i++) {
        monitorServer(servers[i], self, options);
      }
    });
  } else {
    for (var i = 0; i < servers.length; i++) {
      monitorServer(servers[i], self, options);
    }
  }
  function executeReconnect(self) {
    return function() {
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        return;
      }
      connectNewServers(self, self.s.replicaSetState.unknownServers, function() {
        var monitoringFrequencey = self.s.replicaSetState.hasPrimary()
          ? _haInterval
          : self.s.minHeartbeatFrequencyMS;
        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());
      });
    };
  }
  var intervalTime = !self.s.replicaSetState.hasPrimary()
    ? self.s.minHeartbeatFrequencyMS
    : _haInterval;
  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());
}
function addServerToList(list, server) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;
  }
  list.push(server);
}
function handleEvent(self, event) {
  return function() {
    if (self.state === DESTROYED || self.state === UNREFERENCED) return;
    if (self.s.logger.isDebug()) {
      self.s.logger.debug(
        f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id)
      );
    }
    self.s.replicaSetState.remove(this);
    if (self.state === DESTROYED || self.state === UNREFERENCED) return;
    if (
      !self.s.replicaSetState.hasPrimary() &&
      !self.s.replicaSetState.hasSecondary() &&
      self.s.options.secondaryOnlyConnectionAllowed
    ) {
      stateTransition(self, DISCONNECTED);
    } else if (!self.s.replicaSetState.hasPrimary()) {
      stateTransition(self, DISCONNECTED);
    }
    addServerToList(self.s.connectingServers, this);
  };
}
function shouldTriggerConnect(self) {
  const isConnecting = self.state === CONNECTING;
  const hasPrimary = self.s.replicaSetState.hasPrimary();
  const hasSecondary = self.s.replicaSetState.hasSecondary();
  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;
  const readPreferenceSecondary =
    self.s.connectOptions.readPreference &&
    self.s.connectOptions.readPreference.equals(ReadPreference.secondary);
  return (
    (isConnecting &&
      ((readPreferenceSecondary && hasSecondary) || (!readPreferenceSecondary && hasPrimary))) ||
    (hasSecondary && secondaryOnlyConnectionAllowed)
  );
}
function handleInitialConnectEvent(self, event) {
  return function() {
    var _this = this;
    if (self.s.logger.isDebug()) {
      self.s.logger.debug(
        f(
          'handleInitialConnectEvent %s from server %s in replset with id %s',
          event,
          this.name,
          self.id
        )
      );
    }
    if (self.state === DESTROYED || self.state === UNREFERENCED) {
      return this.destroy({ force: true });
    }
    if (event === 'connect') {
      var result = self.s.replicaSetState.update(_this);
      if (result === true) {
        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
          self.ismaster = _this.lastIsMaster();
        }
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(
            f(
              'handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]',
              event,
              _this.name,
              self.id,
              JSON.stringify(self.s.replicaSetState.set)
            )
          );
        }
        for (let i = 0; i < handlers.length; i++) {
          _this.removeAllListeners(handlers[i]);
        }
        _this.on('error', handleEvent(self, 'error'));
        _this.on('close', handleEvent(self, 'close'));
        _this.on('timeout', handleEvent(self, 'timeout'));
        _this.on('parseError', handleEvent(self, 'parseError'));
        if (shouldTriggerConnect(self)) {
          self.state = CONNECTED;
          self.initialConnectState.connect = true;
          process.nextTick(function() {
            self.emit('connect', self);
          });
          topologyMonitor(self, {});
        }
      } else if (result instanceof MongoError) {
        _this.destroy({ force: true });
        self.destroy({ force: true });
        return self.emit('error', result);
      } else {
        _this.destroy({ force: true });
      }
    } else {
      self.emit('failed', this);
      addServerToList(self.s.connectingServers, this);
      self.s.replicaSetState.remove(this);
    }
    if (
      self.initialConnectState.connect &&
      !self.initialConnectState.fullsetup &&
      self.s.replicaSetState.hasPrimaryAndSecondary()
    ) {
      self.initialConnectState.fullsetup = true;
      self.initialConnectState.all = true;
      process.nextTick(function() {
        self.emit('fullsetup', self);
        self.emit('all', self);
      });
    }
    for (var i = 0; i < self.s.connectingServers.length; i++) {
      if (self.s.connectingServers[i].equals(this)) {
        self.s.connectingServers.splice(i, 1);
      }
    }
    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {
      topologyMonitor(self, { haInterval: 1 });
    }
  };
}
function connectServers(self, servers) {
  self.s.connectingServers = self.s.connectingServers.concat(servers);
  var timeoutInterval = 0;
  function connect(server, timeoutInterval) {
    setTimeout(function() {
      if (self.s.replicaSetState.update(server)) {
        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
          self.ismaster = server.lastIsMaster();
        }
      }
      server.once('close', handleInitialConnectEvent(self, 'close'));
      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
      server.once('error', handleInitialConnectEvent(self, 'error'));
      server.once('connect', handleInitialConnectEvent(self, 'connect'));
      server.on('serverOpening', e => self.emit('serverOpening', e));
      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));
      server.on('serverClosed', e => self.emit('serverClosed', e));
      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);
      server.connect(self.s.connectOptions);
    }, timeoutInterval);
  }
  while (servers.length > 0) {
    connect(servers.shift(), timeoutInterval++);
  }
}
function emitSDAMEvent(self, event, description) {
  if (self.listeners(event).length > 0) {
    self.emit(event, description);
  }
}
ReplSet.prototype.connect = function(options) {
  var self = this;
  this.s.connectOptions = options || {};
  stateTransition(this, CONNECTING);
  var servers = this.s.seedlist.map(function(x) {
    return new Server(
      Object.assign({}, self.s.options, x, options, {
        reconnect: false,
        monitoring: false,
        parent: self,
        clientInfo: clone(self.s.clientInfo)
      })
    );
  });
  if (
    this.s.options.socketTimeout > 0 &&
    this.s.options.socketTimeout <= this.s.options.haInterval
  ) {
    return self.emit(
      'error',
      new MongoError(
        f(
          'haInterval [%s] MS must be set to less than socketTimeout [%s] MS',
          this.s.options.haInterval,
          this.s.options.socketTimeout
        )
      )
    );
  }
  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });
  connectServers(self, servers);
};
ReplSet.prototype.auth = function(credentials, callback) {
  if (typeof callback === 'function') callback(null, null);
};
ReplSet.prototype.destroy = function(options, callback) {
  options = options || {};
  let destroyCount = this.s.connectingServers.length + 1; 
  const serverDestroyed = () => {
    destroyCount--;
    if (destroyCount > 0) {
      return;
    }
    emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });
    stateTransition(this, DESTROYED);
    if (typeof callback === 'function') {
      callback(null, null);
    }
  };
  if (this.haTimeoutId) clearTimeout(this.haTimeoutId);
  for (var i = 0; i < this.intervalIds.length; i++) {
    this.intervalIds[i].stop();
  }
  this.intervalIds = [];
  if (destroyCount === 0) {
    serverDestroyed();
    return;
  }
  this.s.replicaSetState.destroy(options, serverDestroyed);
  this.s.connectingServers.forEach(function(x) {
    x.destroy(options, serverDestroyed);
  });
};
ReplSet.prototype.unref = function() {
  stateTransition(this, UNREFERENCED);
  this.s.replicaSetState.allServers().forEach(function(x) {
    x.unref();
  });
  clearTimeout(this.haTimeoutId);
};
ReplSet.prototype.lastIsMaster = function() {
  if (
    this.s.options.secondaryOnlyConnectionAllowed &&
    !this.s.replicaSetState.hasPrimary() &&
    this.s.replicaSetState.hasSecondary()
  ) {
    return this.s.replicaSetState.secondaries[0].lastIsMaster();
  }
  return this.s.replicaSetState.primary
    ? this.s.replicaSetState.primary.lastIsMaster()
    : this.ismaster;
};
ReplSet.prototype.connections = function() {
  var servers = this.s.replicaSetState.allServers();
  var connections = [];
  for (var i = 0; i < servers.length; i++) {
    connections = connections.concat(servers[i].connections());
  }
  return connections;
};
ReplSet.prototype.isConnected = function(options) {
  options = options || {};
  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {
    return this.s.replicaSetState.hasSecondary();
  }
  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {
    return this.s.replicaSetState.hasPrimary();
  }
  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {
    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
  }
  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
  }
  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
    return true;
  }
  return this.s.replicaSetState.hasPrimary();
};
ReplSet.prototype.isDestroyed = function() {
  return this.state === DESTROYED;
};
ReplSet.prototype.selectServer = function(selector, options, callback) {
  if (typeof selector === 'function' && typeof callback === 'undefined')
    (callback = selector), (selector = undefined), (options = {});
  if (typeof options === 'function')
    (callback = options), (options = selector), (selector = undefined);
  options = options || {};
  const server = this.s.replicaSetState.pickServer(options.readPreference);
  if (this.s.debug) this.emit('pickedServer', options.readPreference, server);
  callback(null, server);
};
ReplSet.prototype.getServers = function() {
  return this.s.replicaSetState.allServers();
};
function executeWriteOperation(args, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const self = args.self;
  const op = args.op;
  const ns = args.ns;
  const ops = args.ops;
  if (self.state === DESTROYED) {
    return callback(new MongoError(f('topology was destroyed')));
  }
  const willRetryWrite =
    !args.retrying &&
    !!options.retryWrites &&
    options.session &&
    isRetryableWritesSupported(self) &&
    !options.session.inTransaction();
  if (!self.s.replicaSetState.hasPrimary()) {
    if (self.s.disconnectHandler) {
      return self.s.disconnectHandler.add(op, ns, ops, options, callback);
    } else if (!willRetryWrite) {
      return callback(new MongoError('no primary server found'));
    }
  }
  const handler = (err, result) => {
    if (!err) return callback(null, result);
    if (!isRetryableError(err)) {
      return callback(err);
    }
    if (willRetryWrite) {
      const newArgs = Object.assign({}, args, { retrying: true });
      return executeWriteOperation(newArgs, options, callback);
    }
    if (self.s.replicaSetState.primary) {
      self.s.replicaSetState.remove(self.s.replicaSetState.primary, { force: true });
    }
    return callback(err);
  };
  if (callback.operationId) {
    handler.operationId = callback.operationId;
  }
  if (willRetryWrite) {
    options.session.incrementTransactionNumber();
    options.willRetryWrite = willRetryWrite;
  }
  self.s.replicaSetState.primary[op](ns, ops, options, handler);
}
ReplSet.prototype.insert = function(ns, ops, options, callback) {
  executeWriteOperation({ self: this, op: 'insert', ns, ops }, options, callback);
};
ReplSet.prototype.update = function(ns, ops, options, callback) {
  executeWriteOperation({ self: this, op: 'update', ns, ops }, options, callback);
};
ReplSet.prototype.remove = function(ns, ops, options, callback) {
  executeWriteOperation({ self: this, op: 'remove', ns, ops }, options, callback);
};
const RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];
function isWriteCommand(command) {
  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);
}
ReplSet.prototype.command = function(ns, cmd, options, callback) {
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));
  var self = this;
  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
  if (
    readPreference.preference === 'primary' &&
    !this.s.replicaSetState.hasPrimary() &&
    this.s.disconnectHandler != null
  ) {
    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
  } else if (
    readPreference.preference === 'secondary' &&
    !this.s.replicaSetState.hasSecondary() &&
    this.s.disconnectHandler != null
  ) {
    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
  } else if (
    readPreference.preference !== 'primary' &&
    !this.s.replicaSetState.hasSecondary() &&
    !this.s.replicaSetState.hasPrimary() &&
    this.s.disconnectHandler != null
  ) {
    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
  }
  var server = this.s.replicaSetState.pickServer(readPreference);
  if (!(server instanceof Server)) return callback(server);
  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);
  if (server == null) {
    return callback(
      new MongoError(
        f('no server found that matches the provided readPreference %s', readPreference)
      )
    );
  }
  const willRetryWrite =
    !options.retrying &&
    !!options.retryWrites &&
    options.session &&
    isRetryableWritesSupported(self) &&
    !options.session.inTransaction() &&
    isWriteCommand(cmd);
  const cb = (err, result) => {
    if (!err) return callback(null, result);
    if (!isRetryableError(err)) {
      return callback(err);
    }
    if (willRetryWrite) {
      const newOptions = Object.assign({}, options, { retrying: true });
      return this.command(ns, cmd, newOptions, callback);
    }
    if (this.s.replicaSetState.primary) {
      this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });
    }
    return callback(err);
  };
  if (willRetryWrite) {
    options.session.incrementTransactionNumber();
    options.willRetryWrite = willRetryWrite;
  }
  server.command(ns, cmd, options, cb);
};
ReplSet.prototype.cursor = function(ns, cmd, options) {
  options = options || {};
  const topology = options.topology || this;
  var FinalCursor = options.cursorFactory || this.s.Cursor;
  return new FinalCursor(this.s.bson, ns, cmd, options, topology, this.s.options);
};
module.exports = ReplSet;
