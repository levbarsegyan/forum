'use strict';
const inherits = require('util').inherits;
const f = require('util').format;
const EventEmitter = require('events').EventEmitter;
const BasicCursor = require('../cursor');
const Logger = require('../connection/logger');
const retrieveBSON = require('../connection/utils').retrieveBSON;
const MongoError = require('../error').MongoError;
const Server = require('./server');
const clone = require('./shared').clone;
const diff = require('./shared').diff;
const cloneOptions = require('./shared').cloneOptions;
const createClientInfo = require('./shared').createClientInfo;
const SessionMixins = require('./shared').SessionMixins;
const isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;
const relayEvents = require('../utils').relayEvents;
const isRetryableError = require('../error').isRetryableError;
const BSON = retrieveBSON();
var DISCONNECTED = 'disconnected';
var CONNECTING = 'connecting';
var CONNECTED = 'connected';
var UNREFERENCED = 'unreferenced';
var DESTROYED = 'destroyed';
function stateTransition(self, newState) {
  var legalTransitions = {
    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
    unreferenced: [UNREFERENCED, DESTROYED],
    destroyed: [DESTROYED]
  };
  var legalStates = legalTransitions[self.state];
  if (legalStates && legalStates.indexOf(newState) !== -1) {
    self.state = newState;
  } else {
    self.logger.error(
      f(
        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',
        self.id,
        self.state,
        newState,
        legalStates
      )
    );
  }
}
var id = 1;
var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];
var Mongos = function(seedlist, options) {
  options = options || {};
  this.id = id++;
  this.s = {
    options: Object.assign({}, options),
    bson:
      options.bson ||
      new BSON([
        BSON.Binary,
        BSON.Code,
        BSON.DBRef,
        BSON.Decimal128,
        BSON.Double,
        BSON.Int32,
        BSON.Long,
        BSON.Map,
        BSON.MaxKey,
        BSON.MinKey,
        BSON.ObjectId,
        BSON.BSONRegExp,
        BSON.Symbol,
        BSON.Timestamp
      ]),
    Cursor: options.cursorFactory || BasicCursor,
    logger: Logger('Mongos', options),
    seedlist: seedlist,
    haInterval: options.haInterval ? options.haInterval : 10000,
    disconnectHandler: options.disconnectHandler,
    index: 0,
    connectOptions: {},
    debug: typeof options.debug === 'boolean' ? options.debug : false,
    localThresholdMS: options.localThresholdMS || 15,
    clientInfo: createClientInfo(options)
  };
  this.s.options.clientInfo = createClientInfo(options);
  if (
    this.s.logger.isWarn() &&
    this.s.options.socketTimeout !== 0 &&
    this.s.options.socketTimeout < this.s.haInterval
  ) {
    this.s.logger.warn(
      f(
        'warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts',
        this.s.options.socketTimeout,
        this.s.haInterval
      )
    );
  }
  this.state = DISCONNECTED;
  this.connectingProxies = [];
  this.connectedProxies = [];
  this.disconnectedProxies = [];
  this.index = 0;
  this.haTimeoutId = null;
  this.ismaster = null;
  this.topologyDescription = {
    topologyType: 'Unknown',
    servers: []
  };
  this.clusterTime = null;
  EventEmitter.call(this);
};
inherits(Mongos, EventEmitter);
Object.assign(Mongos.prototype, SessionMixins);
Object.defineProperty(Mongos.prototype, 'type', {
  enumerable: true,
  get: function() {
    return 'mongos';
  }
});
Object.defineProperty(Mongos.prototype, 'parserType', {
  enumerable: true,
  get: function() {
    return BSON.native ? 'c++' : 'js';
  }
});
Object.defineProperty(Mongos.prototype, 'logicalSessionTimeoutMinutes', {
  enumerable: true,
  get: function() {
    if (!this.ismaster) return null;
    return this.ismaster.logicalSessionTimeoutMinutes || null;
  }
});
function emitSDAMEvent(self, event, description) {
  if (self.listeners(event).length > 0) {
    self.emit(event, description);
  }
}
const SERVER_EVENTS = ['serverDescriptionChanged', 'error', 'close', 'timeout', 'parseError'];
function destroyServer(server, options, callback) {
  options = options || {};
  SERVER_EVENTS.forEach(event => server.removeAllListeners(event));
  server.destroy(options, callback);
}
Mongos.prototype.connect = function(options) {
  var self = this;
  this.s.connectOptions = options || {};
  stateTransition(this, CONNECTING);
  var servers = this.s.seedlist.map(function(x) {
    const server = new Server(
      Object.assign({}, self.s.options, x, options, {
        reconnect: false,
        monitoring: false,
        parent: self,
        clientInfo: clone(self.s.clientInfo)
      })
    );
    relayEvents(server, self, ['serverDescriptionChanged']);
    return server;
  });
  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });
  connectProxies(self, servers);
};
Mongos.prototype.auth = function(credentials, callback) {
  if (typeof callback === 'function') callback(null, null);
};
function handleEvent(self) {
  return function() {
    if (self.state === DESTROYED) return;
    moveServerFrom(self.connectedProxies, self.disconnectedProxies, this);
    emitTopologyDescriptionChanged(self);
    self.emit('left', 'mongos', this);
    self.emit('serverClosed', {
      topologyId: self.id,
      address: this.name
    });
  };
}
function handleInitialConnectEvent(self, event) {
  return function() {
    var _this = this;
    if (self.state === DESTROYED) {
      emitTopologyDescriptionChanged(self);
      moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
      return this.destroy();
    }
    if (event === 'connect') {
      self.ismaster = _this.lastIsMaster();
      if (self.ismaster.msg === 'isdbgrid') {
        for (let i = 0; i < self.connectedProxies.length; i++) {
          if (self.connectedProxies[i].name === _this.name) {
            moveServerFrom(self.connectingProxies, self.disconnectedProxies, _this);
            emitTopologyDescriptionChanged(self);
            _this.destroy();
            return self.emit('failed', _this);
          }
        }
        for (let i = 0; i < handlers.length; i++) {
          _this.removeAllListeners(handlers[i]);
        }
        _this.on('error', handleEvent(self, 'error'));
        _this.on('close', handleEvent(self, 'close'));
        _this.on('timeout', handleEvent(self, 'timeout'));
        _this.on('parseError', handleEvent(self, 'parseError'));
        moveServerFrom(self.connectingProxies, self.connectedProxies, _this);
        self.emit('joined', 'mongos', _this);
      } else {
        if (self.s.logger.isWarn()) {
          var message = 'expected mongos proxy, but found replicaset member mongod for server %s';
          if (!self.ismaster.hosts) {
            message = 'expected mongos proxy, but found standalone mongod for server %s';
          }
          self.s.logger.warn(f(message, _this.name));
        }
        removeProxyFrom(self.connectingProxies, _this);
        self.emit('left', 'server', _this);
        self.emit('failed', _this);
      }
    } else {
      moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
      self.emit('left', 'mongos', this);
      self.emit('failed', this);
    }
    emitTopologyDescriptionChanged(self);
    if (self.connectingProxies.length === 0) {
      if (self.connectedProxies.length > 0 && self.state === CONNECTING) {
        stateTransition(self, CONNECTED);
        self.emit('connect', self);
        self.emit('fullsetup', self);
        self.emit('all', self);
      } else if (self.disconnectedProxies.length === 0) {
        if (self.s.logger.isWarn()) {
          self.s.logger.warn(
            f('no mongos proxies found in seed list, did you mean to connect to a replicaset')
          );
        }
        return self.emit('error', new MongoError('no mongos proxies found in seed list'));
      }
      topologyMonitor(self, { firstConnect: true });
    }
  };
}
function connectProxies(self, servers) {
  self.connectingProxies = self.connectingProxies.concat(servers);
  var timeoutInterval = 0;
  function connect(server, timeoutInterval) {
    setTimeout(function() {
      self.emit('serverOpening', {
        topologyId: self.id,
        address: server.name
      });
      emitTopologyDescriptionChanged(self);
      server.once('close', handleInitialConnectEvent(self, 'close'));
      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
      server.once('error', handleInitialConnectEvent(self, 'error'));
      server.once('connect', handleInitialConnectEvent(self, 'connect'));
      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);
      server.connect(self.s.connectOptions);
    }, timeoutInterval);
  }
  while (servers.length > 0) {
    connect(servers.shift(), timeoutInterval++);
  }
}
function pickProxy(self, session) {
  const transaction = session && session.transaction;
  if (transaction && transaction.server) {
    if (transaction.server.isConnected()) {
      return transaction.server;
    } else {
      transaction.unpinServer();
    }
  }
  var connectedProxies = self.connectedProxies.slice(0);
  var lowerBoundLatency = Number.MAX_VALUE;
  for (var i = 0; i < connectedProxies.length; i++) {
    if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
      lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
    }
  }
  connectedProxies = connectedProxies.filter(function(server) {
    if (
      server.lastIsMasterMS <= lowerBoundLatency + self.s.localThresholdMS &&
      server.isConnected()
    ) {
      return true;
    }
  });
  let proxy;
  if (connectedProxies.length === 0) {
    proxy = self.connectedProxies[0];
  } else {
    proxy = connectedProxies[self.index % connectedProxies.length];
    self.index = (self.index + 1) % connectedProxies.length;
  }
  if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
    transaction.pinServer(proxy);
  }
  return proxy;
}
function moveServerFrom(from, to, proxy) {
  for (var i = 0; i < from.length; i++) {
    if (from[i].name === proxy.name) {
      from.splice(i, 1);
    }
  }
  for (i = 0; i < to.length; i++) {
    if (to[i].name === proxy.name) {
      to.splice(i, 1);
    }
  }
  to.push(proxy);
}
function removeProxyFrom(from, proxy) {
  for (var i = 0; i < from.length; i++) {
    if (from[i].name === proxy.name) {
      from.splice(i, 1);
    }
  }
}
function reconnectProxies(self, proxies, callback) {
  var count = proxies.length;
  var _handleEvent = function(self, event) {
    return function() {
      var _self = this;
      count = count - 1;
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
        return this.destroy();
      }
      if (event === 'connect') {
        if (self.state === DESTROYED || self.state === UNREFERENCED) {
          moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
          return _self.destroy();
        }
        for (var i = 0; i < handlers.length; i++) {
          _self.removeAllListeners(handlers[i]);
        }
        _self.on('error', handleEvent(self, 'error'));
        _self.on('close', handleEvent(self, 'close'));
        _self.on('timeout', handleEvent(self, 'timeout'));
        _self.on('parseError', handleEvent(self, 'parseError'));
        moveServerFrom(self.connectingProxies, self.connectedProxies, _self);
        emitTopologyDescriptionChanged(self);
        self.emit('joined', 'mongos', _self);
      } else {
        moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
        this.destroy();
      }
      if (count === 0) {
        callback();
      }
    };
  };
  if (count === 0) {
    return callback();
  }
  function execute(_server, i) {
    setTimeout(function() {
      if (self.state === DESTROYED || self.state === UNREFERENCED) {
        return;
      }
      var server = new Server(
        Object.assign({}, self.s.options, {
          host: _server.name.split(':')[0],
          port: parseInt(_server.name.split(':')[1], 10),
          reconnect: false,
          monitoring: false,
          parent: self,
          clientInfo: clone(self.s.clientInfo)
        })
      );
      destroyServer(_server);
      removeProxyFrom(self.disconnectedProxies, _server);
      relayEvents(server, self, ['serverDescriptionChanged']);
      self.emit('serverOpening', {
        topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self.id,
        address: server.name
      });
      server.once('connect', _handleEvent(self, 'connect'));
      server.once('close', _handleEvent(self, 'close'));
      server.once('timeout', _handleEvent(self, 'timeout'));
      server.once('error', _handleEvent(self, 'error'));
      server.once('parseError', _handleEvent(self, 'parseError'));
      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);
      self.connectingProxies.push(server);
      server.connect(self.s.connectOptions);
    }, i);
  }
  for (var i = 0; i < proxies.length; i++) {
    execute(proxies[i], i);
  }
}
function topologyMonitor(self, options) {
  options = options || {};
  self.haTimeoutId = setTimeout(function() {
    if (self.state === DESTROYED || self.state === UNREFERENCED) return;
    if (self.isConnected() && self.s.disconnectHandler) {
      self.s.disconnectHandler.execute();
    }
    var proxies = self.connectedProxies.slice(0);
    var count = proxies.length;
    function pingServer(_self, _server, cb) {
      var start = new Date().getTime();
      emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: _server.name });
      _server.command(
        'admin.$cmd',
        {
          ismaster: true
        },
        {
          monitoring: true,
          socketTimeout: self.s.options.connectionTimeout || 2000
        },
        function(err, r) {
          if (self.state === DESTROYED || self.state === UNREFERENCED) {
            moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
            _server.destroy();
            return cb(err, r);
          }
          var latencyMS = new Date().getTime() - start;
          if (err) {
            emitSDAMEvent(self, 'serverHeartbeatFailed', {
              durationMS: latencyMS,
              failure: err,
              connectionId: _server.name
            });
            moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
          } else {
            _server.ismaster = r.result;
            _server.lastIsMasterMS = latencyMS;
            emitSDAMEvent(self, 'serverHeartbeatSucceeded', {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: _server.name
            });
          }
          cb(err, r);
        }
      );
    }
    if (proxies.length === 0) {
      if (self.listeners('close').length > 0 && self.state === CONNECTING) {
        self.emit('error', new MongoError('no mongos proxy available'));
      } else {
        self.emit('close', self);
      }
      return reconnectProxies(self, self.disconnectedProxies, function() {
        if (self.state === DESTROYED || self.state === UNREFERENCED) return;
        if (self.state === CONNECTING && options.firstConnect) {
          self.emit('connect', self);
          self.emit('fullsetup', self);
          self.emit('all', self);
        } else if (self.isConnected()) {
          self.emit('reconnect', self);
        } else if (!self.isConnected() && self.listeners('close').length > 0) {
          self.emit('close', self);
        }
        topologyMonitor(self);
      });
    }
    for (var i = 0; i < proxies.length; i++) {
      pingServer(self, proxies[i], function() {
        count = count - 1;
        if (count === 0) {
          if (self.state === DESTROYED || self.state === UNREFERENCED) return;
          reconnectProxies(self, self.disconnectedProxies, function() {
            if (self.state === DESTROYED || self.state === UNREFERENCED) return;
            topologyMonitor(self);
          });
        }
      });
    }
  }, self.s.haInterval);
}
Mongos.prototype.lastIsMaster = function() {
  return this.ismaster;
};
Mongos.prototype.unref = function() {
  stateTransition(this, UNREFERENCED);
  var proxies = this.connectedProxies.concat(this.connectingProxies);
  proxies.forEach(function(x) {
    x.unref();
  });
  clearTimeout(this.haTimeoutId);
};
Mongos.prototype.destroy = function(options, callback) {
  if (this.haTimeoutId) {
    clearTimeout(this.haTimeoutId);
  }
  const proxies = this.connectedProxies.concat(this.connectingProxies);
  let serverCount = proxies.length;
  const serverDestroyed = () => {
    serverCount--;
    if (serverCount > 0) {
      return;
    }
    emitTopologyDescriptionChanged(this);
    emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });
    stateTransition(this, DESTROYED);
    if (typeof callback === 'function') {
      callback(null, null);
    }
  };
  if (serverCount === 0) {
    serverDestroyed();
    return;
  }
  proxies.forEach(server => {
    this.emit('serverClosed', {
      topologyId: this.id,
      address: server.name
    });
    destroyServer(server, options, serverDestroyed);
    moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
  });
};
Mongos.prototype.isConnected = function() {
  return this.connectedProxies.length > 0;
};
Mongos.prototype.isDestroyed = function() {
  return this.state === DESTROYED;
};
function executeWriteOperation(args, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const self = args.self;
  const op = args.op;
  const ns = args.ns;
  const ops = args.ops;
  let server = pickProxy(self, options.session);
  if (!server) return callback(new MongoError('no mongos proxy available'));
  const willRetryWrite =
    !args.retrying &&
    !!options.retryWrites &&
    options.session &&
    isRetryableWritesSupported(self) &&
    !options.session.inTransaction();
  const handler = (err, result) => {
    if (!err) return callback(null, result);
    if (!isRetryableError(err) || !willRetryWrite) {
      return callback(err);
    }
    server = pickProxy(self, options.session);
    if (!server) {
      return callback(err);
    }
    const newArgs = Object.assign({}, args, { retrying: true });
    return executeWriteOperation(newArgs, options, callback);
  };
  if (callback.operationId) {
    handler.operationId = callback.operationId;
  }
  if (willRetryWrite) {
    options.session.incrementTransactionNumber();
    options.willRetryWrite = willRetryWrite;
  }
  server[op](ns, ops, options, handler);
}
Mongos.prototype.insert = function(ns, ops, options, callback) {
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));
  if (!this.isConnected() && this.s.disconnectHandler != null) {
    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
  }
  if (!this.isConnected()) {
    return callback(new MongoError('no mongos proxy available'));
  }
  executeWriteOperation({ self: this, op: 'insert', ns, ops }, options, callback);
};
Mongos.prototype.update = function(ns, ops, options, callback) {
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));
  if (!this.isConnected() && this.s.disconnectHandler != null) {
    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
  }
  if (!this.isConnected()) {
    return callback(new MongoError('no mongos proxy available'));
  }
  executeWriteOperation({ self: this, op: 'update', ns, ops }, options, callback);
};
Mongos.prototype.remove = function(ns, ops, options, callback) {
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));
  if (!this.isConnected() && this.s.disconnectHandler != null) {
    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
  }
  if (!this.isConnected()) {
    return callback(new MongoError('no mongos proxy available'));
  }
  executeWriteOperation({ self: this, op: 'remove', ns, ops }, options, callback);
};
const RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];
function isWriteCommand(command) {
  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);
}
Mongos.prototype.command = function(ns, cmd, options, callback) {
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));
  var self = this;
  var server = pickProxy(self, options.session);
  if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
  }
  if (server == null) {
    return callback(new MongoError('no mongos proxy available'));
  }
  var clonedOptions = cloneOptions(options);
  clonedOptions.topology = self;
  const willRetryWrite =
    !options.retrying &&
    options.retryWrites &&
    options.session &&
    isRetryableWritesSupported(self) &&
    !options.session.inTransaction() &&
    isWriteCommand(cmd);
  const cb = (err, result) => {
    if (!err) return callback(null, result);
    if (!isRetryableError(err)) {
      return callback(err);
    }
    if (willRetryWrite) {
      const newOptions = Object.assign({}, clonedOptions, { retrying: true });
      return this.command(ns, cmd, newOptions, callback);
    }
    return callback(err);
  };
  if (willRetryWrite) {
    options.session.incrementTransactionNumber();
    options.willRetryWrite = willRetryWrite;
  }
  server.command(ns, cmd, clonedOptions, cb);
};
Mongos.prototype.cursor = function(ns, cmd, options) {
  options = options || {};
  const topology = options.topology || this;
  var FinalCursor = options.cursorFactory || this.s.Cursor;
  return new FinalCursor(this.s.bson, ns, cmd, options, topology, this.s.options);
};
Mongos.prototype.selectServer = function(selector, options, callback) {
  if (typeof selector === 'function' && typeof callback === 'undefined')
    (callback = selector), (selector = undefined), (options = {});
  if (typeof options === 'function')
    (callback = options), (options = selector), (selector = undefined);
  options = options || {};
  const server = pickProxy(this, options.session);
  if (this.s.debug) this.emit('pickedServer', null, server);
  callback(null, server);
};
Mongos.prototype.connections = function() {
  var connections = [];
  for (var i = 0; i < this.connectedProxies.length; i++) {
    connections = connections.concat(this.connectedProxies[i].connections());
  }
  return connections;
};
function emitTopologyDescriptionChanged(self) {
  if (self.listeners('topologyDescriptionChanged').length > 0) {
    var topology = 'Unknown';
    if (self.connectedProxies.length > 0) {
      topology = 'Sharded';
    }
    var description = {
      topologyType: topology,
      servers: []
    };
    var proxies = self.disconnectedProxies.concat(self.connectingProxies);
    description.servers = description.servers.concat(
      proxies.map(function(x) {
        var description = x.getDescription();
        description.type = 'Unknown';
        return description;
      })
    );
    description.servers = description.servers.concat(
      self.connectedProxies.map(function(x) {
        var description = x.getDescription();
        description.type = 'Mongos';
        return description;
      })
    );
    var diffResult = diff(self.topologyDescription, description);
    var result = {
      topologyId: self.id,
      previousDescription: self.topologyDescription,
      newDescription: description,
      diff: diffResult
    };
    if (diffResult.servers.length > 0) {
      self.emit('topologyDescriptionChanged', result);
    }
    self.topologyDescription = description;
  }
}
module.exports = Mongos;
