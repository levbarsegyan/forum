'use strict';
var inherits = require('util').inherits,
  f = require('util').format,
  EventEmitter = require('events').EventEmitter,
  ReadPreference = require('./read_preference'),
  Logger = require('../connection/logger'),
  debugOptions = require('../connection/utils').debugOptions,
  retrieveBSON = require('../connection/utils').retrieveBSON,
  Pool = require('../connection/pool'),
  MongoError = require('../error').MongoError,
  MongoNetworkError = require('../error').MongoNetworkError,
  wireProtocol = require('../wireprotocol'),
  BasicCursor = require('../cursor'),
  sdam = require('./shared'),
  createClientInfo = require('./shared').createClientInfo,
  createCompressionInfo = require('./shared').createCompressionInfo,
  resolveClusterTime = require('./shared').resolveClusterTime,
  SessionMixins = require('./shared').SessionMixins,
  relayEvents = require('../utils').relayEvents;
const collationNotSupported = require('../utils').collationNotSupported;
var debugFields = [
  'reconnect',
  'reconnectTries',
  'reconnectInterval',
  'emitError',
  'cursorFactory',
  'host',
  'port',
  'size',
  'keepAlive',
  'keepAliveInitialDelay',
  'noDelay',
  'connectionTimeout',
  'checkServerIdentity',
  'socketTimeout',
  'ssl',
  'ca',
  'crl',
  'cert',
  'key',
  'rejectUnauthorized',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'servername'
];
var id = 0;
var serverAccounting = false;
var servers = {};
var BSON = retrieveBSON();
var Server = function(options) {
  options = options || {};
  EventEmitter.call(this);
  this.id = id++;
  this.s = {
    options: options,
    logger: Logger('Server', options),
    Cursor: options.cursorFactory || BasicCursor,
    bson:
      options.bson ||
      new BSON([
        BSON.Binary,
        BSON.Code,
        BSON.DBRef,
        BSON.Decimal128,
        BSON.Double,
        BSON.Int32,
        BSON.Long,
        BSON.Map,
        BSON.MaxKey,
        BSON.MinKey,
        BSON.ObjectId,
        BSON.BSONRegExp,
        BSON.Symbol,
        BSON.Timestamp
      ]),
    pool: null,
    disconnectHandler: options.disconnectHandler,
    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,
    inTopology: !!options.parent,
    monitoringInterval:
      typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,
    topologyId: -1,
    compression: { compressors: createCompressionInfo(options) },
    parent: options.parent
  };
  if (!this.s.parent) {
    this.s.clusterTime = null;
  }
  this.ismaster = null;
  this.lastIsMasterMS = -1;
  this.monitoringProcessId = null;
  this.initialConnect = true;
  this._type = 'server';
  this.clientInfo = createClientInfo(options);
  this.lastUpdateTime = 0;
  this.lastWriteDate = 0;
  this.staleness = 0;
};
inherits(Server, EventEmitter);
Object.assign(Server.prototype, SessionMixins);
Object.defineProperty(Server.prototype, 'type', {
  enumerable: true,
  get: function() {
    return this._type;
  }
});
Object.defineProperty(Server.prototype, 'parserType', {
  enumerable: true,
  get: function() {
    return BSON.native ? 'c++' : 'js';
  }
});
Object.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {
  enumerable: true,
  get: function() {
    if (!this.ismaster) return null;
    return this.ismaster.logicalSessionTimeoutMinutes || null;
  }
});
Object.defineProperty(Server.prototype, 'clusterTime', {
  enumerable: true,
  set: function(clusterTime) {
    const settings = this.s.parent ? this.s.parent : this.s;
    resolveClusterTime(settings, clusterTime);
  },
  get: function() {
    const settings = this.s.parent ? this.s.parent : this.s;
    return settings.clusterTime || null;
  }
});
Server.enableServerAccounting = function() {
  serverAccounting = true;
  servers = {};
};
Server.disableServerAccounting = function() {
  serverAccounting = false;
};
Server.servers = function() {
  return servers;
};
Object.defineProperty(Server.prototype, 'name', {
  enumerable: true,
  get: function() {
    return this.s.options.host + ':' + this.s.options.port;
  }
});
function disconnectHandler(self, type, ns, cmd, options, callback) {
  if (
    !self.s.pool.isConnected() &&
    self.s.options.reconnect &&
    self.s.disconnectHandler != null &&
    !options.monitoring
  ) {
    self.s.disconnectHandler.add(type, ns, cmd, options, callback);
    return true;
  }
  if (!self.s.pool.isConnected()) {
    callback(new MongoError(f('no connection available to server %s', self.name)));
    return true;
  }
}
function monitoringProcess(self) {
  return function() {
    if (self.s.pool.isDestroyed()) return;
    self.emit('monitoring', self);
    var start = new Date().getTime();
    self.command(
      'admin.$cmd',
      { ismaster: true },
      {
        socketTimeout:
          typeof self.s.options.connectionTimeout !== 'number'
            ? 2000
            : self.s.options.connectionTimeout,
        monitoring: true
      },
      (err, result) => {
        self.lastIsMasterMS = new Date().getTime() - start;
        if (self.s.pool.isDestroyed()) return;
        if (result) {
          self.ismaster = result.result;
        }
        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
      }
    );
  };
}
var eventHandler = function(self, event) {
  return function(err, conn) {
    if (self.s.logger.isInfo()) {
      var object = err instanceof MongoError ? JSON.stringify(err) : {};
      self.s.logger.info(
        f('server %s fired event %s out with message %s', self.name, event, object)
      );
    }
    if (event === 'connect') {
      self.initialConnect = false;
      self.ismaster = conn.ismaster;
      self.lastIsMasterMS = conn.lastIsMasterMS;
      if (conn.agreedCompressor) {
        self.s.pool.options.agreedCompressor = conn.agreedCompressor;
      }
      if (conn.zlibCompressionLevel) {
        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
      }
      if (conn.ismaster.$clusterTime) {
        const $clusterTime = conn.ismaster.$clusterTime;
        self.clusterTime = $clusterTime;
      }
      if (self.ismaster.msg === 'isdbgrid') {
        self._type = 'mongos';
      }
      if (self.s.monitoring) {
        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
      }
      sdam.emitServerDescriptionChanged(self, {
        address: self.name,
        arbiters: [],
        hosts: [],
        passives: [],
        type: sdam.getTopologyType(self)
      });
      if (!self.s.inTopology) {
        sdam.emitTopologyDescriptionChanged(self, {
          topologyType: 'Single',
          servers: [
            {
              address: self.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self)
            }
          ]
        });
      }
      if (self.s.logger.isInfo()) {
        self.s.logger.info(
          f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster))
        );
      }
      self.emit('connect', self);
    } else if (
      event === 'error' ||
      event === 'parseError' ||
      event === 'close' ||
      event === 'timeout' ||
      event === 'reconnect' ||
      event === 'attemptReconnect' ||
      'reconnectFailed'
    ) {
      if (
        serverAccounting &&
        ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1
      ) {
        if (!self.s.inTopology) {
          self.emit('topologyOpening', { topologyId: self.id });
        }
        delete servers[self.id];
      }
      if (event === 'close') {
        sdam.emitServerDescriptionChanged(self, {
          address: self.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: 'Unknown'
        });
      }
      if (event === 'reconnectFailed') {
        self.emit('reconnectFailed', err);
        if (self.listeners('error').length > 0) {
          self.emit('error', err);
        }
        return;
      }
      if (
        ['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 &&
        self.initialConnect &&
        ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1
      ) {
        self.initialConnect = false;
        return self.emit(
          'error',
          new MongoNetworkError(
            f('failed to connect to server [%s] on first connect [%s]', self.name, err)
          )
        );
      }
      if (event === 'reconnect') {
        sdam.emitServerDescriptionChanged(self, {
          address: self.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: sdam.getTopologyType(self)
        });
        return self.emit(event, self);
      }
      self.emit(event, err);
    }
  };
};
Server.prototype.connect = function(options) {
  var self = this;
  options = options || {};
  if (serverAccounting) servers[this.id] = this;
  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {
    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));
  }
  self.s.pool = new Pool(this, Object.assign(self.s.options, options, { bson: this.s.bson }));
  self.s.pool.on('close', eventHandler(self, 'close'));
  self.s.pool.on('error', eventHandler(self, 'error'));
  self.s.pool.on('timeout', eventHandler(self, 'timeout'));
  self.s.pool.on('parseError', eventHandler(self, 'parseError'));
  self.s.pool.on('connect', eventHandler(self, 'connect'));
  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));
  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));
  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);
  if (!self.s.inTopology) {
    this.emit('topologyOpening', { topologyId: self.id });
  }
  self.emit('serverOpening', {
    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,
    address: self.name
  });
  self.s.pool.connect();
};
Server.prototype.auth = function(credentials, callback) {
  if (typeof callback === 'function') callback(null, null);
};
Server.prototype.getDescription = function() {
  var ismaster = this.ismaster || {};
  var description = {
    type: sdam.getTopologyType(this),
    address: this.name
  };
  if (ismaster.hosts) description.hosts = ismaster.hosts;
  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;
  if (ismaster.passives) description.passives = ismaster.passives;
  if (ismaster.setName) description.setName = ismaster.setName;
  return description;
};
Server.prototype.lastIsMaster = function() {
  return this.ismaster;
};
Server.prototype.unref = function() {
  this.s.pool.unref();
};
Server.prototype.isConnected = function() {
  if (!this.s.pool) return false;
  return this.s.pool.isConnected();
};
Server.prototype.isDestroyed = function() {
  if (!this.s.pool) return false;
  return this.s.pool.isDestroyed();
};
function basicWriteValidations(self) {
  if (!self.s.pool) return new MongoError('server instance is not connected');
  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');
}
function basicReadValidations(self, options) {
  basicWriteValidations(self, options);
  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
    throw new Error('readPreference must be an instance of ReadPreference');
  }
}
Server.prototype.command = function(ns, cmd, options, callback) {
  var self = this;
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  var result = basicReadValidations(self, options);
  if (result) return callback(result);
  options = Object.assign({}, options, { wireProtocolCommand: false });
  if (self.s.logger.isDebug())
    self.s.logger.debug(
      f(
        'executing command [%s] against %s',
        JSON.stringify({
          ns: ns,
          cmd: cmd,
          options: debugOptions(debugFields, options)
        }),
        self.name
      )
    );
  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;
  if (collationNotSupported(this, cmd)) {
    return callback(new MongoError(`server ${this.name} does not support collation`));
  }
  wireProtocol.command(self, ns, cmd, options, callback);
};
Server.prototype.insert = function(ns, ops, options, callback) {
  var self = this;
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  var result = basicWriteValidations(self, options);
  if (result) return callback(result);
  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;
  ops = Array.isArray(ops) ? ops : [ops];
  return wireProtocol.insert(self, ns, ops, options, callback);
};
Server.prototype.update = function(ns, ops, options, callback) {
  var self = this;
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  var result = basicWriteValidations(self, options);
  if (result) return callback(result);
  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;
  if (collationNotSupported(this, options)) {
    return callback(new MongoError(`server ${this.name} does not support collation`));
  }
  ops = Array.isArray(ops) ? ops : [ops];
  return wireProtocol.update(self, ns, ops, options, callback);
};
Server.prototype.remove = function(ns, ops, options, callback) {
  var self = this;
  if (typeof options === 'function') {
    (callback = options), (options = {}), (options = options || {});
  }
  var result = basicWriteValidations(self, options);
  if (result) return callback(result);
  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;
  if (collationNotSupported(this, options)) {
    return callback(new MongoError(`server ${this.name} does not support collation`));
  }
  ops = Array.isArray(ops) ? ops : [ops];
  return wireProtocol.remove(self, ns, ops, options, callback);
};
Server.prototype.cursor = function(ns, cmd, options) {
  options = options || {};
  const topology = options.topology || this;
  var FinalCursor = options.cursorFactory || this.s.Cursor;
  return new FinalCursor(this.s.bson, ns, cmd, options, topology, this.s.options);
};
Server.prototype.equals = function(server) {
  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();
  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();
  return false;
};
Server.prototype.connections = function() {
  return this.s.pool.allConnections();
};
Server.prototype.selectServer = function(selector, options, callback) {
  if (typeof selector === 'function' && typeof callback === 'undefined')
    (callback = selector), (selector = undefined), (options = {});
  if (typeof options === 'function')
    (callback = options), (options = selector), (selector = undefined);
  callback(null, this);
};
var listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];
Server.prototype.destroy = function(options, callback) {
  if (this._destroyed) {
    if (typeof callback === 'function') callback(null, null);
    return;
  }
  options = options || {};
  var self = this;
  if (serverAccounting) delete servers[this.id];
  if (this.monitoringProcessId) {
    clearTimeout(this.monitoringProcessId);
  }
  if (!self.s.pool) {
    this._destroyed = true;
    if (typeof callback === 'function') callback(null, null);
    return;
  }
  if (options.emitClose) {
    self.emit('close', self);
  }
  if (options.emitDestroy) {
    self.emit('destroy', self);
  }
  listeners.forEach(function(event) {
    self.s.pool.removeAllListeners(event);
  });
  if (self.listeners('serverClosed').length > 0)
    self.emit('serverClosed', {
      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,
      address: self.name
    });
  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {
    self.emit('topologyClosed', { topologyId: self.id });
  }
  if (self.s.logger.isDebug()) {
    self.s.logger.debug(f('destroy called on server %s', self.name));
  }
  this.s.pool.destroy(options.force, callback);
  this._destroyed = true;
};
module.exports = Server;
