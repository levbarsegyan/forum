'use strict';
const MongoError = require('../error').MongoError;
class AuthProvider {
  constructor(bson) {
    this.bson = bson;
    this.authStore = [];
  }
  auth(sendAuthCommand, connections, credentials, callback) {
    let count = connections.length;
    if (count === 0) {
      callback(null, null);
      return;
    }
    let numberOfValidConnections = 0;
    let errorObject = null;
    const execute = connection => {
      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {
        count = count - 1;
        if (err) {
          errorObject = new MongoError(err);
        } else if (r && (r.$err || r.errmsg)) {
          errorObject = new MongoError(r);
        } else {
          numberOfValidConnections = numberOfValidConnections + 1;
        }
        if (count !== 0) {
          return;
        }
        if (numberOfValidConnections > 0) {
          this.addCredentials(credentials);
          callback(null, true);
        } else {
          if (errorObject == null) {
            errorObject = new MongoError(`failed to authenticate using ${credentials.mechanism}`);
          }
          callback(errorObject, false);
        }
      });
    };
    const executeInNextTick = _connection => process.nextTick(() => execute(_connection));
    while (connections.length > 0) {
      executeInNextTick(connections.shift());
    }
  }
  _authenticateSingleConnection() {
    throw new Error('_authenticateSingleConnection must be overridden');
  }
  addCredentials(credentials) {
    const found = this.authStore.some(cred => cred.equals(credentials));
    if (!found) {
      this.authStore.push(credentials);
    }
  }
  reauthenticate(sendAuthCommand, connections, callback) {
    const authStore = this.authStore.slice(0);
    let count = authStore.length;
    if (count === 0) {
      return callback(null, null);
    }
    for (let i = 0; i < authStore.length; i++) {
      this.auth(sendAuthCommand, connections, authStore[i], function(err) {
        count = count - 1;
        if (count === 0) {
          callback(err, null);
        }
      });
    }
  }
  logout(source) {
    this.authStore = this.authStore.filter(credentials => credentials.source !== source);
  }
}
module.exports = { AuthProvider };
