'use strict';
const Logger = require('./connection/logger');
const retrieveBSON = require('./connection/utils').retrieveBSON;
const MongoError = require('./error').MongoError;
const MongoNetworkError = require('./error').MongoNetworkError;
const mongoErrorContextSymbol = require('./error').mongoErrorContextSymbol;
const f = require('util').format;
const collationNotSupported = require('./utils').collationNotSupported;
const wireProtocol = require('./wireprotocol');
const BSON = retrieveBSON();
const Long = BSON.Long;
var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
  options = options || {};
  this.pool = null;
  this.server = null;
  this.disconnectHandler = options.disconnectHandler;
  this.bson = bson;
  this.ns = ns;
  this.cmd = cmd;
  this.options = options;
  this.topology = topology;
  this.cursorState = {
    cursorId: null,
    cmd: cmd,
    documents: options.documents || [],
    cursorIndex: 0,
    dead: false,
    killed: false,
    init: false,
    notified: false,
    limit: options.limit || cmd.limit || 0,
    skip: options.skip || cmd.skip || 0,
    batchSize: options.batchSize || cmd.batchSize || 1000,
    currentLimit: 0,
    transforms: options.transforms,
    raw: options.raw || (cmd && cmd.raw)
  };
  if (typeof options.session === 'object') {
    this.cursorState.session = options.session;
  }
  if (typeof topologyOptions.promoteLongs === 'boolean') {
    this.cursorState.promoteLongs = topologyOptions.promoteLongs;
  } else if (typeof options.promoteLongs === 'boolean') {
    this.cursorState.promoteLongs = options.promoteLongs;
  }
  if (typeof topologyOptions.promoteValues === 'boolean') {
    this.cursorState.promoteValues = topologyOptions.promoteValues;
  } else if (typeof options.promoteValues === 'boolean') {
    this.cursorState.promoteValues = options.promoteValues;
  }
  if (typeof topologyOptions.promoteBuffers === 'boolean') {
    this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
  } else if (typeof options.promoteBuffers === 'boolean') {
    this.cursorState.promoteBuffers = options.promoteBuffers;
  }
  if (topologyOptions.reconnect) {
    this.cursorState.reconnect = topologyOptions.reconnect;
  }
  this.logger = Logger('Cursor', topologyOptions);
  if (typeof cmd === 'number') {
    this.cursorState.cursorId = Long.fromNumber(cmd);
    this.cursorState.lastCursorId = this.cursorState.cursorId;
  } else if (cmd instanceof Long) {
    this.cursorState.cursorId = cmd;
    this.cursorState.lastCursorId = cmd;
  }
};
Cursor.prototype.setCursorBatchSize = function(value) {
  this.cursorState.batchSize = value;
};
Cursor.prototype.cursorBatchSize = function() {
  return this.cursorState.batchSize;
};
Cursor.prototype.setCursorLimit = function(value) {
  this.cursorState.limit = value;
};
Cursor.prototype.cursorLimit = function() {
  return this.cursorState.limit;
};
Cursor.prototype.setCursorSkip = function(value) {
  this.cursorState.skip = value;
};
Cursor.prototype.cursorSkip = function() {
  return this.cursorState.skip;
};
Cursor.prototype._endSession = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};
  const session = this.cursorState.session;
  if (session && (options.force || session.owner === this)) {
    this.cursorState.session = undefined;
    session.endSession(callback);
    return true;
  }
  if (callback) {
    callback();
  }
  return false;
};
var handleCallback = function(callback, err, result) {
  try {
    callback(err, result);
  } catch (err) {
    process.nextTick(function() {
      throw err;
    });
  }
};
Cursor.prototype._getmore = function(callback) {
  if (this.logger.isDebug())
    this.logger.debug(f('schedule getMore call for query [%s]', JSON.stringify(this.query)));
  var batchSize = this.cursorState.batchSize;
  if (
    this.cursorState.limit > 0 &&
    this.cursorState.currentLimit + batchSize > this.cursorState.limit
  ) {
    batchSize = this.cursorState.limit - this.cursorState.currentLimit;
  }
  wireProtocol.getMore(this.server, this.ns, this.cursorState, batchSize, this.options, callback);
};
Cursor.prototype.clone = function() {
  return this.topology.cursor(this.ns, this.cmd, this.options);
};
Cursor.prototype.isDead = function() {
  return this.cursorState.dead === true;
};
Cursor.prototype.isKilled = function() {
  return this.cursorState.killed === true;
};
Cursor.prototype.isNotified = function() {
  return this.cursorState.notified === true;
};
Cursor.prototype.bufferedCount = function() {
  return this.cursorState.documents.length - this.cursorState.cursorIndex;
};
Cursor.prototype.readBufferedDocuments = function(number) {
  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
  var elements = this.cursorState.documents.slice(
    this.cursorState.cursorIndex,
    this.cursorState.cursorIndex + length
  );
  if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {
    for (var i = 0; i < elements.length; i++) {
      elements[i] = this.cursorState.transforms.doc(elements[i]);
    }
  }
  if (
    this.cursorState.limit > 0 &&
    this.cursorState.currentLimit + elements.length > this.cursorState.limit
  ) {
    elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
    this.kill();
  }
  this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
  this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
  return elements;
};
Cursor.prototype.kill = function(callback) {
  this.cursorState.dead = true;
  this.cursorState.killed = true;
  this.cursorState.documents = [];
  if (
    this.cursorState.cursorId == null ||
    this.cursorState.cursorId.isZero() ||
    this.cursorState.init === false
  ) {
    if (callback) callback(null, null);
    return;
  }
  wireProtocol.killCursors(this.server, this.ns, this.cursorState, callback);
};
Cursor.prototype.rewind = function() {
  if (this.cursorState.init) {
    if (!this.cursorState.dead) {
      this.kill();
    }
    this.cursorState.currentLimit = 0;
    this.cursorState.init = false;
    this.cursorState.dead = false;
    this.cursorState.killed = false;
    this.cursorState.notified = false;
    this.cursorState.documents = [];
    this.cursorState.cursorId = null;
    this.cursorState.cursorIndex = 0;
  }
};
var isConnectionDead = function(self, callback) {
  if (self.pool && self.pool.isDestroyed()) {
    self.cursorState.killed = true;
    const err = new MongoNetworkError(
      f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)
    );
    _setCursorNotifiedImpl(self, () => callback(err));
    return true;
  }
  return false;
};
var isCursorDeadButNotkilled = function(self, callback) {
  if (self.cursorState.dead && !self.cursorState.killed) {
    self.cursorState.killed = true;
    setCursorNotified(self, callback);
    return true;
  }
  return false;
};
var isCursorDeadAndKilled = function(self, callback) {
  if (self.cursorState.dead && self.cursorState.killed) {
    handleCallback(callback, new MongoError('cursor is dead'));
    return true;
  }
  return false;
};
var isCursorKilled = function(self, callback) {
  if (self.cursorState.killed) {
    setCursorNotified(self, callback);
    return true;
  }
  return false;
};
var setCursorDeadAndNotified = function(self, callback) {
  self.cursorState.dead = true;
  setCursorNotified(self, callback);
};
var setCursorNotified = function(self, callback) {
  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));
};
var _setCursorNotifiedImpl = function(self, callback) {
  self.cursorState.notified = true;
  self.cursorState.documents = [];
  self.cursorState.cursorIndex = 0;
  if (self._endSession) {
    return self._endSession(undefined, () => callback());
  }
  return callback();
};
var nextFunction = function(self, callback) {
  if (self.cursorState.notified) {
    return callback(new Error('cursor is exhausted'));
  }
  if (isCursorKilled(self, callback)) return;
  if (isCursorDeadButNotkilled(self, callback)) return;
  if (isCursorDeadAndKilled(self, callback)) return;
  if (!self.cursorState.init) {
    return initializeCursor(self, callback);
  }
  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
    self.kill();
    return setCursorDeadAndNotified(self, callback);
  } else if (
    self.cursorState.cursorIndex === self.cursorState.documents.length &&
    !Long.ZERO.equals(self.cursorState.cursorId)
  ) {
    self.cursorState.documents = [];
    self.cursorState.cursorIndex = 0;
    if (self.topology.isDestroyed())
      return callback(
        new MongoNetworkError('connection destroyed, not possible to instantiate cursor')
      );
    if (isConnectionDead(self, callback)) return;
    self._getmore(function(err, doc, connection) {
      if (err) {
        if (err instanceof MongoError) {
          err[mongoErrorContextSymbol].isGetMore = true;
        }
        return handleCallback(callback, err);
      }
      if (self.cursorState.cursorId && self.cursorState.cursorId.isZero() && self._endSession) {
        self._endSession();
      }
      self.connection = connection;
      if (
        self.cursorState.documents.length === 0 &&
        self.cmd.tailable &&
        Long.ZERO.equals(self.cursorState.cursorId)
      ) {
        return handleCallback(
          callback,
          new MongoError({
            message: 'No more documents in tailed cursor',
            tailable: self.cmd.tailable,
            awaitData: self.cmd.awaitData
          })
        );
      } else if (
        self.cursorState.documents.length === 0 &&
        self.cmd.tailable &&
        !Long.ZERO.equals(self.cursorState.cursorId)
      ) {
        return nextFunction(self, callback);
      }
      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
        return setCursorDeadAndNotified(self, callback);
      }
      nextFunction(self, callback);
    });
  } else if (
    self.cursorState.documents.length === self.cursorState.cursorIndex &&
    self.cmd.tailable &&
    Long.ZERO.equals(self.cursorState.cursorId)
  ) {
    return handleCallback(
      callback,
      new MongoError({
        message: 'No more documents in tailed cursor',
        tailable: self.cmd.tailable,
        awaitData: self.cmd.awaitData
      })
    );
  } else if (
    self.cursorState.documents.length === self.cursorState.cursorIndex &&
    Long.ZERO.equals(self.cursorState.cursorId)
  ) {
    setCursorDeadAndNotified(self, callback);
  } else {
    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
      self.kill();
      return setCursorDeadAndNotified(self, callback);
    }
    self.cursorState.currentLimit += 1;
    var doc = self.cursorState.documents[self.cursorState.cursorIndex++];
    if (!doc || doc.$err) {
      self.kill();
      return setCursorDeadAndNotified(self, function() {
        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));
      });
    }
    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {
      doc = self.cursorState.transforms.doc(doc);
    }
    handleCallback(callback, null, doc);
  }
};
function initializeCursor(cursor, callback) {
  if (!cursor.topology.isConnected(cursor.options)) {
    if (cursor.topology._type === 'server' && !cursor.topology.s.options.reconnect) {
      return callback(new MongoError('no connection available'));
    }
    if (cursor.disconnectHandler != null) {
      if (cursor.topology.isDestroyed()) {
        return callback(new MongoError('Topology was destroyed'));
      }
      return cursor.disconnectHandler.addObjectAndMethod(
        'cursor',
        cursor,
        'next',
        [callback],
        callback
      );
    }
  }
  const serverSelectOptions = {};
  if (cursor.cursorState.session) {
    serverSelectOptions.session = cursor.cursorState.session;
  }
  if (cursor.options.readPreference) {
    serverSelectOptions.readPreference = cursor.options.readPreference;
  }
  return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
    if (err) {
      const disconnectHandler = cursor.disconnectHandler;
      if (disconnectHandler != null) {
        return disconnectHandler.addObjectAndMethod('cursor', cursor, 'next', [callback], callback);
      }
      return callback(err);
    }
    cursor.server = server;
    cursor.cursorState.init = true;
    if (collationNotSupported(cursor.server, cursor.cmd)) {
      return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
    }
    function done() {
      if (
        cursor.cursorState.cursorId &&
        cursor.cursorState.cursorId.isZero() &&
        cursor._endSession
      ) {
        cursor._endSession();
      }
      if (
        cursor.cursorState.documents.length === 0 &&
        cursor.cursorState.cursorId &&
        cursor.cursorState.cursorId.isZero() &&
        !cursor.cmd.tailable &&
        !cursor.cmd.awaitData
      ) {
        return setCursorNotified(cursor, callback);
      }
      nextFunction(cursor, callback);
    }
    if (cursor.cursorState.cursorId != null) {
      return done();
    }
    const queryCallback = (err, r) => {
      if (err) return callback(err);
      const result = r.message;
      if (result.queryFailure) {
        return callback(new MongoError(result.documents[0]), null);
      }
      if (
        Array.isArray(result.documents) &&
        result.documents.length === 1 &&
        (!cursor.cmd.find || (cursor.cmd.find && cursor.cmd.virtual === false)) &&
        (typeof result.documents[0].cursor !== 'string' ||
          result.documents[0]['$err'] ||
          result.documents[0]['errmsg'] ||
          Array.isArray(result.documents[0].result))
      ) {
        if (result.documents[0]['$err'] || result.documents[0]['errmsg']) {
          return callback(new MongoError(result.documents[0]), null);
        }
        if (result.documents[0].cursor != null && typeof result.documents[0].cursor !== 'string') {
          var id = result.documents[0].cursor.id;
          if (result.documents[0].cursor.ns) {
            cursor.ns = result.documents[0].cursor.ns;
          }
          cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;
          cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
          cursor.cursorState.operationTime = result.documents[0].operationTime;
          if (Array.isArray(result.documents[0].cursor.firstBatch)) {
            cursor.cursorState.documents = result.documents[0].cursor.firstBatch; 
          }
          return done(result);
        }
        if (Array.isArray(result.documents[0].result)) {
          cursor.cursorState.documents = result.documents[0].result;
          cursor.cursorState.cursorId = Long.ZERO;
          return done(result);
        }
      }
      const cursorId = result.cursorId || 0;
      cursor.cursorState.cursorId = Long.fromNumber(cursorId);
      cursor.cursorState.documents = result.documents;
      cursor.cursorState.lastCursorId = result.cursorId;
      if (
        cursor.cursorState.transforms &&
        typeof cursor.cursorState.transforms.query === 'function'
      ) {
        cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
      }
      done(result);
    };
    if (cursor.logger.isDebug()) {
      cursor.logger.debug(
        `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(
          cursor.query
        )}]`
      );
    }
    if (cursor.cmd.find != null) {
      wireProtocol.query(
        cursor.server,
        cursor.ns,
        cursor.cmd,
        cursor.cursorState,
        cursor.options,
        queryCallback
      );
      return;
    }
    cursor.query = wireProtocol.command(
      cursor.server,
      cursor.ns,
      cursor.cmd,
      cursor.options,
      queryCallback
    );
  });
}
Cursor.prototype.next = function(callback) {
  nextFunction(this, callback);
};
module.exports = Cursor;
