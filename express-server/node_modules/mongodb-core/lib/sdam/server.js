'use strict';
const EventEmitter = require('events');
const MongoError = require('../error').MongoError;
const Pool = require('../connection/pool');
const relayEvents = require('../utils').relayEvents;
const wireProtocol = require('../wireprotocol');
const BSON = require('../connection/utils').retrieveBSON();
const createClientInfo = require('../topologies/shared').createClientInfo;
const Logger = require('../connection/logger');
const ServerDescription = require('./server_description').ServerDescription;
const ReadPreference = require('../topologies/read_preference');
const monitorServer = require('./monitoring').monitorServer;
const MongoParseError = require('../error').MongoParseError;
const MongoNetworkError = require('../error').MongoNetworkError;
const collationNotSupported = require('../utils').collationNotSupported;
const debugOptions = require('../connection/utils').debugOptions;
const DEBUG_FIELDS = [
  'reconnect',
  'reconnectTries',
  'reconnectInterval',
  'emitError',
  'cursorFactory',
  'host',
  'port',
  'size',
  'keepAlive',
  'keepAliveInitialDelay',
  'noDelay',
  'connectionTimeout',
  'checkServerIdentity',
  'socketTimeout',
  'ssl',
  'ca',
  'crl',
  'cert',
  'key',
  'rejectUnauthorized',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'servername'
];
const STATE_DISCONNECTED = 0;
const STATE_CONNECTING = 1;
const STATE_CONNECTED = 2;
class Server extends EventEmitter {
  constructor(description, options, topology) {
    super();
    this.s = {
      description,
      options,
      logger: Logger('Server', options),
      bson: options.bson || new BSON(),
      clientInfo: createClientInfo(options),
      monitoring: false,
      monitorFunction: options.monitorFunction || monitorServer,
      pool: null,
      state: STATE_DISCONNECTED,
      credentials: options.credentials,
      topology
    };
  }
  get description() {
    return this.s.description;
  }
  get name() {
    return this.s.description.address;
  }
  connect(options) {
    options = options || {};
    if (this.s.pool && !this.s.pool.isDisconnected() && !this.s.pool.isDestroyed()) {
      throw new MongoError(`Server instance in invalid state ${this.s.pool.state}`);
    }
    const addressParts = this.description.address.split(':');
    const poolOptions = Object.assign(
      { host: addressParts[0], port: parseInt(addressParts[1], 10) },
      this.s.options,
      options,
      { bson: this.s.bson }
    );
    poolOptions.reconnect = true;
    this.s.pool = new Pool(this, poolOptions);
    this.s.pool.on('connect', connectEventHandler(this));
    this.s.pool.on('close', errorEventHandler(this));
    this.s.pool.on('error', errorEventHandler(this));
    this.s.pool.on('parseError', parseErrorEventHandler(this));
    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed']);
    this.s.state = STATE_CONNECTING;
    if (options.auth) {
      this.s.pool.connect.apply(this.s.pool, options.auth);
      return;
    }
    this.s.pool.connect();
  }
  destroy(options, callback) {
    if (typeof options === 'function') (callback = options), (options = {});
    options = Object.assign({}, { force: false }, options);
    if (!this.s.pool) {
      this.s.state = STATE_DISCONNECTED;
      if (typeof callback === 'function') {
        callback(null, null);
      }
      return;
    }
    ['close', 'error', 'timeout', 'parseError', 'connect'].forEach(event => {
      this.s.pool.removeAllListeners(event);
    });
    if (this.s.monitorId) {
      clearTimeout(this.s.monitorId);
    }
    this.s.pool.destroy(options.force, err => {
      this.s.state = STATE_DISCONNECTED;
      callback(err);
    });
  }
  monitor(options) {
    options = options || {};
    if (this.s.state !== STATE_CONNECTED || this.s.monitoring) return;
    if (this.s.monitorId) clearTimeout(this.s.monitorId);
    this.s.monitorFunction(this, options);
  }
  command(ns, cmd, options, callback) {
    if (typeof options === 'function') {
      (callback = options), (options = {}), (options = options || {});
    }
    const error = basicReadValidations(this, options);
    if (error) {
      return callback(error, null);
    }
    options = Object.assign({}, options, { wireProtocolCommand: false });
    if (this.s.logger.isDebug()) {
      this.s.logger.debug(
        `executing command [${JSON.stringify({
          ns,
          cmd,
          options: debugOptions(DEBUG_FIELDS, options)
        })}] against ${this.name}`
      );
    }
    if (collationNotSupported(this, cmd)) {
      callback(new MongoError(`server ${this.name} does not support collation`));
      return;
    }
    wireProtocol.command(this, ns, cmd, options, callback);
  }
  insert(ns, ops, options, callback) {
    executeWriteOperation({ server: this, op: 'insert', ns, ops }, options, callback);
  }
  update(ns, ops, options, callback) {
    executeWriteOperation({ server: this, op: 'update', ns, ops }, options, callback);
  }
  remove(ns, ops, options, callback) {
    executeWriteOperation({ server: this, op: 'remove', ns, ops }, options, callback);
  }
}
Object.defineProperty(Server.prototype, 'clusterTime', {
  get: function() {
    return this.s.topology.clusterTime;
  },
  set: function(clusterTime) {
    this.s.topology.clusterTime = clusterTime;
  }
});
function basicWriteValidations(server) {
  if (!server.s.pool) {
    return new MongoError('server instance is not connected');
  }
  if (server.s.pool.isDestroyed()) {
    return new MongoError('server instance pool was destroyed');
  }
  return null;
}
function basicReadValidations(server, options) {
  const error = basicWriteValidations(server, options);
  if (error) {
    return error;
  }
  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
    return new MongoError('readPreference must be an instance of ReadPreference');
  }
}
function executeWriteOperation(args, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const server = args.server;
  const op = args.op;
  const ns = args.ns;
  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
  const error = basicWriteValidations(server, options);
  if (error) {
    callback(error, null);
    return;
  }
  if (collationNotSupported(server, options)) {
    callback(new MongoError(`server ${this.name} does not support collation`));
    return;
  }
  return wireProtocol[op](server, ns, ops, options, callback);
}
function connectEventHandler(server) {
  return function(pool, conn) {
    const ismaster = conn.ismaster;
    server.s.lastIsMasterMS = conn.lastIsMasterMS;
    if (conn.agreedCompressor) {
      server.s.pool.options.agreedCompressor = conn.agreedCompressor;
    }
    if (conn.zlibCompressionLevel) {
      server.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
    }
    if (conn.ismaster.$clusterTime) {
      const $clusterTime = conn.ismaster.$clusterTime;
      server.s.sclusterTime = $clusterTime;
    }
    if (server.s.logger.isInfo()) {
      server.s.logger.info(
        `server ${server.name} connected with ismaster [${JSON.stringify(ismaster)}]`
      );
    }
    server.emit('descriptionReceived', new ServerDescription(server.description.address, ismaster));
    server.s.state = STATE_CONNECTED;
    server.emit('connect', server);
  };
}
function errorEventHandler(server) {
  return function(err) {
    if (err) {
      server.emit('error', new MongoNetworkError(err));
    }
    server.emit('close');
  };
}
function parseErrorEventHandler(server) {
  return function(err) {
    server.s.state = STATE_DISCONNECTED;
    server.emit('error', new MongoParseError(err));
  };
}
module.exports = Server;
