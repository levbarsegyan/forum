'use strict';
const EventEmitter = require('events');
const ServerDescription = require('./server_description').ServerDescription;
const ServerType = require('./server_description').ServerType;
const TopologyDescription = require('./topology_description').TopologyDescription;
const TopologyType = require('./topology_description').TopologyType;
const monitoring = require('./monitoring');
const calculateDurationInMs = require('../utils').calculateDurationInMs;
const MongoTimeoutError = require('../error').MongoTimeoutError;
const Server = require('./server');
const relayEvents = require('../utils').relayEvents;
const ReadPreference = require('../topologies/read_preference');
const readPreferenceServerSelector = require('./server_selectors').readPreferenceServerSelector;
const writableServerSelector = require('./server_selectors').writableServerSelector;
const isRetryableWritesSupported = require('../topologies/shared').isRetryableWritesSupported;
const Cursor = require('../cursor');
const deprecate = require('util').deprecate;
const BSON = require('../connection/utils').retrieveBSON();
const createCompressionInfo = require('../topologies/shared').createCompressionInfo;
const isRetryableError = require('../error').isRetryableError;
const MongoParseError = require('../error').MongoParseError;
const ClientSession = require('../sessions').ClientSession;
const createClientInfo = require('../topologies/shared').createClientInfo;
const MongoError = require('../error').MongoError;
const resolveClusterTime = require('../topologies/shared').resolveClusterTime;
let globalTopologyCounter = 0;
const TOPOLOGY_DEFAULTS = {
  localThresholdMS: 15,
  serverSelectionTimeoutMS: 10000,
  heartbeatFrequencyMS: 30000,
  minHeartbeatFrequencyMS: 500
};
const SERVER_RELAY_EVENTS = [
  'serverHeartbeatStarted',
  'serverHeartbeatSucceeded',
  'serverHeartbeatFailed',
  'commandStarted',
  'commandSucceeded',
  'commandFailed',
  'monitoring'
];
const LOCAL_SERVER_EVENTS = SERVER_RELAY_EVENTS.concat([
  'error',
  'connect',
  'descriptionReceived',
  'close',
  'ended'
]);
class Topology extends EventEmitter {
  constructor(seedlist, options) {
    super();
    if (typeof options === 'undefined' && typeof seedlist !== 'string') {
      options = seedlist;
      seedlist = [];
      if (options.host) {
        seedlist.push({ host: options.host, port: options.port });
      }
    }
    seedlist = seedlist || [];
    if (typeof seedlist === 'string') {
      seedlist = parseStringSeedlist(seedlist);
    }
    options = Object.assign({}, TOPOLOGY_DEFAULTS, options);
    const topologyType = topologyTypeFromSeedlist(seedlist, options);
    const topologyId = globalTopologyCounter++;
    const serverDescriptions = seedlist.reduce((result, seed) => {
      if (seed.domain_socket) seed.host = seed.domain_socket;
      const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
      result.set(address, new ServerDescription(address));
      return result;
    }, new Map());
    this.s = {
      id: topologyId,
      options,
      seedlist: seedlist,
      description: new TopologyDescription(
        topologyType,
        serverDescriptions,
        options.replicaSet,
        null,
        null,
        null,
        options
      ),
      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
      heartbeatFrequencyMS: options.heartbeatFrequencyMS,
      minHeartbeatIntervalMS: options.minHeartbeatIntervalMS,
      Cursor: options.cursorFactory || Cursor,
      bson: options.bson || new BSON(),
      servers: new Map(),
      sessionPool: null,
      sessions: [],
      promiseLibrary: options.promiseLibrary || Promise,
      credentials: options.credentials,
      clusterTime: null
    };
    this.s.options.compression = { compressors: createCompressionInfo(options) };
    this.s.clientInfo = createClientInfo(options);
  }
  get description() {
    return this.s.description;
  }
  get parserType() {
    return BSON.native ? 'c++' : 'js';
  }
  connections() {
    return Array.from(this.s.servers.values()).reduce((result, server) => {
      return result.concat(server.s.pool.allConnections());
    }, []);
  }
  connect(options, callback) {
    if (typeof options === 'function') (callback = options), (options = {});
    options = options || {};
    this.emit('topologyOpening', new monitoring.TopologyOpeningEvent(this.s.id));
    this.emit(
      'topologyDescriptionChanged',
      new monitoring.TopologyDescriptionChangedEvent(
        this.s.id,
        new TopologyDescription(TopologyType.Unknown), 
        this.s.description
      )
    );
    connectServers(this, Array.from(this.s.description.servers.values()));
    this.s.connected = true;
    translateReadPreference(options);
    const readPreference = options.readPreference || ReadPreference.primary;
    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {
      if (err) {
        if (typeof callback === 'function') {
          callback(err, null);
        } else {
          this.emit('error', err);
        }
        return;
      }
      const errorHandler = err => {
        server.removeListener('connect', connectHandler);
        if (typeof callback === 'function') callback(err, null);
      };
      const connectHandler = (_, err) => {
        server.removeListener('error', errorHandler);
        this.emit('open', err, this);
        this.emit('connect', this);
        if (typeof callback === 'function') callback(err, this);
      };
      const STATE_CONNECTING = 1;
      if (server.s.state === STATE_CONNECTING) {
        server.once('error', errorHandler);
        server.once('connect', connectHandler);
        return;
      }
      connectHandler();
    });
  }
  close(options, callback) {
    if (typeof options === 'function') (callback = options), (options = {});
    options = options || {};
    if (this.s.sessionPool) {
      this.s.sessions.forEach(session => session.endSession());
      this.s.sessionPool.endAllPooledSessions();
    }
    const servers = this.s.servers;
    if (servers.size === 0) {
      this.s.connected = false;
      if (typeof callback === 'function') {
        callback(null, null);
      }
      return;
    }
    let destroyed = 0;
    servers.forEach(server =>
      destroyServer(server, this, () => {
        destroyed++;
        if (destroyed === servers.size) {
          this.emit('topologyClosed', new monitoring.TopologyClosedEvent(this.s.id));
          this.s.connected = false;
          if (typeof callback === 'function') {
            callback(null, null);
          }
        }
      })
    );
  }
  selectServer(selector, options, callback) {
    if (typeof options === 'function') {
      callback = options;
      if (typeof selector !== 'function') {
        options = selector;
        translateReadPreference(options);
        const readPreference = options.readPreference || ReadPreference.primary;
        selector = readPreferenceServerSelector(readPreference);
      } else {
        options = {};
      }
    }
    options = Object.assign(
      {},
      { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS },
      options
    );
    const isSharded = this.description.type === TopologyType.Sharded;
    const session = options.session;
    const transaction = session && session.transaction;
    if (isSharded && transaction && transaction.server) {
      callback(null, transaction.server);
      return;
    }
    selectServers(
      this,
      selector,
      options.serverSelectionTimeoutMS,
      process.hrtime(),
      (err, servers) => {
        if (err) return callback(err, null);
        const selectedServer = randomSelection(servers);
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        callback(null, selectedServer);
      }
    );
  }
  hasSessionSupport() {
    return this.description.logicalSessionTimeoutMinutes != null;
  }
  startSession(options, clientOptions) {
    const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
    session.once('ended', () => {
      this.s.sessions = this.s.sessions.filter(s => !s.equals(session));
    });
    this.s.sessions.push(session);
    return session;
  }
  endSessions(sessions, callback) {
    if (!Array.isArray(sessions)) {
      sessions = [sessions];
    }
    this.command(
      'admin.$cmd',
      { endSessions: sessions },
      { readPreference: ReadPreference.primaryPreferred, noResponse: true },
      () => {
        if (typeof callback === 'function') callback();
      }
    );
  }
  serverUpdateHandler(serverDescription) {
    if (!this.s.description.hasServer(serverDescription.address)) {
      return;
    }
    const previousTopologyDescription = this.s.description;
    const previousServerDescription = this.s.description.servers.get(serverDescription.address);
    this.s.description = this.s.description.update(serverDescription);
    if (this.s.description.compatibilityError) {
      this.emit('error', new MongoError(this.s.description.compatibilityError));
      return;
    }
    this.emit(
      'serverDescriptionChanged',
      new monitoring.ServerDescriptionChangedEvent(
        this.s.id,
        serverDescription.address,
        previousServerDescription,
        this.s.description.servers.get(serverDescription.address)
      )
    );
    updateServers(this, serverDescription);
    const clusterTime = serverDescription.$clusterTime;
    if (clusterTime) {
      resolveClusterTime(this, clusterTime);
    }
    this.emit(
      'topologyDescriptionChanged',
      new monitoring.TopologyDescriptionChangedEvent(
        this.s.id,
        previousTopologyDescription,
        this.s.description
      )
    );
  }
  auth(credentials, callback) {
    if (typeof credentials === 'function') (callback = credentials), (credentials = null);
    if (typeof callback === 'function') callback(null, true);
  }
  logout(callback) {
    if (typeof callback === 'function') callback(null, true);
  }
  insert(ns, ops, options, callback) {
    executeWriteOperation({ topology: this, op: 'insert', ns, ops }, options, callback);
  }
  update(ns, ops, options, callback) {
    executeWriteOperation({ topology: this, op: 'update', ns, ops }, options, callback);
  }
  remove(ns, ops, options, callback) {
    executeWriteOperation({ topology: this, op: 'remove', ns, ops }, options, callback);
  }
  command(ns, cmd, options, callback) {
    if (typeof options === 'function') {
      (callback = options), (options = {}), (options = options || {});
    }
    translateReadPreference(options);
    const readPreference = options.readPreference || ReadPreference.primary;
    this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {
      if (err) {
        callback(err, null);
        return;
      }
      const willRetryWrite =
        !options.retrying &&
        !!options.retryWrites &&
        options.session &&
        isRetryableWritesSupported(this) &&
        !options.session.inTransaction() &&
        isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err) return callback(null, result);
        if (!isRetryableError(err)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, options, cb);
    });
  }
  cursor(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    const CursorClass = options.cursorFactory || this.s.Cursor;
    translateReadPreference(options);
    return new CursorClass(this.s.bson, ns, cmd, options, topology, this.s.options);
  }
  get clientInfo() {
    return this.s.clientInfo;
  }
  isConnected() {
    return true;
  }
  isDestroyed() {
    return false;
  }
  unref() {
    console.log('not implemented: `unref`');
  }
  lastIsMaster() {
    const serverDescriptions = Array.from(this.description.servers.values());
    if (serverDescriptions.length === 0) return {};
    const sd = serverDescriptions.filter(sd => sd.type !== ServerType.Unknown)[0];
    const result = sd || { maxWireVersion: this.description.commonWireVersion };
    return result;
  }
  get logicalSessionTimeoutMinutes() {
    return this.description.logicalSessionTimeoutMinutes;
  }
  get bson() {
    return this.s.bson;
  }
}
Object.defineProperty(Topology.prototype, 'clusterTime', {
  enumerable: true,
  get: function() {
    return this.s.clusterTime;
  },
  set: function(clusterTime) {
    this.s.clusterTime = clusterTime;
  }
});
Topology.prototype.destroy = deprecate(
  Topology.prototype.close,
  'destroy() is deprecated, please use close() instead'
);
const RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];
function isWriteCommand(command) {
  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);
}
function destroyServer(server, topology, callback) {
  LOCAL_SERVER_EVENTS.forEach(event => server.removeAllListeners(event));
  server.destroy(() => {
    topology.emit(
      'serverClosed',
      new monitoring.ServerClosedEvent(topology.s.id, server.description.address)
    );
    if (typeof callback === 'function') callback(null, null);
  });
}
function parseStringSeedlist(seedlist) {
  return seedlist.split(',').map(seed => ({
    host: seed.split(':')[0],
    port: seed.split(':')[1] || 27017
  }));
}
function topologyTypeFromSeedlist(seedlist, options) {
  const replicaSet = options.replicaSet || options.setName || options.rs_name;
  if (seedlist.length === 1 && !replicaSet) return TopologyType.Single;
  if (replicaSet) return TopologyType.ReplicaSetNoPrimary;
  return TopologyType.Unknown;
}
function randomSelection(array) {
  return array[Math.floor(Math.random() * array.length)];
}
function selectServers(topology, selector, timeout, start, callback) {
  const duration = calculateDurationInMs(start);
  if (duration >= timeout) {
    return callback(new MongoTimeoutError(`Server selection timed out after ${timeout} ms`));
  }
  if (!topology.s.connected) {
    topology.connect();
    const failToConnectTimer = setTimeout(() => {
      topology.removeListener('connect', connectHandler);
      callback(new MongoTimeoutError('Server selection timed out waiting to connect'));
    }, timeout - duration);
    const connectHandler = () => {
      clearTimeout(failToConnectTimer);
      selectServers(topology, selector, timeout, process.hrtime(), callback);
    };
    topology.once('connect', connectHandler);
    return;
  }
  const serverDescriptions = Array.from(topology.description.servers.values());
  let descriptions;
  if (typeof selector === 'object') {
    const readPreference = selector.readPreference
      ? selector.readPreference
      : ReadPreference.primary;
    selector = readPreferenceServerSelector(readPreference);
  }
  try {
    descriptions = selector
      ? selector(topology.description, serverDescriptions)
      : serverDescriptions;
  } catch (e) {
    return callback(e, null);
  }
  if (descriptions.length) {
    const servers = descriptions.map(description => topology.s.servers.get(description.address));
    return callback(null, servers);
  }
  const retrySelection = () => {
    topology.s.servers.forEach(server => {
      setTimeout(
        () => server.monitor({ heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS }),
        TOPOLOGY_DEFAULTS.minHeartbeatFrequencyMS
      );
    });
    const descriptionChangedHandler = () => {
      clearTimeout(iterationTimer);
      if (topology.description.error) {
        callback(topology.description.error, null);
        return;
      }
      selectServers(topology, selector, timeout, start, callback);
    };
    const iterationTimer = setTimeout(() => {
      topology.removeListener('topologyDescriptionChanged', descriptionChangedHandler);
      callback(new MongoTimeoutError(`Server selection timed out after ${timeout} ms`));
    }, timeout - duration);
    topology.once('topologyDescriptionChanged', descriptionChangedHandler);
  };
  retrySelection();
}
function createAndConnectServer(topology, serverDescription) {
  topology.emit(
    'serverOpening',
    new monitoring.ServerOpeningEvent(topology.s.id, serverDescription.address)
  );
  const server = new Server(serverDescription, topology.s.options, topology);
  relayEvents(server, topology, SERVER_RELAY_EVENTS);
  server.once('connect', serverConnectEventHandler(server, topology));
  server.on('descriptionReceived', topology.serverUpdateHandler.bind(topology));
  server.on('error', serverErrorEventHandler(server, topology));
  server.on('close', () => topology.emit('close', server));
  server.connect();
  return server;
}
function connectServers(topology, serverDescriptions) {
  topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
    const server = createAndConnectServer(topology, serverDescription);
    servers.set(serverDescription.address, server);
    return servers;
  }, new Map());
}
function updateServers(topology, incomingServerDescription) {
  if (topology.s.servers.has(incomingServerDescription.address)) {
    const server = topology.s.servers.get(incomingServerDescription.address);
    server.s.description = incomingServerDescription;
  }
  for (const serverDescription of topology.description.servers.values()) {
    if (!topology.s.servers.has(serverDescription.address)) {
      const server = createAndConnectServer(topology, serverDescription);
      topology.s.servers.set(serverDescription.address, server);
    }
  }
  for (const entry of topology.s.servers) {
    const serverAddress = entry[0];
    if (topology.description.hasServer(serverAddress)) {
      continue;
    }
    const server = topology.s.servers.get(serverAddress);
    topology.s.servers.delete(serverAddress);
    destroyServer(server, topology);
  }
}
function serverConnectEventHandler(server, topology) {
  return function() {
    server.monitor({
      initial: true,
      heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS
    });
  };
}
function serverErrorEventHandler(server, topology) {
  return function(err) {
    topology.emit(
      'serverClosed',
      new monitoring.ServerClosedEvent(topology.s.id, server.description.address)
    );
    if (err instanceof MongoParseError) {
      resetServerState(server, err, { clearPool: true });
      return;
    }
    resetServerState(server, err);
  };
}
function executeWriteOperation(args, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const topology = args.topology;
  const op = args.op;
  const ns = args.ns;
  const ops = args.ops;
  const willRetryWrite =
    !args.retrying &&
    !!options.retryWrites &&
    options.session &&
    isRetryableWritesSupported(topology) &&
    !options.session.inTransaction();
  topology.selectServer(writableServerSelector(), options, (err, server) => {
    if (err) {
      callback(err, null);
      return;
    }
    const handler = (err, result) => {
      if (!err) return callback(null, result);
      if (!isRetryableError(err)) {
        return callback(err);
      }
      if (willRetryWrite) {
        const newArgs = Object.assign({}, args, { retrying: true });
        return executeWriteOperation(newArgs, options, callback);
      }
      return callback(err);
    };
    if (callback.operationId) {
      handler.operationId = callback.operationId;
    }
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    server[op](ns, ops, options, handler);
  });
}
function resetServerState(server, error, options) {
  options = Object.assign({}, { clearPool: false }, options);
  function resetState() {
    server.emit(
      'descriptionReceived',
      new ServerDescription(server.description.address, null, { error })
    );
  }
  if (options.clearPool && server.pool) {
    server.pool.reset(() => resetState());
    return;
  }
  resetState();
}
function translateReadPreference(options) {
  if (options.readPreference == null) {
    return;
  }
  let r = options.readPreference;
  if (typeof r === 'string') {
    options.readPreference = new ReadPreference(r);
  } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {
    const mode = r.mode || r.preference;
    if (mode && typeof mode === 'string') {
      options.readPreference = new ReadPreference(mode, r.tags, {
        maxStalenessSeconds: r.maxStalenessSeconds
      });
    }
  } else if (!(r instanceof ReadPreference)) {
    throw new TypeError('Invalid read preference: ' + r);
  }
  return options;
}
module.exports = Topology;
