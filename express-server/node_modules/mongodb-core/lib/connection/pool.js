'use strict';
const inherits = require('util').inherits;
const EventEmitter = require('events').EventEmitter;
const MongoError = require('../error').MongoError;
const MongoNetworkError = require('../error').MongoNetworkError;
const MongoWriteConcernError = require('../error').MongoWriteConcernError;
const Logger = require('./logger');
const f = require('util').format;
const Msg = require('./msg').Msg;
const CommandResult = require('./command_result');
const MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;
const COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;
const opcodes = require('../wireprotocol/shared').opcodes;
const compress = require('../wireprotocol/compression').compress;
const compressorIDs = require('../wireprotocol/compression').compressorIDs;
const uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;
const apm = require('./apm');
const Buffer = require('safe-buffer').Buffer;
const connect = require('./connect');
const updateSessionFromResponse = require('../sessions').updateSessionFromResponse;
var DISCONNECTED = 'disconnected';
var CONNECTING = 'connecting';
var CONNECTED = 'connected';
var DESTROYING = 'destroying';
var DESTROYED = 'destroyed';
var _id = 0;
var Pool = function(topology, options) {
  EventEmitter.call(this);
  this.topology = topology;
  this.options = Object.assign(
    {
      host: 'localhost',
      port: 27017,
      size: 5,
      minSize: 0,
      connectionTimeout: 30000,
      socketTimeout: 360000,
      keepAlive: true,
      keepAliveInitialDelay: 300000,
      noDelay: true,
      ssl: false,
      checkServerIdentity: true,
      ca: null,
      crl: null,
      cert: null,
      key: null,
      passPhrase: null,
      rejectUnauthorized: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      reconnect: true,
      reconnectInterval: 1000,
      reconnectTries: 30,
      domainsEnabled: false
    },
    options
  );
  this.id = _id++;
  this.retriesLeft = this.options.reconnectTries;
  this.reconnectId = null;
  if (
    !options.bson ||
    (options.bson &&
      (typeof options.bson.serialize !== 'function' ||
        typeof options.bson.deserialize !== 'function'))
  ) {
    throw new Error('must pass in valid bson parser');
  }
  this.logger = Logger('Pool', options);
  this.state = DISCONNECTED;
  this.availableConnections = [];
  this.inUseConnections = [];
  this.connectingConnections = 0;
  this.executing = false;
  this.queue = [];
  this.reconnectConnection = null;
  this.numberOfConsecutiveTimeouts = 0;
  this.connectionIndex = 0;
  const pool = this;
  this._messageHandler = messageHandler(this);
  this._connectionCloseHandler = function(err) {
    const connection = this;
    connectionFailureHandler(pool, 'close', err, connection);
  };
  this._connectionErrorHandler = function(err) {
    const connection = this;
    connectionFailureHandler(pool, 'error', err, connection);
  };
  this._connectionTimeoutHandler = function(err) {
    const connection = this;
    connectionFailureHandler(pool, 'timeout', err, connection);
  };
  this._connectionParseErrorHandler = function(err) {
    const connection = this;
    connectionFailureHandler(pool, 'parseError', err, connection);
  };
};
inherits(Pool, EventEmitter);
Object.defineProperty(Pool.prototype, 'size', {
  enumerable: true,
  get: function() {
    return this.options.size;
  }
});
Object.defineProperty(Pool.prototype, 'minSize', {
  enumerable: true,
  get: function() {
    return this.options.minSize;
  }
});
Object.defineProperty(Pool.prototype, 'connectionTimeout', {
  enumerable: true,
  get: function() {
    return this.options.connectionTimeout;
  }
});
Object.defineProperty(Pool.prototype, 'socketTimeout', {
  enumerable: true,
  get: function() {
    return this.options.socketTimeout;
  }
});
function stateTransition(self, newState) {
  var legalTransitions = {
    disconnected: [CONNECTING, DESTROYING, DISCONNECTED],
    connecting: [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],
    connected: [CONNECTED, DISCONNECTED, DESTROYING],
    destroying: [DESTROYING, DESTROYED],
    destroyed: [DESTROYED]
  };
  var legalStates = legalTransitions[self.state];
  if (legalStates && legalStates.indexOf(newState) !== -1) {
    self.emit('stateChanged', self.state, newState);
    self.state = newState;
  } else {
    self.logger.error(
      f(
        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',
        self.id,
        self.state,
        newState,
        legalStates
      )
    );
  }
}
function connectionFailureHandler(pool, event, err, conn) {
  if (conn) {
    if (conn._connectionFailHandled) return;
    conn._connectionFailHandled = true;
    conn.destroy();
    removeConnection(pool, conn);
    while (conn.workItems.length > 0) {
      const workItem = conn.workItems.shift();
      if (workItem.cb) workItem.cb(err);
    }
  }
  if (event === 'timeout') {
    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
      pool.numberOfConsecutiveTimeouts = 0;
      pool.destroy(true);
      return pool.emit('close', pool);
    }
  }
  if (pool.socketCount() === 0) {
    if (pool.state !== DESTROYED && pool.state !== DESTROYING) {
      stateTransition(pool, DISCONNECTED);
    }
    event = event === 'error' ? 'close' : event;
    pool.emit(event, err);
  }
  if (!pool.reconnectId && pool.options.reconnect) {
    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
  }
  const totalConnections = totalConnectionCount(pool);
  if (totalConnections < pool.minSize) {
    _createConnection(pool);
  }
}
function attemptReconnect(self) {
  return function() {
    self.emit('attemptReconnect', self);
    if (self.state === DESTROYED || self.state === DESTROYING) return;
    if (self.isConnected()) {
      self.reconnectId = null;
      return;
    }
    self.connectingConnections++;
    connect(self.options, (err, connection) => {
      self.connectingConnections--;
      if (err) {
        if (self.logger.isDebug()) {
          self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
        }
        self.retriesLeft = self.retriesLeft - 1;
        if (self.retriesLeft <= 0) {
          self.destroy();
          self.emit(
            'reconnectFailed',
            new MongoNetworkError(
              f(
                'failed to reconnect after %s attempts with interval %s ms',
                self.options.reconnectTries,
                self.options.reconnectInterval
              )
            )
          );
        } else {
          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
        }
        return;
      }
      if (self.state === DESTROYED || self.state === DESTROYING) {
        return connection.destroy();
      }
      self.reconnectId = null;
      handlers.forEach(event => connection.removeAllListeners(event));
      connection.on('error', self._connectionErrorHandler);
      connection.on('close', self._connectionCloseHandler);
      connection.on('timeout', self._connectionTimeoutHandler);
      connection.on('parseError', self._connectionParseErrorHandler);
      connection.on('message', self._messageHandler);
      self.retriesLeft = self.options.reconnectTries;
      self.availableConnections.push(connection);
      self.reconnectConnection = null;
      self.emit('reconnect', self);
      _execute(self)();
    });
  };
}
function moveConnectionBetween(connection, from, to) {
  var index = from.indexOf(connection);
  if (index !== -1) {
    from.splice(index, 1);
    to.push(connection);
  }
}
function messageHandler(self) {
  return function(message, connection) {
    var workItem = null;
    for (var i = 0; i < connection.workItems.length; i++) {
      if (connection.workItems[i].requestId === message.responseTo) {
        workItem = connection.workItems[i];
        connection.workItems.splice(i, 1);
      }
    }
    if (workItem && workItem.monitoring) {
      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
    }
    self.numberOfConsecutiveTimeouts = 0;
    if (workItem && workItem.socketTimeout) {
      connection.resetSocketTimeout();
    }
    if (self.logger.isDebug()) {
      self.logger.debug(
        f(
          'message [%s] received from %s:%s',
          message.raw.toString('hex'),
          self.options.host,
          self.options.port
        )
      );
    }
    function handleOperationCallback(self, cb, err, result) {
      if (!self.options.domainsEnabled) {
        return process.nextTick(function() {
          return cb(err, result);
        });
      }
      cb(err, result);
    }
    if (!self.executing) {
      process.nextTick(function() {
        _execute(self)();
      });
    }
    if (workItem && !workItem.immediateRelease) {
      try {
        message.parse(workItem);
      } catch (err) {
        return handleOperationCallback(self, workItem.cb, new MongoError(err));
      }
      if (message.documents[0]) {
        const document = message.documents[0];
        const session = workItem.session;
        if (session) {
          updateSessionFromResponse(session, document);
        }
        if (document.$clusterTime) {
          self.topology.clusterTime = document.$clusterTime;
        }
      }
      if (workItem.command && message.documents[0]) {
        const responseDoc = message.documents[0];
        if (responseDoc.writeConcernError) {
          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
          return handleOperationCallback(self, workItem.cb, err);
        }
        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));
        }
      }
      message.hashedName = connection.hashedName;
      handleOperationCallback(
        self,
        workItem.cb,
        null,
        new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message)
      );
    }
  };
}
Pool.prototype.socketCount = function() {
  return this.availableConnections.length + this.inUseConnections.length;
};
function totalConnectionCount(pool) {
  return (
    pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections
  );
}
Pool.prototype.allConnections = function() {
  return this.availableConnections.concat(this.inUseConnections);
};
Pool.prototype.get = function() {
  return this.allConnections()[0];
};
Pool.prototype.isConnected = function() {
  if (this.state === DESTROYED || this.state === DESTROYING) {
    return false;
  }
  var connections = this.availableConnections.concat(this.inUseConnections);
  for (var i = 0; i < connections.length; i++) {
    if (connections[i].isConnected()) return true;
  }
  return false;
};
Pool.prototype.isDestroyed = function() {
  return this.state === DESTROYED || this.state === DESTROYING;
};
Pool.prototype.isDisconnected = function() {
  return this.state === DISCONNECTED;
};
Pool.prototype.connect = function() {
  if (this.state !== DISCONNECTED) {
    throw new MongoError('connection in unlawful state ' + this.state);
  }
  const self = this;
  stateTransition(this, CONNECTING);
  self.connectingConnections++;
  connect(self.options, (err, connection) => {
    self.connectingConnections--;
    if (err) {
      if (self.logger.isDebug()) {
        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
      }
      if (self.state === CONNECTING) {
        self.emit('error', err);
      }
      return;
    }
    if (self.state === DESTROYED || self.state === DESTROYING) {
      connection.destroy();
      return self.destroy();
    }
    connection.on('error', self._connectionErrorHandler);
    connection.on('close', self._connectionCloseHandler);
    connection.on('timeout', self._connectionTimeoutHandler);
    connection.on('parseError', self._connectionParseErrorHandler);
    connection.on('message', self._messageHandler);
    if (self.options.inTopology) {
      stateTransition(self, CONNECTED);
      self.availableConnections.push(connection);
      return self.emit('connect', self, connection);
    }
    if (self.state === DESTROYED || self.state === DESTROYING) {
      return self.destroy();
    }
    if (err) {
      self.destroy();
      return self.emit('error', err);
    }
    stateTransition(self, CONNECTED);
    self.availableConnections.push(connection);
    if (self.minSize) {
      for (let i = 0; i < self.minSize; i++) {
        _createConnection(self);
      }
    }
    self.emit('connect', self, connection);
  });
};
Pool.prototype.auth = function(credentials, callback) {
  if (typeof callback === 'function') callback(null, null);
};
Pool.prototype.logout = function(dbName, callback) {
  if (typeof callback === 'function') callback(null, null);
};
Pool.prototype.unref = function() {
  var connections = this.availableConnections.concat(this.inUseConnections);
  connections.forEach(function(c) {
    c.unref();
  });
};
var events = ['error', 'close', 'timeout', 'parseError', 'connect', 'message'];
function destroy(self, connections, options, callback) {
  let connectionCount = connections.length;
  function connectionDestroyed() {
    connectionCount--;
    if (connectionCount > 0) {
      return;
    }
    self.inUseConnections = [];
    self.availableConnections = [];
    self.connectingConnections = 0;
    stateTransition(self, DESTROYED);
    if (typeof callback === 'function') {
      callback(null, null);
    }
  }
  if (connectionCount === 0) {
    connectionDestroyed();
    return;
  }
  connections.forEach(conn => {
    for (var i = 0; i < events.length; i++) {
      conn.removeAllListeners(events[i]);
    }
    conn.destroy(options, connectionDestroyed);
  });
}
Pool.prototype.destroy = function(force, callback) {
  var self = this;
  if (this.state === DESTROYED || self.state === DESTROYING) {
    if (typeof callback === 'function') callback(null, null);
    return;
  }
  stateTransition(this, DESTROYING);
  if (force) {
    var connections = self.availableConnections.concat(self.inUseConnections);
    while (self.queue.length > 0) {
      var workItem = self.queue.shift();
      if (typeof workItem.cb === 'function') {
        workItem.cb(new MongoError('Pool was force destroyed'));
      }
    }
    return destroy(self, connections, { force: true }, callback);
  }
  if (this.reconnectId) {
    clearTimeout(this.reconnectId);
  }
  if (this.reconnectConnection) {
    this.reconnectConnection.destroy();
  }
  function checkStatus() {
    flushMonitoringOperations(self.queue);
    if (self.queue.length === 0) {
      var connections = self.availableConnections.concat(self.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].workItems.length > 0) {
          return setTimeout(checkStatus, 1);
        }
      }
      destroy(self, connections, { force: false }, callback);
    } else {
      _execute(self)();
      setTimeout(checkStatus, 1);
    }
  }
  checkStatus();
};
Pool.prototype.reset = function(callback) {
  if (typeof callback === 'function') callback();
};
function serializeCommand(self, command, callback) {
  const originalCommandBuffer = command.toBin();
  const shouldCompress = !!self.options.agreedCompressor;
  if (!shouldCompress || !canCompress(command)) {
    return callback(null, originalCommandBuffer);
  }
  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);
  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
  compress(self, messageToBeCompressed, function(err, compressedMessage) {
    if (err) return callback(err, null);
    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
    msgHeader.writeInt32LE(
      MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,
      0
    ); 
    msgHeader.writeInt32LE(command.requestId, 4); 
    msgHeader.writeInt32LE(0, 8); 
    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); 
    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
    compressionDetails.writeInt32LE(originalCommandOpCode, 0); 
    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); 
    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); 
    return callback(null, [msgHeader, compressionDetails, compressedMessage]);
  });
}
Pool.prototype.write = function(command, options, cb) {
  var self = this;
  if (typeof options === 'function') {
    cb = options;
  }
  options = options || {};
  if (!(typeof cb === 'function') && !options.noResponse) {
    throw new MongoError('write method must provide a callback');
  }
  if (this.state === DESTROYED || this.state === DESTROYING) {
    if (cb) {
      try {
        cb(new MongoError('pool destroyed'));
      } catch (err) {
        process.nextTick(function() {
          throw err;
        });
      }
    }
    return;
  }
  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {
    var oldCb = cb;
    cb = process.domain.bind(function() {
      var args = new Array(arguments.length);
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      process.nextTick(function() {
        oldCb.apply(null, args);
      });
    });
  }
  var operation = {
    cb: cb,
    raw: false,
    promoteLongs: true,
    promoteValues: true,
    promoteBuffers: false,
    fullResult: false
  };
  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;
  operation.promoteValues =
    typeof options.promoteValues === 'boolean' ? options.promoteValues : true;
  operation.promoteBuffers =
    typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;
  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;
  operation.immediateRelease =
    typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;
  operation.documentsReturnedIn = options.documentsReturnedIn;
  operation.command = typeof options.command === 'boolean' ? options.command : false;
  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;
  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;
  operation.session = options.session || null;
  operation.socketTimeout = options.socketTimeout;
  operation.monitoring = options.monitoring;
  if (options.socketTimeout) {
    operation.socketTimeout = options.socketTimeout;
  }
  operation.requestId = command.requestId;
  if (self.options.monitorCommands) {
    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));
    operation.started = process.hrtime();
    operation.cb = (err, reply) => {
      if (err) {
        self.emit(
          'commandFailed',
          new apm.CommandFailedEvent(this, command, err, operation.started)
        );
      } else {
        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
          self.emit(
            'commandFailed',
            new apm.CommandFailedEvent(this, command, reply.result, operation.started)
          );
        } else {
          self.emit(
            'commandSucceeded',
            new apm.CommandSucceededEvent(this, command, reply, operation.started)
          );
        }
      }
      if (typeof cb === 'function') cb(err, reply);
    };
  }
  serializeCommand(self, command, (err, serializedBuffers) => {
    if (err) throw err;
    operation.buffer = serializedBuffers;
    if (options.monitoring) {
      self.queue.unshift(operation);
    } else {
      self.queue.push(operation);
    }
    if (!self.executing) {
      process.nextTick(function() {
        _execute(self)();
      });
    }
  });
};
function canCompress(command) {
  const commandDoc = command instanceof Msg ? command.command : command.query;
  const commandName = Object.keys(commandDoc)[0];
  return uncompressibleCommands.indexOf(commandName) === -1;
}
function remove(connection, connections) {
  for (var i = 0; i < connections.length; i++) {
    if (connections[i] === connection) {
      connections.splice(i, 1);
      return true;
    }
  }
}
function removeConnection(self, connection) {
  if (remove(connection, self.availableConnections)) return;
  if (remove(connection, self.inUseConnections)) return;
}
const handlers = ['close', 'message', 'error', 'timeout', 'parseError', 'connect'];
function _createConnection(self) {
  if (self.state === DESTROYED || self.state === DESTROYING) {
    return;
  }
  self.connectingConnections++;
  connect(self.options, (err, connection) => {
    self.connectingConnections--;
    if (err) {
      if (self.logger.isDebug()) {
        self.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
      }
      if (!self.reconnectId && self.options.reconnect) {
        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
      }
      return;
    }
    if (self.state === DESTROYED || self.state === DESTROYING) {
      removeConnection(self, connection);
      return connection.destroy();
    }
    connection.on('error', self._connectionErrorHandler);
    connection.on('close', self._connectionCloseHandler);
    connection.on('timeout', self._connectionTimeoutHandler);
    connection.on('parseError', self._connectionParseErrorHandler);
    connection.on('message', self._messageHandler);
    if (self.state === DESTROYED || self.state === DESTROYING) {
      return connection.destroy();
    }
    removeConnection(self, connection);
    if (err) {
      return connection.destroy();
    }
    self.availableConnections.push(connection);
    _execute(self)();
  });
}
function flushMonitoringOperations(queue) {
  for (var i = 0; i < queue.length; i++) {
    if (queue[i].monitoring) {
      var workItem = queue[i];
      queue.splice(i, 1);
      workItem.cb(
        new MongoError({ message: 'no connection available for monitoring', driver: true })
      );
    }
  }
}
function _execute(self) {
  return function() {
    if (self.state === DESTROYED) return;
    if (self.executing) return;
    self.executing = true;
    if (self.connectingConnections > 0) {
      self.executing = false;
      return;
    }
    while (true) {
      const totalConnections = totalConnectionCount(self);
      if (self.availableConnections.length === 0) {
        flushMonitoringOperations(self.queue);
        break;
      }
      if (self.queue.length === 0) {
        break;
      }
      var connection = null;
      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0);
      if (connections.length === 0) {
        connection =
          self.availableConnections[self.connectionIndex++ % self.availableConnections.length];
      } else {
        connection = connections[self.connectionIndex++ % connections.length];
      }
      if (!connection.isConnected()) {
        removeConnection(self, connection);
        flushMonitoringOperations(self.queue);
        break;
      }
      var workItem = self.queue.shift();
      if (workItem.monitoring) {
        var foundValidConnection = false;
        for (let i = 0; i < self.availableConnections.length; i++) {
          if (
            self.availableConnections[i].isConnected() &&
            self.availableConnections[i].workItems.length === 0
          ) {
            foundValidConnection = true;
            connection = self.availableConnections[i];
            break;
          }
        }
        if (!foundValidConnection) {
          self.queue.unshift(workItem);
          if (totalConnections < self.options.size && self.queue.length > 0) {
            _createConnection(self);
          }
          setTimeout(function() {
            _execute(self)();
          }, 10);
          break;
        }
      }
      if (totalConnections < self.options.size) {
        if (connection.workItems.length > 0) {
          self.queue.unshift(workItem);
          _createConnection(self);
          break;
        }
      }
      var buffer = workItem.buffer;
      if (workItem.monitoring) {
        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);
      }
      if (!workItem.noResponse) {
        connection.workItems.push(workItem);
      }
      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {
        connection.setSocketTimeout(workItem.socketTimeout);
      }
      var writeSuccessful = true;
      if (Array.isArray(buffer)) {
        for (let i = 0; i < buffer.length; i++) {
          writeSuccessful = connection.write(buffer[i]);
        }
      } else {
        writeSuccessful = connection.write(buffer);
      }
      if (workItem.noResponse && typeof workItem.cb === 'function') {
        workItem.cb(null, null);
      }
      if (writeSuccessful === false) {
        self.queue.unshift(workItem);
        removeConnection(self, connection);
        flushMonitoringOperations(self.queue);
        break;
      }
    }
    self.executing = false;
  };
}
Pool._execute = _execute;
module.exports = Pool;
