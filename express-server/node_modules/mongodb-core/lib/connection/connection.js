'use strict';
const EventEmitter = require('events').EventEmitter;
const crypto = require('crypto');
const debugOptions = require('./utils').debugOptions;
const parseHeader = require('../wireprotocol/shared').parseHeader;
const decompress = require('../wireprotocol/compression').decompress;
const Response = require('./commands').Response;
const BinMsg = require('./msg').BinMsg;
const MongoNetworkError = require('../error').MongoNetworkError;
const MongoError = require('../error').MongoError;
const Logger = require('./logger');
const OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;
const OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;
const MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;
const Buffer = require('safe-buffer').Buffer;
let _id = 0;
const DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
const DEBUG_FIELDS = [
  'host',
  'port',
  'size',
  'keepAlive',
  'keepAliveInitialDelay',
  'noDelay',
  'connectionTimeout',
  'socketTimeout',
  'ssl',
  'ca',
  'crl',
  'cert',
  'rejectUnauthorized',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'checkServerIdentity'
];
let connectionAccountingSpy = undefined;
let connectionAccounting = false;
let connections = {};
class Connection extends EventEmitter {
  constructor(socket, options) {
    super();
    options = options || {};
    if (!options.bson) {
      throw new TypeError('must pass in valid bson parser');
    }
    this.id = _id++;
    this.options = options;
    this.logger = Logger('Connection', options);
    this.bson = options.bson;
    this.tag = options.tag;
    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
    this.port = options.port || 27017;
    this.host = options.host || 'localhost';
    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;
    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;
    this.keepAliveInitialDelay =
      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;
    this.connectionTimeout =
      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;
    if (this.keepAliveInitialDelay > this.socketTimeout) {
      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
    }
    if (this.logger.isDebug()) {
      this.logger.debug(
        `creating connection ${this.id} with options [${JSON.stringify(
          debugOptions(DEBUG_FIELDS, options)
        )}]`
      );
    }
    this.responseOptions = {
      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false
    };
    this.flushing = false;
    this.queue = [];
    this.writeStream = null;
    this.destroyed = false;
    const hash = crypto.createHash('sha1');
    hash.update(this.address);
    this.hashedName = hash.digest('hex');
    this.workItems = [];
    this.socket = socket;
    this.socket.once('error', errorHandler(this));
    this.socket.once('timeout', timeoutHandler(this));
    this.socket.once('close', closeHandler(this));
    this.socket.on('data', dataHandler(this));
    if (connectionAccounting) {
      addConnection(this.id, this);
    }
  }
  setSocketTimeout(value) {
    if (this.socket) {
      this.socket.setTimeout(value);
    }
  }
  resetSocketTimeout() {
    if (this.socket) {
      this.socket.setTimeout(this.socketTimeout);
    }
  }
  static enableConnectionAccounting(spy) {
    if (spy) {
      connectionAccountingSpy = spy;
    }
    connectionAccounting = true;
    connections = {};
  }
  static disableConnectionAccounting() {
    connectionAccounting = false;
    connectionAccountingSpy = undefined;
  }
  static connections() {
    return connections;
  }
  get address() {
    return `${this.host}:${this.port}`;
  }
  unref() {
    if (this.socket == null) {
      this.once('connect', () => this.socket.unref());
      return;
    }
    this.socket.unref();
  }
  destroy(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    options = Object.assign({ force: false }, options);
    if (connectionAccounting) {
      deleteConnection(this.id);
    }
    if (this.socket == null) {
      this.destroyed = true;
      return;
    }
    if (options.force) {
      this.socket.destroy();
      this.destroyed = true;
      if (typeof callback === 'function') callback(null, null);
      return;
    }
    this.socket.end(err => {
      this.destroyed = true;
      if (typeof callback === 'function') callback(err, null);
    });
  }
  write(buffer) {
    if (this.logger.isDebug()) {
      if (!Array.isArray(buffer)) {
        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);
      } else {
        for (let i = 0; i < buffer.length; i++)
          this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);
      }
    }
    if (this.socket.destroyed === false) {
      if (!Array.isArray(buffer)) {
        this.socket.write(buffer, 'binary');
        return true;
      }
      for (let i = 0; i < buffer.length; i++) {
        this.socket.write(buffer[i], 'binary');
      }
      return true;
    }
    return false;
  }
  toString() {
    return '' + this.id;
  }
  toJSON() {
    return { id: this.id, host: this.host, port: this.port };
  }
  isConnected() {
    if (this.destroyed) return false;
    return !this.socket.destroyed && this.socket.writable;
  }
}
function deleteConnection(id) {
  delete connections[id];
  if (connectionAccountingSpy) {
    connectionAccountingSpy.deleteConnection(id);
  }
}
function addConnection(id, connection) {
  connections[id] = connection;
  if (connectionAccountingSpy) {
    connectionAccountingSpy.addConnection(id, connection);
  }
}
function errorHandler(conn) {
  return function(err) {
    if (connectionAccounting) deleteConnection(conn.id);
    if (conn.logger.isDebug()) {
      conn.logger.debug(
        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`
      );
    }
    conn.emit('error', new MongoNetworkError(err), conn);
  };
}
function timeoutHandler(conn) {
  return function() {
    if (connectionAccounting) deleteConnection(conn.id);
    if (conn.logger.isDebug()) {
      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
    }
    conn.emit(
      'timeout',
      new MongoNetworkError(`connection ${conn.id} to ${conn.address} timed out`),
      conn
    );
  };
}
function closeHandler(conn) {
  return function(hadError) {
    if (connectionAccounting) deleteConnection(conn.id);
    if (conn.logger.isDebug()) {
      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
    }
    if (!hadError) {
      conn.emit(
        'close',
        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),
        conn
      );
    }
  };
}
function processMessage(conn, message) {
  const msgHeader = parseHeader(message);
  if (msgHeader.opCode !== OP_COMPRESSED) {
    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
    conn.emit(
      'message',
      new ResponseConstructor(
        conn.bson,
        message,
        msgHeader,
        message.slice(MESSAGE_HEADER_SIZE),
        conn.responseOptions
      ),
      conn
    );
    return;
  }
  msgHeader.fromCompressed = true;
  let index = MESSAGE_HEADER_SIZE;
  msgHeader.opCode = message.readInt32LE(index);
  index += 4;
  msgHeader.length = message.readInt32LE(index);
  index += 4;
  const compressorID = message[index];
  index++;
  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {
    if (err) {
      conn.emit('error', err);
      return;
    }
    if (decompressedMsgBody.length !== msgHeader.length) {
      conn.emit(
        'error',
        new MongoError(
          'Decompressing a compressed message from the server failed. The message is corrupt.'
        )
      );
      return;
    }
    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
    conn.emit(
      'message',
      new ResponseConstructor(
        conn.bson,
        message,
        msgHeader,
        decompressedMsgBody,
        conn.responseOptions
      ),
      conn
    );
  });
}
function dataHandler(conn) {
  return function(data) {
    while (data.length > 0) {
      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
        if (remainingBytesToRead > data.length) {
          data.copy(conn.buffer, conn.bytesRead);
          conn.bytesRead = conn.bytesRead + data.length;
          data = Buffer.alloc(0);
        } else {
          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
          data = data.slice(remainingBytesToRead);
          const emitBuffer = conn.buffer;
          conn.buffer = null;
          conn.sizeOfMessage = 0;
          conn.bytesRead = 0;
          conn.stubBuffer = null;
          processMessage(conn, emitBuffer);
        }
      } else {
        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
          if (conn.stubBuffer.length + data.length > 4) {
            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);
            conn.stubBuffer.copy(newData, 0);
            data.copy(newData, conn.stubBuffer.length);
            data = newData;
            conn.buffer = null;
            conn.sizeOfMessage = 0;
            conn.bytesRead = 0;
            conn.stubBuffer = null;
          } else {
            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);
            conn.stubBuffer.copy(newStubBuffer, 0);
            data.copy(newStubBuffer, conn.stubBuffer.length);
            data = Buffer.alloc(0);
          }
        } else {
          if (data.length > 4) {
            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
              const errorObject = {
                err: 'socketHandler',
                trace: '',
                bin: conn.buffer,
                parseState: {
                  sizeOfMessage: sizeOfMessage,
                  bytesRead: conn.bytesRead,
                  stubBuffer: conn.stubBuffer
                }
              };
              conn.emit('parseError', errorObject, conn);
              return;
            }
            if (
              sizeOfMessage > 4 &&
              sizeOfMessage < conn.maxBsonMessageSize &&
              sizeOfMessage > data.length
            ) {
              conn.buffer = Buffer.alloc(sizeOfMessage);
              data.copy(conn.buffer, 0);
              conn.bytesRead = data.length;
              conn.sizeOfMessage = sizeOfMessage;
              conn.stubBuffer = null;
              data = Buffer.alloc(0);
            } else if (
              sizeOfMessage > 4 &&
              sizeOfMessage < conn.maxBsonMessageSize &&
              sizeOfMessage === data.length
            ) {
              const emitBuffer = data;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              data = Buffer.alloc(0);
              processMessage(conn, emitBuffer);
            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
              const errorObject = {
                err: 'socketHandler',
                trace: null,
                bin: data,
                parseState: {
                  sizeOfMessage: sizeOfMessage,
                  bytesRead: 0,
                  buffer: null,
                  stubBuffer: null
                }
              };
              conn.emit('parseError', errorObject, conn);
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              data = Buffer.alloc(0);
            } else {
              const emitBuffer = data.slice(0, sizeOfMessage);
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              data = data.slice(sizeOfMessage);
              processMessage(conn, emitBuffer);
            }
          } else {
            conn.stubBuffer = Buffer.alloc(data.length);
            data.copy(conn.stubBuffer, 0);
            data = Buffer.alloc(0);
          }
        }
      }
    }
  };
}
module.exports = Connection;
