'use strict';
const mongoErrorContextSymbol = Symbol('mongoErrorContextSymbol');
class MongoError extends Error {
  constructor(message) {
    if (message instanceof Error) {
      super(message.message);
      this.stack = message.stack;
    } else {
      if (typeof message === 'string') {
        super(message);
      } else {
        super(message.message || message.errmsg || message.$err || 'n/a');
        for (var name in message) {
          this[name] = message[name];
        }
      }
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = 'MongoError';
    this[mongoErrorContextSymbol] = this[mongoErrorContextSymbol] || {};
  }
  static create(options) {
    return new MongoError(options);
  }
  hasErrorLabel(label) {
    return this.errorLabels && this.errorLabels.indexOf(label) !== -1;
  }
}
class MongoNetworkError extends MongoError {
  constructor(message) {
    super(message);
    this.name = 'MongoNetworkError';
    this.errorLabels = ['TransientTransactionError'];
  }
}
class MongoParseError extends MongoError {
  constructor(message) {
    super(message);
    this.name = 'MongoParseError';
  }
}
class MongoTimeoutError extends MongoError {
  constructor(message) {
    super(message);
    this.name = 'MongoTimeoutError';
  }
}
function makeWriteConcernResultObject(input) {
  const output = Object.assign({}, input);
  if (output.ok === 0) {
    output.ok = 1;
    delete output.errmsg;
    delete output.code;
    delete output.codeName;
  }
  return output;
}
class MongoWriteConcernError extends MongoError {
  constructor(message, result) {
    super(message);
    this.name = 'MongoWriteConcernError';
    if (result != null) {
      this.result = makeWriteConcernResultObject(result);
    }
  }
}
const RETRYABLE_ERROR_CODES = new Set([
  6, 
  7, 
  89, 
  91, 
  189, 
  9001, 
  10107, 
  11600, 
  11602, 
  13435, 
  13436 
]);
function isRetryableError(error) {
  return (
    RETRYABLE_ERROR_CODES.has(error.code) ||
    error instanceof MongoNetworkError ||
    error.message.match(/not master/) ||
    error.message.match(/node is recovering/)
  );
}
module.exports = {
  MongoError,
  MongoNetworkError,
  MongoParseError,
  MongoTimeoutError,
  MongoWriteConcernError,
  mongoErrorContextSymbol,
  isRetryableError
};
