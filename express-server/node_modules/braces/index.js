'use strict';
var toRegex = require('to-regex');
var unique = require('array-unique');
var extend = require('extend-shallow');
var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Braces = require('./lib/braces');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;
var cache = {};
function braces(pattern, options) {
  var key = utils.createKey(String(pattern), options);
  var arr = [];
  var disabled = options && options.cache === false;
  if (!disabled && cache.hasOwnProperty(key)) {
    return cache[key];
  }
  if (Array.isArray(pattern)) {
    for (var i = 0; i < pattern.length; i++) {
      arr.push.apply(arr, braces.create(pattern[i], options));
    }
  } else {
    arr = braces.create(pattern, options);
  }
  if (options && options.nodupes === true) {
    arr = unique(arr);
  }
  if (!disabled) {
    cache[key] = arr;
  }
  return arr;
}
braces.expand = function(pattern, options) {
  return braces.create(pattern, extend({}, options, {expand: true}));
};
braces.optimize = function(pattern, options) {
  return braces.create(pattern, options);
};
braces.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }
  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }
  function create() {
    if (pattern === '' || pattern.length < 3) {
      return [pattern];
    }
    if (utils.isEmptySets(pattern)) {
      return [];
    }
    if (utils.isQuotedString(pattern)) {
      return [pattern.slice(1, -1)];
    }
    var proto = new Braces(options);
    var result = !options || options.expand !== true
      ? proto.optimize(pattern, options)
      : proto.expand(pattern, options);
    var arr = result.output;
    if (options && options.noempty === true) {
      arr = arr.filter(Boolean);
    }
    if (options && options.nodupes === true) {
      arr = unique(arr);
    }
    Object.defineProperty(arr, 'result', {
      enumerable: false,
      value: result
    });
    return arr;
  }
  return memoize('create', pattern, options, create);
};
braces.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }
  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }
  function makeRe() {
    var arr = braces(pattern, options);
    var opts = extend({strictErrors: false}, options);
    return toRegex(arr, opts);
  }
  return memoize('makeRe', pattern, options, makeRe);
};
braces.parse = function(pattern, options) {
  var proto = new Braces(options);
  return proto.parse(pattern, options);
};
braces.compile = function(ast, options) {
  var proto = new Braces(options);
  return proto.compile(ast, options);
};
braces.clearCache = function() {
  cache = braces.cache = {};
};
function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + ':' + pattern, options);
  var disabled = options && options.cache === false;
  if (disabled) {
    braces.clearCache();
    return fn(pattern, options);
  }
  if (cache.hasOwnProperty(key)) {
    return cache[key];
  }
  var res = fn(pattern, options);
  cache[key] = res;
  return res;
}
braces.Braces = Braces;
braces.compilers = compilers;
braces.parsers = parsers;
braces.cache = cache;
module.exports = braces;
