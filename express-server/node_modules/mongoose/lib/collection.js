'use strict';
const EventEmitter = require('events').EventEmitter;
const STATES = require('./connectionstate');
const immediate = require('./helpers/immediate');
function Collection(name, conn, opts) {
  if (opts === void 0) {
    opts = {};
  }
  if (opts.capped === void 0) {
    opts.capped = {};
  }
  opts.bufferCommands = undefined === opts.bufferCommands
    ? true
    : opts.bufferCommands;
  if (typeof opts.capped === 'number') {
    opts.capped = {size: opts.capped};
  }
  this.opts = opts;
  this.name = name;
  this.collectionName = name;
  this.conn = conn;
  this.queue = [];
  this.buffer = this.opts.bufferCommands;
  this.emitter = new EventEmitter();
  if (STATES.connected === this.conn.readyState) {
    this.onOpen();
  }
}
Collection.prototype.name;
Collection.prototype.collectionName;
Collection.prototype.conn;
Collection.prototype.onOpen = function() {
  this.buffer = false;
  immediate(() => this.doQueue());
};
Collection.prototype.onClose = function(force) {
  if (this.opts.bufferCommands && !force) {
    this.buffer = true;
  }
};
Collection.prototype.addQueue = function(name, args) {
  this.queue.push([name, args]);
  return this;
};
Collection.prototype.doQueue = function() {
  for (let i = 0, l = this.queue.length; i < l; i++) {
    if (typeof this.queue[i][0] === 'function') {
      this.queue[i][0].apply(this, this.queue[i][1]);
    } else {
      this[this.queue[i][0]].apply(this, this.queue[i][1]);
    }
  }
  this.queue = [];
  const _this = this;
  process.nextTick(function() {
    _this.emitter.emit('queue');
  });
  return this;
};
Collection.prototype.ensureIndex = function() {
  throw new Error('Collection#ensureIndex unimplemented by driver');
};
Collection.prototype.createIndex = function() {
  throw new Error('Collection#ensureIndex unimplemented by driver');
};
Collection.prototype.findAndModify = function() {
  throw new Error('Collection#findAndModify unimplemented by driver');
};
Collection.prototype.findOneAndUpdate = function() {
  throw new Error('Collection#findOneAndUpdate unimplemented by driver');
};
Collection.prototype.findOneAndDelete = function() {
  throw new Error('Collection#findOneAndDelete unimplemented by driver');
};
Collection.prototype.findOneAndReplace = function() {
  throw new Error('Collection#findOneAndReplace unimplemented by driver');
};
Collection.prototype.findOne = function() {
  throw new Error('Collection#findOne unimplemented by driver');
};
Collection.prototype.find = function() {
  throw new Error('Collection#find unimplemented by driver');
};
Collection.prototype.insert = function() {
  throw new Error('Collection#insert unimplemented by driver');
};
Collection.prototype.insertOne = function() {
  throw new Error('Collection#insertOne unimplemented by driver');
};
Collection.prototype.insertMany = function() {
  throw new Error('Collection#insertMany unimplemented by driver');
};
Collection.prototype.save = function() {
  throw new Error('Collection#save unimplemented by driver');
};
Collection.prototype.update = function() {
  throw new Error('Collection#update unimplemented by driver');
};
Collection.prototype.getIndexes = function() {
  throw new Error('Collection#getIndexes unimplemented by driver');
};
Collection.prototype.mapReduce = function() {
  throw new Error('Collection#mapReduce unimplemented by driver');
};
Collection.prototype.watch = function() {
  throw new Error('Collection#watch unimplemented by driver');
};
module.exports = Collection;
