'use strict';
if (global.MONGOOSE_DRIVER_PATH) {
  const deprecationWarning = 'The `MONGOOSE_DRIVER_PATH` global property is ' +
    'deprecated. Use `mongoose.driver.set()` instead.';
  const setDriver = require('util').deprecate(function() {
    require('./driver').set(require(global.MONGOOSE_DRIVER_PATH));
  }, deprecationWarning);
  setDriver();
} else {
  require('./driver').set(require('./drivers/node-mongodb-native'));
}
const Schema = require('./schema');
const SchemaType = require('./schematype');
const SchemaTypes = require('./schema/index');
const VirtualType = require('./virtualtype');
const STATES = require('./connectionstate');
const Types = require('./types');
const Query = require('./query');
const Model = require('./model');
const Document = require('./document');
const applyPlugins = require('./helpers/schema/applyPlugins');
const get = require('./helpers/get');
const legacyPluralize = require('mongoose-legacy-pluralize');
const utils = require('./utils');
const pkg = require('../package.json');
const cast = require('./cast');
const removeSubdocs = require('./plugins/removeSubdocs');
const saveSubdocs = require('./plugins/saveSubdocs');
const validateBeforeSave = require('./plugins/validateBeforeSave');
const Aggregate = require('./aggregate');
const PromiseProvider = require('./promise_provider');
const shardingPlugin = require('./plugins/sharding');
const defaultMongooseSymbol = Symbol.for('mongoose:default');
require('./helpers/printJestWarning');
function Mongoose(options) {
  this.connections = [];
  this.models = {};
  this.modelSchemas = {};
  this.options = {
    pluralization: true
  };
  const conn = this.createConnection(); 
  conn.models = this.models;
  this._pluralize = legacyPluralize;
  if (!options || !options[defaultMongooseSymbol]) {
    const _this = this;
    this.Schema = function() {
      this.base = _this;
      return Schema.apply(this, arguments);
    };
    this.Schema.prototype = Object.create(Schema.prototype);
    Object.assign(this.Schema, Schema);
    this.Schema.base = this;
    this.Schema.Types = Object.assign({}, Schema.Types);
  } else {
    for (const key of ['Schema', 'model']) {
      this[key] = Mongoose.prototype[key];
    }
  }
  this.Schema.prototype.base = this;
  Object.defineProperty(this, 'plugins', {
    configurable: false,
    enumerable: true,
    writable: false,
    value: [
      [saveSubdocs, { deduplicate: true }],
      [validateBeforeSave, { deduplicate: true }],
      [shardingPlugin, { deduplicate: true }],
      [removeSubdocs, { deduplicate: true }]
    ]
  });
}
Mongoose.prototype.cast = cast;
Mongoose.prototype.STATES = STATES;
Mongoose.prototype.driver = require('./driver');
Mongoose.prototype.set = function(key, value) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  if (arguments.length === 1) {
    return _mongoose.options[key];
  }
  _mongoose.options[key] = value;
  if (key === 'objectIdGetter') {
    if (value) {
      Object.defineProperty(mongoose.Types.ObjectId.prototype, '_id', {
        enumerable: false,
        configurable: true,
        get: function() {
          return this;
        }
      });
    } else {
      delete mongoose.Types.ObjectId.prototype._id;
    }
  }
  return _mongoose;
};
Mongoose.prototype.get = Mongoose.prototype.set;
Mongoose.prototype.createConnection = function(uri, options, callback) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  const conn = new Connection(_mongoose);
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  _mongoose.connections.push(conn);
  if (arguments.length > 0) {
    return conn.openUri(uri, options, callback);
  }
  return conn;
};
Mongoose.prototype.connect = function() {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  const conn = _mongoose.connection;
  return conn.openUri(arguments[0], arguments[1], arguments[2]).then(() => _mongoose);
};
Mongoose.prototype.disconnect = function(callback) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  return utils.promiseOrCallback(callback, cb => {
    let remaining = _mongoose.connections.length;
    if (remaining <= 0) {
      return cb(null);
    }
    _mongoose.connections.forEach(conn => {
      conn.close(function(error) {
        if (error) {
          return cb(error);
        }
        if (!--remaining) {
          cb(null);
        }
      });
    });
  });
};
Mongoose.prototype.startSession = function() {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
};
Mongoose.prototype.pluralize = function(fn) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  if (arguments.length > 0) {
    _mongoose._pluralize = fn;
  }
  return _mongoose._pluralize;
};
Mongoose.prototype.model = function(name, schema, collection, skipInit) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  let model;
  if (typeof name === 'function') {
    model = name;
    name = model.name;
    if (!(model.prototype instanceof Model)) {
      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');
    }
  }
  if (typeof schema === 'string') {
    collection = schema;
    schema = false;
  }
  if (utils.isObject(schema) && !(schema.instanceOfSchema)) {
    schema = new Schema(schema);
  }
  if (schema && !schema.instanceOfSchema) {
    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
      'schema or a POJO');
  }
  if (typeof collection === 'boolean') {
    skipInit = collection;
    collection = null;
  }
  let options;
  if (skipInit && utils.isObject(skipInit)) {
    options = skipInit;
    skipInit = true;
  } else {
    options = {};
  }
  if (!_mongoose.modelSchemas[name]) {
    if (schema) {
      _mongoose.modelSchemas[name] = schema;
    } else {
      throw new mongoose.Error.MissingSchemaError(name);
    }
  }
  const originalSchema = schema;
  if (schema) {
    if (_mongoose.get('cloneSchemas')) {
      schema = schema.clone();
    }
    _mongoose._applyPlugins(schema);
  }
  let sub;
  if (_mongoose.models[name] && options.cache !== false) {
    if (originalSchema &&
        originalSchema.instanceOfSchema &&
        originalSchema !== _mongoose.models[name].schema) {
      throw new _mongoose.Error.OverwriteModelError(name);
    }
    if (collection && collection !== _mongoose.models[name].collection.name) {
      model = _mongoose.models[name];
      schema = model.prototype.schema;
      sub = model.__subclass(_mongoose.connection, schema, collection);
      return sub;
    }
    return _mongoose.models[name];
  }
  if (!schema) {
    schema = this.modelSchemas[name];
    if (!schema) {
      throw new mongoose.Error.MissingSchemaError(name);
    }
  }
  if (!('pluralization' in schema.options)) {
    schema.options.pluralization = _mongoose.options.pluralization;
  }
  if (!collection) {
    collection = schema.get('collection') ||
      utils.toCollectionName(name, _mongoose.pluralize());
  }
  const connection = options.connection || _mongoose.connection;
  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
  if (!skipInit) {
    model.init(function $modelInitNoop() {});
  }
  if (options.cache === false) {
    return model;
  }
  _mongoose.models[name] = model;
  return _mongoose.models[name];
};
Mongoose.prototype.deleteModel = function(name) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  _mongoose.connection.deleteModel(name);
  return _mongoose;
};
Mongoose.prototype.modelNames = function() {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  const names = Object.keys(_mongoose.models);
  return names;
};
Mongoose.prototype._applyPlugins = function(schema, options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  options = options || {};
  options.applyPluginsToDiscriminators = get(_mongoose,
    'options.applyPluginsToDiscriminators', false);
  options.applyPluginsToChildSchemas = get(_mongoose,
    'options.applyPluginsToChildSchemas', true);
  applyPlugins(schema, _mongoose.plugins, options, '$globalPluginsApplied');
};
Mongoose.prototype.plugin = function(fn, opts) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  _mongoose.plugins.push([fn, opts]);
  return _mongoose;
};
Mongoose.prototype.__defineGetter__('connection', function() {
  return this.connections[0];
});
Mongoose.prototype.__defineSetter__('connection', function(v) {
  if (v instanceof Connection) {
    this.connections[0] = v;
    this.models = v.models;
  }
});
Mongoose.prototype.connections;
const driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';
const Connection = require(driver + '/connection');
const Collection = require(driver + '/collection');
Mongoose.prototype.Aggregate = Aggregate;
Mongoose.prototype.Collection = Collection;
Mongoose.prototype.Connection = Connection;
Mongoose.prototype.version = pkg.version;
Mongoose.prototype.Mongoose = Mongoose;
Mongoose.prototype.Schema = Schema;
Mongoose.prototype.SchemaType = SchemaType;
Mongoose.prototype.SchemaTypes = Schema.Types;
Mongoose.prototype.VirtualType = VirtualType;
Mongoose.prototype.Types = Types;
Mongoose.prototype.Query = Query;
Object.defineProperty(Mongoose.prototype, 'Promise', {
  get: function() {
    return PromiseProvider.get();
  },
  set: function(lib) {
    PromiseProvider.set(lib);
  }
});
Mongoose.prototype.PromiseProvider = PromiseProvider;
Mongoose.prototype.Model = Model;
Mongoose.prototype.Document = Document;
Mongoose.prototype.DocumentProvider = require('./document_provider');
Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
Mongoose.prototype.Mixed = SchemaTypes.Mixed;
Mongoose.prototype.Number = SchemaTypes.Number;
Mongoose.prototype.Error = require('./error/index');
Mongoose.prototype.now = function now() { return new Date(); };
Mongoose.prototype.CastError = require('./error/cast');
Mongoose.prototype.mongo = require('mongodb');
Mongoose.prototype.mquery = require('mquery');
const mongoose = module.exports = exports = new Mongoose({
  [defaultMongooseSymbol]: true
});
