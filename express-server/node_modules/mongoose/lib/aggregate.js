'use strict';
const AggregationCursor = require('./cursor/AggregationCursor');
const Query = require('./query');
const applyGlobalMaxTimeMS = require('./helpers/query/applyGlobalMaxTimeMS');
const util = require('util');
const utils = require('./utils');
const read = Query.prototype.read;
const readConcern = Query.prototype.readConcern;
function Aggregate(pipeline) {
  this._pipeline = [];
  this._model = undefined;
  this.options = {};
  if (arguments.length === 1 && util.isArray(pipeline)) {
    this.append.apply(this, pipeline);
  }
}
Aggregate.prototype.options;
Aggregate.prototype.model = function(model) {
  if (arguments.length === 0) {
    return this._model;
  }
  this._model = model;
  if (model.schema != null) {
    if (this.options.readPreference == null &&
        model.schema.options.read != null) {
      this.options.readPreference = model.schema.options.read;
    }
    if (this.options.collation == null &&
        model.schema.options.collation != null) {
      this.options.collation = model.schema.options.collation;
    }
  }
  return this;
};
Aggregate.prototype.append = function() {
  const args = (arguments.length === 1 && util.isArray(arguments[0]))
    ? arguments[0]
    : utils.args(arguments);
  if (!args.every(isOperator)) {
    throw new Error('Arguments must be aggregate pipeline operators');
  }
  this._pipeline = this._pipeline.concat(args);
  return this;
};
Aggregate.prototype.addFields = function(arg) {
  const fields = {};
  if (typeof arg === 'object' && !util.isArray(arg)) {
    Object.keys(arg).forEach(function(field) {
      fields[field] = arg[field];
    });
  } else {
    throw new Error('Invalid addFields() argument. Must be an object');
  }
  return this.append({$addFields: fields});
};
Aggregate.prototype.project = function(arg) {
  const fields = {};
  if (typeof arg === 'object' && !util.isArray(arg)) {
    Object.keys(arg).forEach(function(field) {
      fields[field] = arg[field];
    });
  } else if (arguments.length === 1 && typeof arg === 'string') {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      const include = field[0] === '-' ? 0 : 1;
      if (include === 0) {
        field = field.substring(1);
      }
      fields[field] = include;
    });
  } else {
    throw new Error('Invalid project() argument. Must be string or object');
  }
  return this.append({$project: fields});
};
Aggregate.prototype.near = function(arg) {
  const op = {};
  op.$geoNear = arg;
  return this.append(op);
};
'group match skip limit out'.split(' ').forEach(function($operator) {
  Aggregate.prototype[$operator] = function(arg) {
    const op = {};
    op['$' + $operator] = arg;
    return this.append(op);
  };
});
Aggregate.prototype.unwind = function() {
  const args = utils.args(arguments);
  const res = [];
  for (let i = 0; i < args.length; ++i) {
    const arg = args[i];
    if (arg && typeof arg === 'object') {
      res.push({ $unwind: arg });
    } else if (typeof arg === 'string') {
      res.push({
        $unwind: (arg && arg.startsWith('$')) ? arg : '$' + arg
      });
    } else {
      throw new Error('Invalid arg "' + arg + '" to unwind(), ' +
        'must be string or object');
    }
  }
  return this.append.apply(this, res);
};
Aggregate.prototype.replaceRoot = function(newRoot) {
  let ret;
  if (typeof newRoot === 'string') {
    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;
  } else {
    ret = newRoot;
  }
  return this.append({
    $replaceRoot: {
      newRoot: ret
    }
  });
};
Aggregate.prototype.count = function(countName) {
  return this.append({ $count: countName });
};
Aggregate.prototype.sortByCount = function(arg) {
  if (arg && typeof arg === 'object') {
    return this.append({ $sortByCount: arg });
  } else if (typeof arg === 'string') {
    return this.append({
      $sortByCount: (arg && arg.startsWith('$')) ? arg : '$' + arg
    });
  } else {
    throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), ' +
      'must be string or object');
  }
};
Aggregate.prototype.lookup = function(options) {
  return this.append({$lookup: options});
};
Aggregate.prototype.graphLookup = function(options) {
  const cloneOptions = {};
  if (options) {
    if (!utils.isObject(options)) {
      throw new TypeError('Invalid graphLookup() argument. Must be an object.');
    }
    utils.mergeClone(cloneOptions, options);
    const startWith = cloneOptions.startWith;
    if (startWith && typeof startWith === 'string') {
      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?
        cloneOptions.startWith :
        '$' + cloneOptions.startWith;
    }
  }
  return this.append({ $graphLookup: cloneOptions });
};
Aggregate.prototype.sample = function(size) {
  return this.append({$sample: {size: size}});
};
Aggregate.prototype.sort = function(arg) {
  const sort = {};
  if (arg.constructor.name === 'Object') {
    const desc = ['desc', 'descending', -1];
    Object.keys(arg).forEach(function(field) {
      if (arg[field] instanceof Object && arg[field].$meta) {
        sort[field] = arg[field];
        return;
      }
      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
    });
  } else if (arguments.length === 1 && typeof arg === 'string') {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      const ascend = field[0] === '-' ? -1 : 1;
      if (ascend === -1) {
        field = field.substring(1);
      }
      sort[field] = ascend;
    });
  } else {
    throw new TypeError('Invalid sort() argument. Must be a string or object.');
  }
  return this.append({$sort: sort});
};
Aggregate.prototype.read = function(pref, tags) {
  if (!this.options) {
    this.options = {};
  }
  read.call(this, pref, tags);
  return this;
};
Aggregate.prototype.readConcern = function(level) {
  if (!this.options) {
    this.options = {};
  }
  readConcern.call(this, level);
  return this;
};
Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
  if (arguments.length === 3) {
    if ((typeof thenExpr === 'string' && !thenExpr.startsWith('$$')) ||
        (typeof elseExpr === 'string' && !elseExpr.startsWith('$$'))) {
      throw new Error('If thenExpr or elseExpr is string, it must start with $$. e.g. $$DESCEND, $$PRUNE, $$KEEP');
    }
    expression = {
      $cond: {
        if: expression,
        then: thenExpr,
        else: elseExpr
      }
    };
  } else if (arguments.length !== 1) {
    throw new TypeError('Invalid arguments');
  }
  return this.append({$redact: expression});
};
Aggregate.prototype.explain = function(callback) {
  return utils.promiseOrCallback(callback, cb => {
    if (!this._pipeline.length) {
      const err = new Error('Aggregate has empty pipeline');
      return cb(err);
    }
    prepareDiscriminatorPipeline(this);
    this._model.collection.
      aggregate(this._pipeline, this.options || {}).
      explain(function(error, result) {
        if (error) {
          return cb(error);
        }
        cb(null, result);
      });
  }, this._model.events);
};
Aggregate.prototype.allowDiskUse = function(value) {
  this.options.allowDiskUse = value;
  return this;
};
Aggregate.prototype.hint = function(value) {
  this.options.hint = value;
  return this;
};
Aggregate.prototype.session = function(session) {
  if (session == null) {
    delete this.options.session;
  } else {
    this.options.session = session;
  }
  return this;
};
Aggregate.prototype.option = function(value) {
  for (const key in value) {
    this.options[key] = value[key];
  }
  return this;
};
Aggregate.prototype.cursor = function(options) {
  if (!this.options) {
    this.options = {};
  }
  this.options.cursor = options || {};
  return this;
};
Aggregate.prototype.addCursorFlag = util.deprecate(function(flag, value) {
  if (!this.options) {
    this.options = {};
  }
  this.options[flag] = value;
  return this;
}, 'Mongoose: `Aggregate#addCursorFlag()` is deprecated, use `option()` instead');
Aggregate.prototype.collation = function(collation) {
  if (!this.options) {
    this.options = {};
  }
  this.options.collation = collation;
  return this;
};
Aggregate.prototype.facet = function(options) {
  return this.append({$facet: options});
};
Aggregate.prototype.pipeline = function() {
  return this._pipeline;
};
Aggregate.prototype.exec = function(callback) {
  if (!this._model) {
    throw new Error('Aggregate not bound to any Model');
  }
  const model = this._model;
  const pipeline = this._pipeline;
  const collection = this._model.collection;
  applyGlobalMaxTimeMS(this.options, model);
  if (this.options && this.options.cursor) {
    return new AggregationCursor(this);
  }
  return utils.promiseOrCallback(callback, cb => {
    if (!pipeline.length) {
      const err = new Error('Aggregate has empty pipeline');
      return cb(err);
    }
    prepareDiscriminatorPipeline(this);
    model.hooks.execPre('aggregate', this, error => {
      if (error) {
        const _opts = { error: error };
        return model.hooks.execPost('aggregate', this, [null], _opts, error => {
          cb(error);
        });
      }
      const options = utils.clone(this.options || {});
      collection.aggregate(pipeline, options, (error, cursor) => {
        if (error) {
          const _opts = { error: error };
          return model.hooks.execPost('aggregate', this, [null], _opts, error => {
            if (error) {
              return cb(error);
            }
            return cb(null);
          });
        }
        cursor.toArray((error, result) => {
          const _opts = { error: error };
          model.hooks.execPost('aggregate', this, [result], _opts, (error, result) => {
            if (error) {
              return cb(error);
            }
            cb(null, result);
          });
        });
      });
    });
  }, model.events);
};
Aggregate.prototype.then = function(resolve, reject) {
  return this.exec().then(resolve, reject);
};
Aggregate.prototype.catch = function(reject) {
  return this.exec().then(null, reject);
};
if (Symbol.asyncIterator != null) {
  Aggregate.prototype[Symbol.asyncIterator] = function() {
    return this.cursor({ useMongooseAggCursor: true }).
      exec().
      transformNull().
      map(doc => {
        return doc == null ? { done: true } : { value: doc, done: false };
      });
  };
}
function isOperator(obj) {
  if (typeof obj !== 'object') {
    return false;
  }
  const k = Object.keys(obj);
  return k.length === 1 && k.some(key => { return key[0] === '$'; });
}
Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
function prepareDiscriminatorPipeline(aggregate) {
  const schema = aggregate._model.schema;
  const discriminatorMapping = schema && schema.discriminatorMapping;
  if (discriminatorMapping && !discriminatorMapping.isRoot) {
    const originalPipeline = aggregate._pipeline;
    const discriminatorKey = discriminatorMapping.key;
    const discriminatorValue = discriminatorMapping.value;
    if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {
      originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
    } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {
      originalPipeline[0].$geoNear.query =
          originalPipeline[0].$geoNear.query || {};
      originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;
    } else {
      const match = {};
      match[discriminatorKey] = discriminatorValue;
      aggregate._pipeline.unshift({ $match: match });
    }
  }
}
module.exports = Aggregate;
