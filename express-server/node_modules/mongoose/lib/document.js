'use strict';
const EventEmitter = require('events').EventEmitter;
const InternalCache = require('./internal');
const MongooseError = require('./error');
const MixedSchema = require('./schema/mixed');
const ObjectExpectedError = require('./error/objectExpected');
const ObjectParameterError = require('./error/objectParameter');
const StrictModeError = require('./error/strict');
const ValidatorError = require('./schematype').ValidatorError;
const VirtualType = require('./virtualtype');
const cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');
const compile = require('./helpers/document/compile').compile;
const defineKey = require('./helpers/document/compile').defineKey;
const flatten = require('./helpers/common').flatten;
const get = require('./helpers/get');
const getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');
const idGetter = require('./plugins/idGetter');
const isDefiningProjection = require('./helpers/projection/isDefiningProjection');
const isExclusive = require('./helpers/projection/isExclusive');
const inspect = require('util').inspect;
const internalToObjectOptions = require('./options').internalToObjectOptions;
const mpath = require('mpath');
const utils = require('./utils');
const ValidationError = MongooseError.ValidationError;
const clone = utils.clone;
const deepEqual = utils.deepEqual;
const isMongooseObject = utils.isMongooseObject;
const arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;
const documentArrayParent = require('./helpers/symbols').documentArrayParent;
const documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;
const getSymbol = require('./helpers/symbols').getSymbol;
const populateModelSymbol = require('./helpers/symbols').populateModelSymbol;
let DocumentArray;
let MongooseArray;
let Embedded;
const specialProperties = utils.specialProperties;
function Document(obj, fields, skipId, options) {
  if (typeof skipId === 'object' && skipId != null) {
    options = skipId;
    skipId = options.skipId;
  }
  options = options || {};
  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = 'isNew' in options ? options.isNew : true;
  this.errors = undefined;
  this.$__.$options = options || {};
  if (obj != null && typeof obj !== 'object') {
    throw new ObjectParameterError(obj, 'obj', 'Document');
  }
  const schema = this.schema;
  if (typeof fields === 'boolean') {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = schema.options.strict;
    this.$__.selected = fields;
  }
  const required = schema.requiredPaths(true);
  for (let i = 0; i < required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }
  this.$__.emitter.setMaxListeners(0);
  let exclude = null;
  if (utils.isPOJO(fields)) {
    exclude = isExclusive(fields);
  }
  const hasIncludedChildren = exclude === false && fields ?
    $__hasIncludedChildren(fields) :
    {};
  if (this._doc == null) {
    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {
      isNew: this.isNew
    });
  }
  if (obj) {
    if (obj instanceof Document) {
      this.isNew = obj.isNew;
    }
    if (this.$__original_set) {
      this.$__original_set(obj, undefined, true);
    } else {
      this.$set(obj, undefined, true);
    }
  }
  if (options.willInit) {
    this.once('init', () => {
      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
        isNew: this.isNew
      });
    });
  } else {
    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
      isNew: this.isNew
    });
  }
  this.$__._id = this._id;
  this.$locals = {};
  if (!schema.options.strict && obj) {
    const _this = this;
    const keys = Object.keys(this._doc);
    keys.forEach(function(key) {
      if (!(key in schema.tree)) {
        defineKey(key, null, _this);
      }
    });
  }
  applyQueue(this);
}
utils.each(
  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
    'removeAllListeners', 'addListener'],
  function(emitterFn) {
    Document.prototype[emitterFn] = function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
  });
Document.prototype.constructor = Document;
Document.prototype.schema;
Object.defineProperty(Document.prototype, '$locals', {
  configurable: false,
  enumerable: false,
  writable: true
});
Document.prototype.isNew;
Document.prototype.id;
Document.prototype.errors;
function $__hasIncludedChildren(fields) {
  const hasIncludedChildren = {};
  const keys = Object.keys(fields);
  for (let j = 0; j < keys.length; ++j) {
    const parts = keys[j].split('.');
    const c = [];
    for (let k = 0; k < parts.length; ++k) {
      c.push(parts[k]);
      hasIncludedChildren[c.join('.')] = 1;
    }
  }
  return hasIncludedChildren;
}
function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
  const paths = Object.keys(doc.schema.paths);
  const plen = paths.length;
  for (let i = 0; i < plen; ++i) {
    let def;
    let curPath = '';
    const p = paths[i];
    if (p === '_id' && skipId) {
      continue;
    }
    const type = doc.schema.paths[p];
    const path = p.split('.');
    const len = path.length;
    let included = false;
    let doc_ = doc._doc;
    for (let j = 0; j < len; ++j) {
      if (doc_ == null) {
        break;
      }
      const piece = path[j];
      curPath += (!curPath.length ? '' : '.') + piece;
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }
      if (j === len - 1) {
        if (doc_[piece] !== void 0) {
          break;
        }
        if (typeof type.defaultValue === 'function') {
          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
            break;
          }
          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
            break;
          }
        } else if (!isBeforeSetters) {
          continue;
        }
        if (pathsToSkip && pathsToSkip[curPath]) {
          break;
        }
        if (fields && exclude !== null) {
          if (exclude === true) {
            if (p in fields) {
              continue;
            }
            def = type.getDefault(doc, false);
            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            }
          } else if (included) {
            def = type.getDefault(doc, false);
            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            }
          }
        } else {
          def = type.getDefault(doc, false);
          if (typeof def !== 'undefined') {
            doc_[piece] = def;
            doc.$__.activePaths.default(p);
          }
        }
      } else {
        doc_ = doc_[piece];
      }
    }
  }
}
Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};
  const paths = Object.keys(this.schema.paths).
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;
  for (; ii < plen; ++ii) {
    const p = paths[ii];
    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }
    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;
    for (let i = 0; i < len; ++i) {
      const piece = path[i];
      curPath += (!curPath.length ? '' : '.') + piece;
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }
      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }
  this._doc = doc;
};
Document.prototype.toBSON = function() {
  return this.toObject(internalToObjectOptions);
};
Document.prototype.init = function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }
  this.$__init(doc, opts);
  if (fn) {
    fn(null, this);
  }
  return this;
};
Document.prototype.$__init = function(doc, opts) {
  this.isNew = false;
  this.$init = true;
  if (doc._id !== null && doc._id !== undefined &&
    opts && opts.populated && opts.populated.length) {
    const id = String(doc._id);
    for (let i = 0; i < opts.populated.length; ++i) {
      const item = opts.populated[i];
      if (item.isVirtual) {
        this.populated(item.path, utils.getValue(item.path, doc), item);
      } else {
        this.populated(item.path, item._docs[id], item);
      }
    }
  }
  init(this, doc, this._doc);
  this.emit('init', this);
  this.constructor.emit('init', this);
  this.$__._id = this._id;
  return this;
};
function init(self, obj, doc, prefix) {
  prefix = prefix || '';
  const keys = Object.keys(obj);
  const len = keys.length;
  let schema;
  let path;
  let i;
  let index = 0;
  while (index < len) {
    _init(index++);
  }
  function _init(index) {
    i = keys[index];
    path = prefix + i;
    schema = self.schema.path(path);
    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {
      return;
    }
    if (!schema && utils.isPOJO(obj[i])) {
      if (!doc[i]) {
        doc[i] = {};
      }
      init(self, obj[i], doc[i], path + '.');
    } else if (!schema) {
      doc[i] = obj[i];
    } else {
      if (obj[i] === null) {
        doc[i] = null;
      } else if (obj[i] !== undefined) {
        const intCache = obj[i].$__ || {};
        const wasPopulated = intCache.wasPopulated || null;
        if (schema && !wasPopulated) {
          try {
            doc[i] = schema.cast(obj[i], self, true);
          } catch (e) {
            self.invalidate(e.path, new ValidatorError({
              path: e.path,
              message: e.message,
              type: 'cast',
              value: e.value
            }));
          }
        } else {
          doc[i] = obj[i];
        }
      }
      if (!self.isModified(path)) {
        self.$__.activePaths.init(path);
      }
    }
  }
}
Document.prototype.update = function update() {
  const args = utils.args(arguments);
  args.unshift({_id: this._id});
  const query = this.constructor.update.apply(this.constructor, args);
  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }
  return query;
};
Document.prototype.updateOne = function updateOne(doc, options, callback) {
  const query = this.constructor.updateOne({_id: this._id}, doc, options);
  query._pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [], cb);
  });
  query._post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [], {}, cb);
  });
  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }
  if (callback != null) {
    return query.exec(callback);
  }
  return query;
};
Document.prototype.replaceOne = function replaceOne() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  return this.constructor.replaceOne.apply(this.constructor, args);
};
Document.prototype.$session = function $session(session) {
  if (arguments.length === 0) {
    return this.$__.session;
  }
  this.$__.session = session;
  if (!this.ownerDocument) {
    const subdocs = this.$__getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }
  return session;
};
Document.prototype.overwrite = function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }
  return this;
};
Document.prototype.$set = function $set(path, val, type, options) {
  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }
  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;
  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;
  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }
  if (typeof path !== 'string') {
    if (path === null || path === void 0) {
      const _ = path;
      path = val;
      val = _;
    } else {
      prefix = val ? val + '.' : '';
      if (path instanceof Document) {
        if (path.$__isNested) {
          path = path.toObject();
        } else {
          path = path._doc;
        }
      }
      keys = Object.keys(path);
      const len = keys.length;
      if (len === 0 && !this.schema.options.minimize) {
        if (val) {
          this.$set(val, {});
        }
        return this;
      }
      while (i < len) {
        _handleIndex.call(this, i++);
      }
      return this;
    }
  } else {
    this.$__.$setCalled.add(path);
  }
  function _handleIndex(i) {
    key = keys[i];
    const pathName = prefix + key;
    pathtype = this.schema.pathType(pathName);
    if (type === true &&
        !prefix &&
        path[key] != null &&
        pathtype === 'nested' &&
        this._doc[key] != null &&
        Object.keys(this._doc[key]).length === 0) {
      delete this._doc[key];
    }
    if (typeof path[key] === 'object' &&
        !utils.isNativeObject(path[key]) &&
        path[key] != null &&
        pathtype !== 'virtual' &&
        pathtype !== 'real' &&
        !(this.$__path(pathName) instanceof MixedSchema) &&
        !(this.schema.paths[pathName] &&
        this.schema.paths[pathName].options &&
        this.schema.paths[pathName].options.ref)) {
      this.$__.$setCalled.add(prefix + key);
      this.$set(path[key], prefix + key, constructing);
    } else if (strict) {
      if (constructing && path[key] === void 0 &&
          this.get(key) !== void 0) {
        return;
      }
      if (pathtype === 'adhocOrUndefined') {
        pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
      }
      if (pathtype === 'real' || pathtype === 'virtual') {
        let p = path[key];
        if (this.schema.paths[pathName] &&
            this.schema.paths[pathName].$isSingleNested &&
            path[key] instanceof Document) {
          p = p.toObject({ virtuals: false, transform: false });
        }
        this.$set(prefix + key, p, constructing);
      } else if (pathtype === 'nested' && path[key] instanceof Document) {
        this.$set(prefix + key,
          path[key].toObject({transform: false}), constructing);
      } else if (strict === 'throw') {
        if (pathtype === 'nested') {
          throw new ObjectExpectedError(key, path[key]);
        } else {
          throw new StrictModeError(key);
        }
      }
    } else if (path[key] !== void 0) {
      this.$set(prefix + key, path[key], constructing);
    }
  }
  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }
  if (utils.isPOJO(val) && val.$__ != null && val._doc != null) {
    val = val._doc;
  }
  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }
      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }
      this.markModified(path);
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }
  let schema;
  const parts = path.split('.');
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }
  if (pathType === 'adhocOrUndefined' && strict) {
    let mixed;
    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }
      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }
      if (schema instanceof MixedSchema) {
        mixed = true;
        break;
      }
    }
    if (schema == null) {
      schema = getEmbeddedDiscriminatorPath(this, path);
    }
    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      if (!this.isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }
  let pathToMark;
  if (parts.length <= 1) {
    pathToMark = path;
  } else {
    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');
      if (this.get(subpath) === null) {
        pathToMark = subpath;
        break;
      }
    }
    if (!pathToMark) {
      pathToMark = path;
    }
  }
  const priorVal = (() => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();
  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }
  let shouldSet = true;
  try {
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      if (modelName === model.modelName || modelName === model.baseModelName) {
        return true;
      }
      return false;
    })();
    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      if (this.ownerDocument) {
        this.ownerDocument().populated(this.$__fullPath(path),
          val._id, { [populateModelSymbol]: val.constructor });
      } else {
        this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      }
      didPopulate = true;
    }
    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] instanceof Document &&
        val[0].constructor.modelName &&
        (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      didPopulate = true;
    }
    if (this.schema.singleNestedPaths[path] == null) {
      val = schema.applySetters(val, this, false, priorVal);
    }
    if (!didPopulate && this.$__.populated) {
      delete this.$__.populated[path];
    }
    this.$markValid(path);
  } catch (e) {
    this.invalidate(path,
      new MongooseError.CastError(schema.instance, val, path, e));
    shouldSet = false;
  }
  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
  }
  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }
  return this;
};
Document.prototype.set = Document.prototype.$set;
Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }
  if (this.schema.singleNestedPaths[path] != null) {
    return false;
  }
  if (val === void 0 && !this.isSelected(path)) {
    return true;
  }
  if (val === void 0 && path in this.$__.activePaths.states.default) {
    return false;
  }
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }
  if (!deepEqual(val, priorVal || this.get(path))) {
    return true;
  }
  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) {
    return true;
  }
  return false;
};
Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');
  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;
  if (shouldModify) {
    this.markModified(pathToMark);
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);
      if (val.isMongooseDocumentArray) {
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
        }
      });
    }
  }
  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';
  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }
    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
      } else {
        obj[parts[i]] = val;
      }
    } else {
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
      }
    }
  }
};
Document.prototype.$__getValue = function(path) {
  return utils.getValue(path, this._doc);
};
Document.prototype.$__setValue = function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
};
Document.prototype.get = function(path, type, options) {
  let adhoc;
  options = options || {};
  if (type) {
    adhoc = this.schema.interpretAsType(path, type, this.schema.options);
  }
  const schema = this.$__path(path) || this.schema.virtualpath(path);
  const pieces = path.split('.');
  let obj = this._doc;
  if (schema instanceof VirtualType) {
    if (schema.getters.length === 0) {
      return void 0;
    }
    return schema.applyGetters(null, this);
  }
  if (typeof this.schema.aliases[pieces[0]] == 'string') {
    pieces[0] = this.schema.aliases[pieces[0]];
  }
  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }
    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i]);
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }
  if (adhoc) {
    obj = adhoc.cast(obj);
  }
  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.schema.nested[path] && options.virtuals) {
    return applyGetters(this, utils.clone(obj) || {}, 'virtuals', { path: path });
  }
  return obj;
};
Document.prototype[getSymbol] = Document.prototype.get;
Document.prototype.$__path = function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
  if (adhocType) {
    return adhocType;
  }
  return this.schema.path(path);
};
Document.prototype.markModified = function(path, scope) {
  this.$__.activePaths.modify(path);
  if (scope != null && !this.ownerDocument) {
    this.$__.pathsToScopes[path] = scope;
  }
};
Document.prototype.unmarkModified = function(path) {
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
};
Document.prototype.$ignore = function(path) {
  this.$__.activePaths.ignore(path);
};
Document.prototype.directModifiedPaths = function() {
  return Object.keys(this.$__.activePaths.states.modify);
};
Document.prototype.$isEmpty = function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };
  if (arguments.length > 0) {
    const v = this.get(path);
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }
  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
};
function _isEmpty(v) {
  if (v == null) {
    return true;
  }
  if (typeof v !== 'object' || Array.isArray(v)) {
    return false;
  }
  for (const key of Object.keys(v)) {
    if (!_isEmpty(v[key])) {
      return false;
    }
  }
  return true;
}
Document.prototype.modifiedPaths = function(options) {
  options = options || {};
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));
    if (!options.includeChildren) {
      return list;
    }
    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
              }
            }
          }
        }
      } else {
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }
    return list;
  }, []);
};
Document.prototype.isModified = function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this.modifiedPaths();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });
    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }
  return this.$__.activePaths.some('modify');
};
Document.prototype.$isDefault = function(path) {
  return (path in this.$__.activePaths.states.default);
};
Document.prototype.$isDeleted = function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }
  this.$__.isDeleted = !!val;
  return this;
};
Document.prototype.isDirectModified = function(path) {
  return (path in this.$__.activePaths.states.modify);
};
Document.prototype.isInit = function(path) {
  return (path in this.$__.activePaths.states.init);
};
Document.prototype.isSelected = function isSelected(path) {
  if (this.$__.selected) {
    if (path === '_id') {
      return this.$__.selected._id !== 0;
    }
    const paths = Object.keys(this.$__.selected);
    let i = paths.length;
    let inclusive = null;
    let cur;
    if (i === 1 && paths[0] === '_id') {
      return this.$__.selected._id === 0;
    }
    while (i--) {
      cur = paths[i];
      if (cur === '_id') {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (path in this.$__.selected) {
      return inclusive;
    }
    i = paths.length;
    const pathDot = path + '.';
    while (i--) {
      cur = paths[i];
      if (cur === '_id') {
        continue;
      }
      if (cur.startsWith(pathDot)) {
        return inclusive || cur !== pathDot;
      }
      if (pathDot.startsWith(cur + '.')) {
        return inclusive;
      }
    }
    return !inclusive;
  }
  return true;
};
Document.prototype.isDirectSelected = function isDirectSelected(path) {
  if (this.$__.selected) {
    if (path === '_id') {
      return this.$__.selected._id !== 0;
    }
    const paths = Object.keys(this.$__.selected);
    let i = paths.length;
    let inclusive = null;
    let cur;
    if (i === 1 && paths[0] === '_id') {
      return this.$__.selected._id === 0;
    }
    while (i--) {
      cur = paths[i];
      if (cur === '_id') {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (path in this.$__.selected) {
      return inclusive;
    }
    return !inclusive;
  }
  return true;
};
Document.prototype.validate = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  return utils.promiseOrCallback(callback, cb => this.$__validate(options, function(error) {
    cb(error);
  }), this.constructor.events);
};
function _evaluateRequiredFunctions(doc) {
  Object.keys(doc.$__.activePaths.states.require).forEach(path => {
    const p = doc.schema.path(path);
    if (p != null && typeof p.originalRequiredValue === 'function') {
      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc);
    }
  });
}
function _getPathsToValidate(doc) {
  let i;
  let len;
  const skipSchemaValidators = {};
  _evaluateRequiredFunctions(doc);
  let paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {
    if (!doc.isSelected(path) && !doc.isModified(path)) {
      return false;
    }
    if (path in doc.$__.cachedRequired) {
      return doc.$__.cachedRequired[path];
    }
    return true;
  });
  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));
  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));
  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));
  if (!doc.ownerDocument) {
    const subdocs = doc.$__getAllSubdocs();
    let subdoc;
    len = subdocs.length;
    const modifiedPaths = doc.modifiedPaths();
    for (i = 0; i < len; ++i) {
      subdoc = subdocs[i];
      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&
          !doc.isDirectModified(subdoc.$basePath) &&
          !doc.$isDefault(subdoc.$basePath)) {
        paths = paths.filter(function(p) {
          return p != null && p.indexOf(subdoc.$basePath + '.') !== 0;
        });
        paths.push(subdoc.$basePath);
        skipSchemaValidators[subdoc.$basePath] = true;
      }
    }
  }
  len = paths.length;
  for (i = 0; i < len; ++i) {
    const path = paths[i];
    const _pathType = doc.schema.path(path);
    if (!_pathType ||
        !_pathType.$isMongooseArray ||
        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {
      continue;
    }
    const val = doc.$__getValue(path);
    if (val) {
      const numElements = val.length;
      for (let j = 0; j < numElements; ++j) {
        paths.push(path + '.' + j);
      }
    }
  }
  const flattenOptions = { skipArrays: true };
  len = paths.length;
  for (i = 0; i < len; ++i) {
    const pathToCheck = paths[i];
    if (doc.schema.nested[pathToCheck]) {
      let _v = doc.$__getValue(pathToCheck);
      if (isMongooseObject(_v)) {
        _v = _v.toObject({ transform: false });
      }
      const flat = flatten(_v, '', flattenOptions);
      const _subpaths = Object.keys(flat).map(function(p) {
        return pathToCheck + '.' + p;
      });
      paths = paths.concat(_subpaths);
    }
  }
  len = paths.length;
  for (i = 0; i < len; ++i) {
    const path = paths[i];
    const _pathType = doc.schema.path(path);
    if (!_pathType || !_pathType.$isSchemaMap) {
      continue;
    }
    const val = doc.$__getValue(path);
    if (val == null) {
      continue;
    }
    for (const key of val.keys()) {
      paths.push(path + '.' + key);
    }
  }
  return [paths, skipSchemaValidators];
}
Document.prototype.$__validate = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);
  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }
  const _this = this;
  const _complete = () => {
    const err = this.$__.validationError;
    this.$__.validationError = undefined;
    this.$__.cachedRequired = {};
    this.emit('validate', _this);
    this.constructor.emit('validate', _this);
    if (err) {
      for (const key in err.errors) {
        if (!this[documentArrayParent] && err.errors[key] instanceof MongooseError.CastError) {
          this.invalidate(key, err.errors[key]);
        }
      }
      return err;
    }
  };
  const pathDetails = _getPathsToValidate(this);
  const paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (paths.length === 0) {
    return process.nextTick(function() {
      const error = _complete();
      if (error) {
        return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {
          callback(error);
        });
      }
      callback(null, _this);
    });
  }
  const validated = {};
  let total = 0;
  const complete = function() {
    const error = _complete();
    if (error) {
      return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {
        callback(error);
      });
    }
    callback(null, _this);
  };
  const validatePath = function(path) {
    if (path == null || validated[path]) {
      return;
    }
    validated[path] = true;
    total++;
    process.nextTick(function() {
      const p = _this.schema.path(path);
      if (!p) {
        return --total || complete();
      }
      if (!_this.$isValid(path)) {
        --total || complete();
        return;
      }
      const val = _this.$__getValue(path);
      const scope = path in _this.$__.pathsToScopes ?
        _this.$__.pathsToScopes[path] :
        _this;
      p.doValidate(val, function(err) {
        if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
          if (p.$isSingleNested &&
              err.name === 'ValidationError' &&
              p.schema.options.storeSubdocValidationError === false) {
            return --total || complete();
          }
          _this.invalidate(path, err, undefined, true);
        }
        --total || complete();
      }, scope, { skipSchemaValidators: skipSchemaValidators[path], path: path });
    });
  };
  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) {
    validatePath(paths[i]);
  }
};
Document.prototype.validateSync = function(pathsToValidate, options) {
  const _this = this;
  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);
  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }
  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (pathsToValidate && pathsToValidate.length) {
    const tmp = [];
    for (let i = 0; i < paths.length; ++i) {
      if (pathsToValidate.indexOf(paths[i]) !== -1) {
        tmp.push(paths[i]);
      }
    }
    paths = tmp;
  }
  const validating = {};
  paths.forEach(function(path) {
    if (validating[path]) {
      return;
    }
    validating[path] = true;
    const p = _this.schema.path(path);
    if (!p) {
      return;
    }
    if (!_this.$isValid(path)) {
      return;
    }
    const val = _this.$__getValue(path);
    const err = p.doValidateSync(val, _this, {
      skipSchemaValidators: skipSchemaValidators[path],
      path: path
    });
    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
      if (p.$isSingleNested &&
          err.name === 'ValidationError' &&
          p.schema.options.storeSubdocValidationError === false) {
        return;
      }
      _this.invalidate(path, err, undefined, true);
    }
  });
  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
  _this.constructor.emit('validate', _this);
  if (err) {
    for (const key in err.errors) {
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }
  return err;
};
Document.prototype.invalidate = function(path, err, val, kind) {
  if (!this.$__.validationError) {
    this.$__.validationError = new ValidationError(this);
  }
  if (this.$__.validationError.errors[path]) {
    return;
  }
  if (!err || typeof err === 'string') {
    err = new ValidatorError({
      path: path,
      message: err,
      type: kind || 'user defined',
      value: val
    });
  }
  if (this.$__.validationError === err) {
    return this.$__.validationError;
  }
  this.$__.validationError.addError(path, err);
  return this.$__.validationError;
};
Document.prototype.$markValid = function(path) {
  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
    return;
  }
  delete this.$__.validationError.errors[path];
  if (Object.keys(this.$__.validationError.errors).length === 0) {
    this.$__.validationError = null;
  }
};
Document.prototype.$isValid = function(path) {
  return !this.$__.validationError || !this.$__.validationError.errors[path];
};
Document.prototype.$__reset = function reset() {
  let _this = this;
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  this.$__.activePaths
    .map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    })
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    })
    .forEach(function(array) {
      let i = array.length;
      while (i--) {
        const doc = array[i];
        if (!doc) {
          continue;
        }
        doc.$__reset();
      }
      _this.$__.activePaths.init(array.$path());
      array[arrayAtomicsSymbol] = {};
    });
  this.$__.activePaths.
    map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    }).
    filter(function(val) {
      return val && val.$isSingleNested;
    }).
    forEach(function(doc) {
      doc.$__reset();
      _this.$__.activePaths.init(doc.$basePath);
    });
  this.$__dirty().forEach(function(dirt) {
    const type = dirt.value;
    if (type && type[arrayAtomicsSymbol]) {
      type[arrayAtomicsSymbol] = {};
    }
  });
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
  this.errors = undefined;
  _this = this;
  this.schema.requiredPaths().forEach(function(path) {
    _this.$__.activePaths.require(path);
  });
  return this;
};
Document.prototype.$__dirty = function() {
  const _this = this;
  let all = this.$__.activePaths.map('modify', function(path) {
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  });
  all = all.concat(this.$__.activePaths.map('default', function(path) {
    if (path === '_id' || _this.$__getValue(path) == null) {
      return;
    }
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  }));
  all.sort(function(a, b) {
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  });
  const minimal = [];
  let lastPath;
  let top;
  all.forEach(function(item) {
    if (!item) {
      return;
    }
    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    } else if (top != null &&
        top.value != null &&
        top.value[arrayAtomicsSymbol] != null &&
        top.value.hasAtomics()) {
      top.value[arrayAtomicsSymbol] = {};
      top.value[arrayAtomicsSymbol].$set = top.value;
    }
  });
  top = lastPath = null;
  return minimal;
};
Document.prototype.$__setSchema = function(schema) {
  schema.plugin(idGetter, { deduplicate: true });
  compile(schema.tree, this, undefined, schema.options);
  for (const key of Object.keys(schema.virtuals)) {
    schema.virtuals[key]._applyDefaultGetters();
  }
  this.schema = schema;
  this[documentSchemaSymbol] = schema;
};
Document.prototype.$__getArrayPathsToValidate = function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  return this.$__.activePaths
    .map('init', 'modify', function(i) {
      return this.$__getValue(i);
    }.bind(this))
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, [])
    .filter(function(doc) {
      return doc;
    });
};
Document.prototype.$__getAllSubdocs = function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');
  function docReducer(doc, seed, path) {
    let val = doc;
    if (path) {
      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
        val = doc._doc[path];
      } else {
        val = doc[path];
      }
    }
    if (val instanceof Embedded) {
      seed.push(val);
    } else if (val instanceof Map) {
      seed = Array.from(val.keys()).reduce(function(seed, path) {
        return docReducer(val.get(path), seed, null);
      }, seed);
    } else if (val && val.$isSingleNested) {
      seed = Object.keys(val._doc).reduce(function(seed, path) {
        return docReducer(val._doc, seed, path);
      }, seed);
      seed.push(val);
    } else if (val && val.isMongooseDocumentArray) {
      val.forEach(function _docReduce(doc) {
        if (!doc || !doc._doc) {
          return;
        }
        if (doc instanceof Embedded) {
          seed.push(doc);
        }
        seed = Object.keys(doc._doc).reduce(function(seed, path) {
          return docReducer(doc._doc, seed, path);
        }, seed);
      });
    } else if (val instanceof Document && val.$__isNested) {
      seed = Object.keys(val).reduce(function(seed, path) {
        return docReducer(val, seed, path);
      }, seed);
    }
    return seed;
  }
  const _this = this;
  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {
    return docReducer(_this, seed, path);
  }, []);
  return subDocs;
};
function applyQueue(doc) {
  const q = doc.schema && doc.schema.callQueue;
  if (!q.length) {
    return;
  }
  let pair;
  for (let i = 0; i < q.length; ++i) {
    pair = q[i];
    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
      doc[pair[0]].apply(doc, pair[1]);
    }
  }
}
Document.prototype.$__handleReject = function handleReject(err) {
  if (this.listeners('error').length) {
    this.emit('error', err);
  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
    this.constructor.emit('error', err);
  } else if (this.listeners && this.listeners('error').length) {
    this.emit('error', err);
  }
};
Document.prototype.$toObject = function(options, json) {
  let defaultOptions = {
    transform: true,
    flattenDecimals: true
  };
  const path = json ? 'toJSON' : 'toObject';
  const baseOptions = get(this, 'constructor.base.options.' + path, {});
  const schemaOptions = get(this, 'schema.options', {});
  defaultOptions = utils.options(defaultOptions, clone(baseOptions));
  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));
  options = utils.isPOJO(options) ? clone(options) : {};
  if (!('flattenMaps' in options)) {
    options.flattenMaps = defaultOptions.flattenMaps;
  }
  let _minimize;
  if (options.minimize != null) {
    _minimize = options.minimize;
  } else if (defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = schemaOptions.minimize;
  }
  const cloneOptions = Object.assign(utils.clone(options), {
    _isNested: true,
    json: json,
    minimize: _minimize
  });
  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    return clone(this._id, cloneOptions);
  }
  options = utils.options(defaultOptions, options);
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;
  cloneOptions._parentOptions = options;
  const originalTransform = options.transform;
  let ret = clone(this._doc, cloneOptions) || {};
  if (options.getters) {
    applyGetters(this, ret, 'paths', cloneOptions);
    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }
  if (options.virtuals || options.getters && options.virtuals !== false) {
    applyGetters(this, ret, 'virtuals', cloneOptions);
  }
  if (options.versionKey === false && this.schema.options.versionKey) {
    delete ret[this.schema.options.versionKey];
  }
  let transform = options.transform;
  if (transform === true || (schemaOptions.toObject && transform)) {
    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;
    if (opts) {
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    }
  } else {
    options.transform = originalTransform;
  }
  if (typeof transform === 'function') {
    const xformed = transform(this, ret, options);
    if (typeof xformed !== 'undefined') {
      ret = xformed;
    }
  }
  return ret;
};
Document.prototype.toObject = function(options) {
  return this.$toObject(options);
};
function minimize(obj) {
  const keys = Object.keys(obj);
  let i = keys.length;
  let hasKeys;
  let key;
  let val;
  while (i--) {
    key = keys[i];
    val = obj[key];
    if (utils.isObject(val) && !Buffer.isBuffer(val)) {
      obj[key] = minimize(val);
    }
    if (undefined === obj[key]) {
      delete obj[key];
      continue;
    }
    hasKeys = true;
  }
  return hasKeys
    ? obj
    : undefined;
}
function applyGetters(self, json, type, options) {
  const schema = self.schema;
  const paths = Object.keys(schema[type]);
  let i = paths.length;
  const numPaths = i;
  let path;
  let assignPath;
  let cur = self._doc;
  let v;
  if (!cur) {
    return json;
  }
  if (type === 'virtuals') {
    options = options || {};
    for (i = 0; i < numPaths; ++i) {
      path = paths[i];
      assignPath = path;
      if (options.path != null) {
        if (!path.startsWith(options.path + '.')) {
          continue;
        }
        assignPath = path.substr(options.path.length + 1);
      }
      const parts = assignPath.split('.');
      v = clone(self.get(path), options);
      if (v === void 0) {
        continue;
      }
      const plen = parts.length;
      cur = json;
      for (let j = 0; j < plen - 1; ++j) {
        cur[parts[j]] = cur[parts[j]] || {};
        cur = cur[parts[j]];
      }
      cur[parts[plen - 1]] = v;
    }
    return json;
  }
  while (i--) {
    path = paths[i];
    const parts = path.split('.');
    const plen = parts.length;
    const last = plen - 1;
    let branch = json;
    let part;
    cur = self._doc;
    for (let ii = 0; ii < plen; ++ii) {
      part = parts[ii];
      v = cur[part];
      if (ii === last) {
        const val = self.get(path);
        if (val != null && val.$__ == null) {
          branch[part] = clone(val, options);
        }
      } else if (v == null) {
        if (part in cur) {
          branch[part] = v;
        }
        break;
      } else {
        branch = branch[part] || (branch[part] = {});
      }
      cur = v;
    }
  }
  return json;
}
Document.prototype.toJSON = function(options) {
  return this.$toObject(options, true);
};
Document.prototype.inspect = function(options) {
  const isPOJO = utils.isPOJO(options);
  let opts;
  if (isPOJO) {
    opts = options;
    opts.minimize = false;
  }
  return this.toObject(opts);
};
if (inspect.custom) {
  Document.prototype[inspect.custom] = Document.prototype.inspect;
}
Document.prototype.toString = function() {
  return inspect(this.inspect());
};
Document.prototype.equals = function(doc) {
  if (!doc) {
    return false;
  }
  const tid = this.get('_id');
  const docid = doc.get ? doc.get('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
};
Document.prototype.populate = function populate() {
  if (arguments.length === 0) {
    return this;
  }
  const pop = this.$__.populate || (this.$__.populate = {});
  const args = utils.args(arguments);
  let fn;
  if (typeof args[args.length - 1] === 'function') {
    fn = args.pop();
  }
  if (args.length) {
    const res = utils.populate.apply(null, args);
    for (let i = 0; i < res.length; ++i) {
      pop[res[i].path] = res[i];
    }
  }
  if (fn) {
    const paths = utils.object.vals(pop);
    this.$__.populate = undefined;
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
      topLevelModel = this.$__.scope.constructor;
      const nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) {
        populateOptions.path = nestedPath + '.' + populateOptions.path;
      });
    }
    if (this.$session() != null) {
      const session = this.$session();
      paths.forEach(path => {
        if (path.options == null) {
          path.options = { session: session };
          return;
        }
        if (!('session' in path.options)) {
          path.options.session = session;
        }
      });
    }
    topLevelModel.populate(this, paths, fn);
  }
  return this;
};
Document.prototype.execPopulate = function(callback) {
  return utils.promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
};
Document.prototype.populated = function(path, val, options) {
  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    const v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }
  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }
  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = {value: val, options: options};
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
      break;
    }
  }
  return val;
};
Document.prototype.depopulate = function(path) {
  if (typeof path === 'string') {
    path = path.split(' ');
  }
  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
  const populated = get(this, '$__.populated', {});
  if (arguments.length === 0) {
    for (let i = 0; i < virtualKeys.length; i++) {
      delete this.$$populatedVirtuals[virtualKeys[i]];
      delete this._doc[virtualKeys[i]];
      delete populated[virtualKeys[i]];
    }
    const keys = Object.keys(populated);
    for (let i = 0; i < keys.length; i++) {
      populatedIds = this.populated(keys[i]);
      if (!populatedIds) {
        continue;
      }
      delete populated[keys[i]];
      this.$set(keys[i], populatedIds);
    }
    return this;
  }
  for (let i = 0; i < path.length; i++) {
    populatedIds = this.populated(path[i]);
    delete populated[path[i]];
    if (virtualKeys.indexOf(path[i]) !== -1) {
      delete this.$$populatedVirtuals[path[i]];
      delete this._doc[path[i]];
    } else if (populatedIds) {
      this.$set(path[i], populatedIds);
    }
  }
  return this;
};
Document.prototype.$__fullPath = function(path) {
  return path || '';
};
Document.ValidationError = ValidationError;
module.exports = exports = Document;
