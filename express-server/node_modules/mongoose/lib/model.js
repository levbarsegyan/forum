'use strict';
const Aggregate = require('./aggregate');
const ChangeStream = require('./cursor/ChangeStream');
const Document = require('./document');
const DocumentNotFoundError = require('./error').DocumentNotFoundError;
const DivergentArrayError = require('./error').DivergentArrayError;
const Error = require('./error');
const EventEmitter = require('events').EventEmitter;
const MongooseBuffer = require('./types/buffer');
const OverwriteModelError = require('./error').OverwriteModelError;
const PromiseProvider = require('./promise_provider');
const Query = require('./query');
const RemoveOptions = require('./options/removeOptions');
const SaveOptions = require('./options/saveOptions');
const Schema = require('./schema');
const VersionError = require('./error').VersionError;
const ParallelSaveError = require('./error').ParallelSaveError;
const applyQueryMiddleware = require('./helpers/query/applyQueryMiddleware');
const applyHooks = require('./helpers/model/applyHooks');
const applyMethods = require('./helpers/model/applyMethods');
const applyStaticHooks = require('./helpers/model/applyStaticHooks');
const applyStatics = require('./helpers/model/applyStatics');
const applyWriteConcern = require('./helpers/schema/applyWriteConcern');
const assignVals = require('./helpers/populate/assignVals');
const castBulkWrite = require('./helpers/model/castBulkWrite');
const discriminator = require('./helpers/model/discriminator');
const getDiscriminatorByValue = require('./queryhelpers').getDiscriminatorByValue;
const immediate = require('./helpers/immediate');
const internalToObjectOptions = require('./options').internalToObjectOptions;
const isPathExcluded = require('./helpers/projection/isPathExcluded');
const isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');
const get = require('./helpers/get');
const getSchemaTypes = require('./helpers/populate/getSchemaTypes');
const getVirtual = require('./helpers/populate/getVirtual');
const leanPopulateMap = require('./helpers/populate/leanPopulateMap');
const modifiedPaths = require('./helpers/update/modifiedPaths');
const normalizeRefPath = require('./helpers/populate/normalizeRefPath');
const parallel = require('async/parallel');
const parallelLimit = require('async/parallelLimit');
const util = require('util');
const utils = require('./utils');
const VERSION_WHERE = 1;
const VERSION_INC = 2;
const VERSION_ALL = VERSION_WHERE | VERSION_INC;
const arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;
const modelCollectionSymbol = Symbol.for('mongoose#Model#collection');
const modelSymbol = require('./helpers/symbols').modelSymbol;
const populateModelSymbol = require('./helpers/symbols').populateModelSymbol;
const schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;
const subclassedSymbol = Symbol('mongoose#Model#subclassed');
function Model(doc, fields, skipId) {
  if (fields instanceof Schema) {
    throw new TypeError('2nd argument to `Model` must be a POJO or string, ' +
      '**not** a schema. Make sure you\'re calling `mongoose.model()`, not ' +
      '`mongoose.Model()`.');
  }
  Document.call(this, doc, fields, skipId);
}
Model.prototype.__proto__ = Document.prototype;
Model.prototype.$isMongooseModelPrototype = true;
Model.prototype.db;
Model.prototype.collection;
Model.prototype.modelName;
Model.prototype.$where;
Model.prototype.baseModelName;
Model.events;
Model._middleware;
function _applyCustomWhere(doc, where) {
  if (doc.$where == null) {
    return;
  }
  const keys = Object.keys(doc.$where);
  const len = keys.length;
  for (let i = 0; i < len; ++i) {
    where[keys[i]] = doc.$where[keys[i]];
  }
}
Model.prototype.$__handleSave = function(options, callback) {
  const _this = this;
  let saveOptions = {};
  if ('safe' in options) {
    _handleSafe(options);
  }
  applyWriteConcern(this.schema, options);
  if ('w' in options) {
    saveOptions.w = options.w;
  }
  if ('j' in options) {
    saveOptions.j = options.j;
  }
  if ('wtimeout' in options) {
    saveOptions.wtimeout = options.wtimeout;
  }
  if ('checkKeys' in options) {
    saveOptions.checkKeys = options.checkKeys;
  }
  const session = this.$session();
  if (!saveOptions.hasOwnProperty('session')) {
    saveOptions.session = session;
  }
  if (Object.keys(saveOptions).length === 0) {
    saveOptions = null;
  }
  if (this.isNew) {
    const obj = this.toObject(internalToObjectOptions);
    if ((obj || {})._id === void 0) {
      setTimeout(function() {
        callback(new Error('document must have an _id before saving'));
      }, 0);
      return;
    }
    this.$__version(true, obj);
    this[modelCollectionSymbol].insertOne(obj, saveOptions, function(err, ret) {
      if (err) {
        _this.isNew = true;
        _this.emit('isNew', true);
        _this.constructor.emit('isNew', true);
        callback(err, null);
        return;
      }
      callback(null, ret);
    });
    this.$__reset();
    this.isNew = false;
    this.emit('isNew', false);
    this.constructor.emit('isNew', false);
    this.$__.inserting = true;
  } else {
    this.$__.inserting = false;
    const delta = this.$__delta();
    if (delta) {
      if (delta instanceof Error) {
        callback(delta);
        return;
      }
      const where = this.$__where(delta[0]);
      if (where instanceof Error) {
        callback(where);
        return;
      }
      _applyCustomWhere(this, where);
      this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, function(err, ret) {
        if (err) {
          callback(err);
          return;
        }
        ret.$where = where;
        callback(null, ret);
      });
    } else {
      this.$__reset();
      callback();
      return;
    }
    this.emit('isNew', false);
    this.constructor.emit('isNew', false);
  }
};
Model.prototype.$__save = function(options, callback) {
  this.$__handleSave(options, (error, result) => {
    const hooks = this.schema.s.hooks;
    if (error) {
      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {
        callback(error, this);
      });
    }
    const modifiedPaths = this.modifiedPaths();
    this.$__reset();
    let numAffected = 0;
    if (get(options, 'safe.w') !== 0 && get(options, 'w') !== 0) {
      if (result) {
        if (Array.isArray(result)) {
          numAffected = result.length;
        } else if (result.result && result.result.n !== undefined) {
          numAffected = result.result.n;
        } else if (result.result && result.result.nModified !== undefined) {
          numAffected = result.result.nModified;
        } else {
          numAffected = result;
        }
      }
      if (this.$__.version && !this.$__.inserting) {
        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
        this.$__.version = undefined;
        const key = this.schema.options.versionKey;
        const version = this.$__getValue(key) || 0;
        if (numAffected <= 0) {
          const err = this.$__.$versionError ||
            new VersionError(this, version, modifiedPaths);
          return callback(err);
        }
        if (doIncrement) {
          this.$__setValue(key, version + 1);
        }
      }
      if (result != null && numAffected <= 0) {
        error = new DocumentNotFoundError(result.$where,
          this.constructor.modelName, numAffected, result);
        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {
          callback(error, this);
        });
      }
    }
    this.$__.saving = undefined;
    this.emit('save', this, numAffected);
    this.constructor.emit('save', this, numAffected);
    callback(null, this);
  });
};
function generateVersionError(doc, modifiedPaths) {
  const key = doc.schema.options.versionKey;
  if (!key) {
    return null;
  }
  const version = doc.$__getValue(key) || 0;
  return new VersionError(doc, version, modifiedPaths);
}
Model.prototype.save = function(options, fn) {
  let parallelSave;
  if (this.$__.saving) {
    parallelSave = new ParallelSaveError(this);
  } else {
    this.$__.saving = new ParallelSaveError(this);
  }
  if (typeof options === 'function') {
    fn = options;
    options = undefined;
  }
  if (fn) {
    fn = this.constructor.$wrapCallback(fn);
  }
  options = new SaveOptions(options);
  if (options.hasOwnProperty('session')) {
    this.$session(options.session);
  }
  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
  return utils.promiseOrCallback(fn, cb => {
    if (parallelSave) {
      this.$__handleReject(parallelSave);
      return cb(parallelSave);
    }
    this.$__.saveOptions = options;
    this.$__save(options, error => {
      this.$__.saving = undefined;
      delete this.$__.saveOptions;
      if (error) {
        this.$__handleReject(error);
        return cb(error);
      }
      cb(null, this);
    });
  }, this.constructor.events);
};
function shouldSkipVersioning(self, path) {
  const skipVersioning = self.schema.options.skipVersioning;
  if (!skipVersioning) return false;
  path = path.replace(/\.\d+\./, '.');
  return skipVersioning[path];
}
function operand(self, where, delta, data, val, op) {
  op || (op = '$set');
  if (!delta[op]) delta[op] = {};
  delta[op][data.path] = val;
  if (self.schema.options.versionKey === false) return;
  if (shouldSkipVersioning(self, data.path)) return;
  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;
  switch (op) {
    case '$set':
    case '$unset':
    case '$pop':
    case '$pull':
    case '$pullAll':
    case '$push':
    case '$addToSet':
      break;
    default:
      return;
  }
  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {
    self.$__.version = VERSION_INC;
  } else if (/^\$p/.test(op)) {
    self.increment();
  } else if (Array.isArray(val)) {
    self.increment();
  } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
    self.$__.version = VERSION_WHERE;
  }
}
function handleAtomics(self, where, delta, data, value) {
  if (delta.$set && delta.$set[data.path]) {
    return;
  }
  if (typeof value.$__getAtomics === 'function') {
    value.$__getAtomics().forEach(function(atomic) {
      const op = atomic[0];
      const val = atomic[1];
      operand(self, where, delta, data, val, op);
    });
    return;
  }
  const atomics = value[arrayAtomicsSymbol];
  const ops = Object.keys(atomics);
  let i = ops.length;
  let val;
  let op;
  if (i === 0) {
    if (utils.isMongooseObject(value)) {
      value = value.toObject({depopulate: 1, _isNested: true});
    } else if (value.valueOf) {
      value = value.valueOf();
    }
    return operand(self, where, delta, data, value);
  }
  function iter(mem) {
    return utils.isMongooseObject(mem)
      ? mem.toObject({depopulate: 1, _isNested: true})
      : mem;
  }
  while (i--) {
    op = ops[i];
    val = atomics[op];
    if (utils.isMongooseObject(val)) {
      val = val.toObject({depopulate: true, transform: false, _isNested: true});
    } else if (Array.isArray(val)) {
      val = val.map(iter);
    } else if (val.valueOf) {
      val = val.valueOf();
    }
    if (op === '$addToSet') {
      val = {$each: val};
    }
    operand(self, where, delta, data, val, op);
  }
}
Model.prototype.$__delta = function() {
  const dirty = this.$__dirty();
  if (!dirty.length && VERSION_ALL !== this.$__.version) {
    return;
  }
  const where = {};
  const delta = {};
  const len = dirty.length;
  const divergent = [];
  let d = 0;
  where._id = this._doc._id;
  if (get(where, '_id.$__', null) != null) {
    where._id = where._id.toObject({ transform: false, depopulate: true });
  }
  for (; d < len; ++d) {
    const data = dirty[d];
    let value = data.value;
    const match = checkDivergentArray(this, data.path, value);
    if (match) {
      divergent.push(match);
      continue;
    }
    const pop = this.populated(data.path, true);
    if (!pop && this.$__.selected) {
      const pathSplit = data.path.split('.');
      const top = pathSplit[0];
      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {
          where[top] = this.$__.selected[top];
          pathSplit[1] = '$';
          data.path = pathSplit.join('.');
        }
        else {
          divergent.push(data.path);
          continue;
        }
      }
    }
    if (divergent.length) continue;
    if (value === undefined) {
      operand(this, where, delta, data, 1, '$unset');
    } else if (value === null) {
      operand(this, where, delta, data, null);
    } else if (value.isMongooseArray && value.$path() && value[arrayAtomicsSymbol]) {
      handleAtomics(this, where, delta, data, value);
    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
      value = value.toObject();
      operand(this, where, delta, data, value);
    } else {
      value = utils.clone(value, {
        depopulate: true,
        transform: false,
        virtuals: false,
        getters: false,
        _isNested: true
      });
      operand(this, where, delta, data, value);
    }
  }
  if (divergent.length) {
    return new DivergentArrayError(divergent);
  }
  if (this.$__.version) {
    this.$__version(where, delta);
  }
  return [where, delta];
};
function checkDivergentArray(doc, path, array) {
  const pop = doc.populated(path, true);
  if (!pop && doc.$__.selected) {
    const top = path.split('.')[0];
    if (doc.$__.selected[top + '.$']) {
      return top;
    }
  }
  if (!(pop && array && array.isMongooseArray)) return;
  const check = pop.options.match ||
      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || 
      pop.options.options && pop.options.options.skip || 
      pop.options.select && 
      (pop.options.select._id === 0 ||
      /\s?-_id\s?/.test(pop.options.select));
  if (check) {
    const atomics = array[arrayAtomicsSymbol];
    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
      return path;
    }
  }
}
Model.prototype.$__version = function(where, delta) {
  const key = this.schema.options.versionKey;
  if (where === true) {
    if (key) this.$__setValue(key, delta[key] = 0);
    return;
  }
  if (!this.isSelected(key)) {
    return;
  }
  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
    const value = this.$__getValue(key);
    if (value != null) where[key] = value;
  }
  if (VERSION_INC === (VERSION_INC & this.$__.version)) {
    if (get(delta.$set, key, null) != null) {
      ++delta.$set[key];
    } else {
      delta.$inc = delta.$inc || {};
      delta.$inc[key] = 1;
    }
  }
};
Model.prototype.increment = function increment() {
  this.$__.version = VERSION_ALL;
  return this;
};
Model.prototype.$__where = function _where(where) {
  where || (where = {});
  if (!where._id) {
    where._id = this._doc._id;
  }
  if (this._doc._id === void 0) {
    return new Error('No _id found on document!');
  }
  return where;
};
Model.prototype.remove = function remove(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = undefined;
  }
  options = new RemoveOptions(options);
  if (options.hasOwnProperty('session')) {
    this.$session(options.session);
  }
  if (fn) {
    fn = this.constructor.$wrapCallback(fn);
  }
  return utils.promiseOrCallback(fn, cb => {
    this.$__remove(options, cb);
  }, this.constructor.events);
};
Model.prototype.delete = Model.prototype.remove;
Model.prototype.deleteOne = function deleteOne(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = undefined;
  }
  if (!options) {
    options = {};
  }
  if (fn) {
    fn = this.constructor.$wrapCallback(fn);
  }
  return utils.promiseOrCallback(fn, cb => {
    this.$__deleteOne(options, cb);
  }, this.constructor.events);
};
Model.prototype.$__remove = function $__remove(options, cb) {
  if (this.$__.isDeleted) {
    return immediate(() => cb(null, this));
  }
  const where = this.$__where();
  if (where instanceof Error) {
    return cb(where);
  }
  _applyCustomWhere(this, where);
  const session = this.$session();
  if (!options.hasOwnProperty('session')) {
    options.session = session;
  }
  this[modelCollectionSymbol].deleteOne(where, options, err => {
    if (!err) {
      this.$__.isDeleted = true;
      this.emit('remove', this);
      this.constructor.emit('remove', this);
      return cb(null, this);
    }
    this.$__.isDeleted = false;
    cb(err);
  });
};
Model.prototype.$__deleteOne = Model.prototype.$__remove;
Model.prototype.model = function model(name) {
  return this.db.model(name);
};
Model.exists = function exists(filter, callback) {
  const query = this.findOne(filter).select({ _id: 1 }).lean();
  if (typeof callback === 'function') {
    query.exec(function(err, doc) {
      if (err != null) {
        return callback(err);
      }
      callback(null, !!doc);
    });
    return;
  }
  return query.then(doc => !!doc);
};
Model.discriminator = function(name, schema, value) {
  let model;
  if (typeof name === 'function') {
    model = name;
    name = utils.getFunctionName(model);
    if (!(model.prototype instanceof Model)) {
      throw new Error('The provided class ' + name + ' must extend Model');
    }
  }
  schema = discriminator(this, name, schema, value, true);
  if (this.db.models[name]) {
    throw new OverwriteModelError(name);
  }
  schema.$isRootDiscriminator = true;
  schema.$globalPluginsApplied = true;
  model = this.db.model(model || name, schema, this.collection.name);
  this.discriminators[name] = model;
  const d = this.discriminators[name];
  d.prototype.__proto__ = this.prototype;
  Object.defineProperty(d, 'baseModelName', {
    value: this.modelName,
    configurable: true,
    writable: false
  });
  applyMethods(d, schema);
  applyStatics(d, schema);
  if (this[subclassedSymbol] != null) {
    for (const submodel of this[subclassedSymbol]) {
      submodel.discriminators = submodel.discriminators || {};
      submodel.discriminators[name] =
        model.__subclass(model.db, schema, submodel.collection.name);
    }
  }
  return d;
};
for (const i in EventEmitter.prototype) {
  Model[i] = EventEmitter.prototype[i];
}
Model.init = function init(callback) {
  this.schema.emit('init', this);
  if (this.$init != null) {
    if (callback) {
      this.$init.then(() => callback(), err => callback(err));
      return null;
    }
    return this.$init;
  }
  const Promise = PromiseProvider.get();
  const autoIndex = this.schema.options.autoIndex == null ?
    this.db.config.autoIndex :
    this.schema.options.autoIndex;
  const autoCreate = this.schema.options.autoCreate == null ?
    this.db.config.autoCreate :
    this.schema.options.autoCreate;
  const _ensureIndexes = autoIndex ?
    cb => this.ensureIndexes({ _automatic: true }, cb) :
    cb => cb();
  const _createCollection = autoCreate ?
    cb => this.createCollection({}, cb) :
    cb => cb();
  this.$init = new Promise((resolve, reject) => {
    _createCollection(error => {
      if (error) {
        return reject(error);
      }
      _ensureIndexes(error => {
        if (error) {
          return reject(error);
        }
        resolve(this);
      });
    });
  });
  if (callback) {
    this.$init.then(() => callback(), err => callback(err));
    this.$caught = true;
    return null;
  } else {
    const _catch = this.$init.catch;
    const _this = this;
    this.$init.catch = function() {
      this.$caught = true;
      return _catch.apply(_this.$init, arguments);
    };
  }
  return this.$init;
};
Model.createCollection = function createCollection(options, callback) {
  if (typeof options === 'string') {
    throw new Error('You can\'t specify a new collection name in Model.createCollection.' +
      'This is not like Connection.createCollection. Only options are accepted here.');
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  const schemaCollation = get(this, 'schema.options.collation', null);
  if (schemaCollation != null) {
    options = Object.assign({ collation: schemaCollation }, options);
  }
  return utils.promiseOrCallback(callback, cb => {
    this.db.createCollection(this.collection.collectionName, options, utils.tick((error) => {
      if (error) {
        return cb(error);
      }
      this.collection = this.db.collection(this.collection.collectionName, options);
      cb(null, this.collection);
    }));
  }, this.events);
};
Model.syncIndexes = function syncIndexes(options, callback) {
  callback = this.$wrapCallback(callback);
  const dropNonSchemaIndexes = (cb) => {
    this.listIndexes((err, indexes) => {
      if (err != null) {
        return cb(err);
      }
      const schemaIndexes = this.schema.indexes();
      const toDrop = [];
      for (const index of indexes) {
        let found = false;
        if (index.key._id) {
          continue;
        }
        for (const schemaIndex of schemaIndexes) {
          const key = schemaIndex[0];
          const options = _decorateDiscriminatorIndexOptions(this,
            utils.clone(schemaIndex[1]));
          const optionKeys = ['unique', 'partialFilterExpression', 'sparse', 'expireAfterSeconds'];
          const indexCopy = Object.assign({}, index);
          for (const key of optionKeys) {
            if (!(key in options) && !(key in indexCopy)) {
              continue;
            }
            indexCopy[key] = options[key];
          }
          if (utils.deepEqual(key, index.key) &&
              utils.deepEqual(index, indexCopy)) {
            found = true;
            break;
          }
        }
        if (!found) {
          toDrop.push(index.name);
        }
      }
      if (toDrop.length === 0) {
        return cb(null, []);
      }
      dropIndexes(toDrop, cb);
    });
  };
  const dropIndexes = (toDrop, cb) => {
    let remaining = toDrop.length;
    let error = false;
    toDrop.forEach(indexName => {
      this.collection.dropIndex(indexName, err => {
        if (err != null) {
          error = true;
          return cb(err);
        }
        if (!error) {
          --remaining || cb(null, toDrop);
        }
      });
    });
  };
  return utils.promiseOrCallback(callback, cb => {
    dropNonSchemaIndexes((err, dropped) => {
      if (err != null) {
        return cb(err);
      }
      this.createIndexes(options, err => {
        if (err != null) {
          return cb(err);
        }
        cb(null, dropped);
      });
    });
  }, this.events);
};
Model.listIndexes = function init(callback) {
  callback = this.$wrapCallback(callback);
  const _listIndexes = cb => {
    this.collection.listIndexes().toArray(cb);
  };
  return utils.promiseOrCallback(callback, cb => {
    if (this.collection.buffer) {
      this.collection.addQueue(_listIndexes, [cb]);
    } else {
      _listIndexes(cb);
    }
  }, this.events);
};
Model.ensureIndexes = function ensureIndexes(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return utils.promiseOrCallback(callback, cb => {
    _ensureIndexes(this, options || {}, error => {
      if (error) {
        return cb(error);
      }
      cb(null);
    });
  }, this.events);
};
Model.createIndexes = function createIndexes(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};
  options.createIndex = true;
  return this.ensureIndexes(options, callback);
};
function _ensureIndexes(model, options, callback) {
  const indexes = model.schema.indexes();
  options = options || {};
  const done = function(err) {
    if (err && !model.$caught) {
      model.emit('error', err);
    }
    model.emit('index', err);
    callback && callback(err);
  };
  for (const index of indexes) {
    const keys = Object.keys(index[0]);
    if (keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed') {
      console.warn('mongoose: Cannot specify a custom index on `_id` for ' +
        'model name "' + model.modelName + '", ' +
        'MongoDB does not allow overwriting the default `_id` index. See ' +
        'http:
    }
  }
  if (!indexes.length) {
    immediate(function() {
      done();
    });
    return;
  }
  const indexSingleDone = function(err, fields, options, name) {
    model.emit('index-single-done', err, fields, options, name);
  };
  const indexSingleStart = function(fields, options) {
    model.emit('index-single-start', fields, options);
  };
  const baseSchema = model.schema._baseSchema;
  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
  const create = function() {
    if (options._automatic) {
      if (model.schema.options.autoIndex === false ||
          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {
        return done();
      }
    }
    const index = indexes.shift();
    if (!index) {
      return done();
    }
    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {
      return create();
    }
    const indexFields = utils.clone(index[0]);
    const indexOptions = utils.clone(index[1]);
    _decorateDiscriminatorIndexOptions(model, indexOptions);
    if ('safe' in options) {
      _handleSafe(options);
    }
    applyWriteConcern(model.schema, indexOptions);
    indexSingleStart(indexFields, options);
    let useCreateIndex = !!model.base.options.useCreateIndex;
    if ('useCreateIndex' in model.db.config) {
      useCreateIndex = !!model.db.config.useCreateIndex;
    }
    if ('createIndex' in options) {
      useCreateIndex = !!options.createIndex;
    }
    const methodName = useCreateIndex ? 'createIndex' : 'ensureIndex';
    model.collection[methodName](indexFields, indexOptions, utils.tick(function(err, name) {
      indexSingleDone(err, indexFields, indexOptions, name);
      if (err) {
        return done(err);
      }
      create();
    }));
  };
  immediate(function() {
    if (options._automatic && !model.collection.collection) {
      model.collection.addQueue(create, []);
    } else {
      create();
    }
  });
}
function _decorateDiscriminatorIndexOptions(model, indexOptions) {
  if (model.baseModelName != null && indexOptions.unique &&
      !('partialFilterExpression' in indexOptions) &&
      !('sparse' in indexOptions)) {
    const value = (
      model.schema.discriminatorMapping &&
      model.schema.discriminatorMapping.value
    ) || model.modelName;
    indexOptions.partialFilterExpression = {
      [model.schema.options.discriminatorKey]: value
    };
  }
  return indexOptions;
}
const safeDeprecationWarning = 'Mongoose: the `safe` option for `save()` is ' +
  'deprecated. Use the `w` option instead: http:
const _handleSafe = util.deprecate(function _handleSafe(options) {
  if (options.safe) {
    if (typeof options.safe === 'boolean') {
      options.w = options.safe;
      delete options.safe;
    }
    if (typeof options.safe === 'object') {
      options.w = options.safe.w;
      options.j = options.safe.j;
      options.wtimeout = options.safe.wtimeout;
      delete options.safe;
    }
  }
}, safeDeprecationWarning);
Model.schema;
Model.db;
Model.collection;
Model.base;
Model.discriminators;
Model.translateAliases = function translateAliases(fields) {
  const translate = (key, value) => {
    let alias;
    const translated = [];
    const fieldKeys = key.split('.');
    let currentSchema = this.schema;
    for (const i in fieldKeys) {
      const name = fieldKeys[i];
      if (currentSchema && currentSchema.aliases[name]) {
        alias = currentSchema.aliases[name];
        translated.push(alias);
      } else {
        translated.push(name);
      }
      if (currentSchema && currentSchema.paths[alias]) {
        currentSchema = currentSchema.paths[alias].schema;
      }
      else
        currentSchema = null;
    }
    const translatedKey = translated.join('.');
    if (fields instanceof Map)
      fields.set(translatedKey, value);
    else
      fields[translatedKey] = value;
    if (translatedKey !== key) {
      if (fields instanceof Map) {
        fields.delete(key);
      } else {
        delete fields[key]; 
      }
    }
    return fields;
  };
  if (typeof fields === 'object') {
    if (fields instanceof Map) {
      for (const field of new Map(fields)) {
        fields = translate(field[0], field[1]);
      }
    } else {
      for (const key of Object.keys(fields)) {
        fields = translate(key, fields[key]);
        if (key[0] === '$') {
          if (Array.isArray(fields[key])) {
            for (const i in fields[key]) {
              fields[key][i] = this.translateAliases(fields[key][i]);
            }
          }
        }
      }
    }
    return fields;
  } else {
    return fields;
  }
};
Model.remove = function remove(conditions, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
  }
  const mq = new this.Query({}, {}, this, this.collection);
  callback = this.$wrapCallback(callback);
  return mq.remove(conditions, callback);
};
Model.deleteOne = function deleteOne(conditions, options, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
    options = null;
  }
  else if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  const mq = new this.Query(conditions, {}, this, this.collection);
  mq.setOptions(options);
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return mq.deleteOne(callback);
};
Model.deleteMany = function deleteMany(conditions, options, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
    options = null;
  }
  else if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  const mq = new this.Query(conditions, {}, this, this.collection);
  mq.setOptions(options);
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return mq.deleteMany(callback);
};
Model.find = function find(conditions, projection, options, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
    projection = null;
    options = null;
  } else if (typeof projection === 'function') {
    callback = projection;
    projection = null;
    options = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  const mq = new this.Query({}, {}, this, this.collection);
  mq.select(projection);
  mq.setOptions(options);
  if (this.schema.discriminatorMapping &&
      this.schema.discriminatorMapping.isRoot &&
      mq.selectedInclusively()) {
    mq.select(this.schema.options.discriminatorKey);
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return mq.find(conditions, callback);
};
Model.findById = function findById(id, projection, options, callback) {
  if (typeof id === 'undefined') {
    id = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return this.findOne({_id: id}, projection, options, callback);
};
Model.findOne = function findOne(conditions, projection, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  } else if (typeof projection === 'function') {
    callback = projection;
    projection = null;
    options = null;
  } else if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
    projection = null;
    options = null;
  }
  const mq = new this.Query({}, {}, this, this.collection);
  mq.select(projection);
  mq.setOptions(options);
  if (this.schema.discriminatorMapping &&
      this.schema.discriminatorMapping.isRoot &&
      mq.selectedInclusively()) {
    mq.select(this.schema.options.discriminatorKey);
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return mq.findOne(conditions, callback);
};
Model.estimatedDocumentCount = function estimatedDocumentCount(options, callback) {
  const mq = new this.Query({}, {}, this, this.collection);
  callback = this.$wrapCallback(callback);
  return mq.estimatedDocumentCount(options, callback);
};
Model.countDocuments = function countDocuments(conditions, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
  }
  const mq = new this.Query({}, {}, this, this.collection);
  callback = this.$wrapCallback(callback);
  return mq.countDocuments(conditions, callback);
};
Model.count = function count(conditions, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
  }
  const mq = new this.Query({}, {}, this, this.collection);
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return mq.count(conditions, callback);
};
Model.distinct = function distinct(field, conditions, callback) {
  const mq = new this.Query({}, {}, this, this.collection);
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return mq.distinct(field, conditions, callback);
};
Model.where = function where(path, val) {
  void val; 
  const mq = new this.Query({}, {}, this, this.collection).find({});
  return mq.where.apply(mq, arguments);
};
Model.$where = function $where() {
  const mq = new this.Query({}, {}, this, this.collection).find({});
  return mq.$where.apply(mq, arguments);
};
Model.findOneAndUpdate = function(conditions, update, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  } else if (arguments.length === 1) {
    if (typeof conditions === 'function') {
      const msg = 'Model.findOneAndUpdate(): First argument must not be a function.\n\n'
          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\n'
          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\n'
          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\n'
          + '  ' + this.modelName + '.findOneAndUpdate(update)\n'
          + '  ' + this.modelName + '.findOneAndUpdate()\n';
      throw new TypeError(msg);
    }
    update = conditions;
    conditions = undefined;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  let fields;
  if (options) {
    fields = options.fields || options.projection;
  }
  update = utils.clone(update, {
    depopulate: true,
    _isNested: true
  });
  _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
  const mq = new this.Query({}, {}, this, this.collection);
  mq.select(fields);
  return mq.findOneAndUpdate(conditions, update, options, callback);
};
function _decorateUpdateWithVersionKey(update, options, versionKey) {
  if (!versionKey || !get(options, 'upsert', false)) {
    return;
  }
  const updatedPaths = modifiedPaths(update);
  if (!updatedPaths[versionKey]) {
    if (options.overwrite) {
      update[versionKey] = 0;
    } else {
      if (!update.$setOnInsert) {
        update.$setOnInsert = {};
      }
      update.$setOnInsert[versionKey] = 0;
    }
  }
}
Model.findByIdAndUpdate = function(id, update, options, callback) {
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  if (arguments.length === 1) {
    if (typeof id === 'function') {
      const msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\n\n'
          + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\n'
          + '  ' + this.modelName + '.findByIdAndUpdate(id)\n'
          + '  ' + this.modelName + '.findByIdAndUpdate()\n';
      throw new TypeError(msg);
    }
    return this.findOneAndUpdate({_id: id}, undefined);
  }
  if (id instanceof Document) {
    id = id._id;
  }
  return this.findOneAndUpdate.call(this, {_id: id}, update, options, callback);
};
Model.findOneAndDelete = function(conditions, options, callback) {
  if (arguments.length === 1 && typeof conditions === 'function') {
    const msg = 'Model.findOneAndDelete(): First argument must not be a function.\n\n'
        + '  ' + this.modelName + '.findOneAndDelete(conditions, callback)\n'
        + '  ' + this.modelName + '.findOneAndDelete(conditions)\n'
        + '  ' + this.modelName + '.findOneAndDelete()\n';
    throw new TypeError(msg);
  }
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  let fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }
  const mq = new this.Query({}, {}, this, this.collection);
  mq.select(fields);
  return mq.findOneAndDelete(conditions, options, callback);
};
Model.findByIdAndDelete = function(id, options, callback) {
  if (arguments.length === 1 && typeof id === 'function') {
    const msg = 'Model.findByIdAndDelete(): First argument must not be a function.\n\n'
        + '  ' + this.modelName + '.findByIdAndDelete(id, callback)\n'
        + '  ' + this.modelName + '.findByIdAndDelete(id)\n'
        + '  ' + this.modelName + '.findByIdAndDelete()\n';
    throw new TypeError(msg);
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return this.findOneAndDelete({_id: id}, options, callback);
};
Model.findOneAndReplace = function(filter, replacement, options, callback) {
  if (arguments.length === 1 && typeof filter === 'function') {
    const msg = 'Model.findOneAndReplace(): First argument must not be a function.\n\n'
        + '  ' + this.modelName + '.findOneAndReplace(conditions, callback)\n'
        + '  ' + this.modelName + '.findOneAndReplace(conditions)\n'
        + '  ' + this.modelName + '.findOneAndReplace()\n';
    throw new TypeError(msg);
  }
  if (arguments.length === 3 && typeof options === 'function') {
    callback = options;
    options = replacement;
    replacement = void 0;
  }
  if (arguments.length === 2 && typeof replacement === 'function') {
    callback = replacement;
    replacement = void 0;
    options = void 0;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  let fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }
  const mq = new this.Query({}, {}, this, this.collection);
  mq.select(fields);
  return mq.findOneAndReplace(filter, replacement, options, callback);
};
Model.findOneAndRemove = function(conditions, options, callback) {
  if (arguments.length === 1 && typeof conditions === 'function') {
    const msg = 'Model.findOneAndRemove(): First argument must not be a function.\n\n'
        + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\n'
        + '  ' + this.modelName + '.findOneAndRemove(conditions)\n'
        + '  ' + this.modelName + '.findOneAndRemove()\n';
    throw new TypeError(msg);
  }
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  let fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }
  const mq = new this.Query({}, {}, this, this.collection);
  mq.select(fields);
  return mq.findOneAndRemove(conditions, options, callback);
};
Model.findByIdAndRemove = function(id, options, callback) {
  if (arguments.length === 1 && typeof id === 'function') {
    const msg = 'Model.findByIdAndRemove(): First argument must not be a function.\n\n'
        + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\n'
        + '  ' + this.modelName + '.findByIdAndRemove(id)\n'
        + '  ' + this.modelName + '.findByIdAndRemove()\n';
    throw new TypeError(msg);
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return this.findOneAndRemove({_id: id}, options, callback);
};
Model.create = function create(doc, options, callback) {
  let args;
  let cb;
  const discriminatorKey = this.schema.options.discriminatorKey;
  if (Array.isArray(doc)) {
    args = doc;
    cb = typeof options === 'function' ? options : callback;
    options = options != null && typeof options === 'object' ? options : {};
  } else {
    const last = arguments[arguments.length - 1];
    options = {};
    if (typeof last === 'function' || !last) {
      cb = last;
      args = utils.args(arguments, 0, arguments.length - 1);
    } else {
      args = utils.args(arguments);
    }
    if (args.length === 2 &&
        args[0] != null &&
        args[1] != null &&
        args[0].session == null &&
        last.session != null &&
        last.session.constructor.name === 'ClientSession' &&
        !this.schema.path('session')) {
      console.warn('WARNING: to pass a `session` to `Model.create()` in ' +
        'Mongoose, you **must** pass an array as the first argument. See: ' +
        'https:
    }
  }
  if (cb) {
    cb = this.$wrapCallback(cb);
  }
  return utils.promiseOrCallback(cb, cb => {
    if (args.length === 0) {
      return cb(null);
    }
    const toExecute = [];
    let firstError;
    args.forEach(doc => {
      toExecute.push(callback => {
        const Model = this.discriminators && doc[discriminatorKey] != null ?
          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this, doc[discriminatorKey]) :
          this;
        if (Model == null) {
          throw new Error(`Discriminator "${doc[discriminatorKey]}" not ` +
            `found for model "${this.modelName}"`);
        }
        let toSave = doc;
        const callbackWrapper = (error, doc) => {
          if (error) {
            if (!firstError) {
              firstError = error;
            }
            return callback(null, { error: error });
          }
          callback(null, { doc: doc });
        };
        if (!(toSave instanceof Model)) {
          try {
            toSave = new Model(toSave);
          } catch (error) {
            return callbackWrapper(error);
          }
        }
        toSave.save(options, callbackWrapper);
      });
    });
    parallel(toExecute, (error, res) => {
      const savedDocs = [];
      const len = res.length;
      for (let i = 0; i < len; ++i) {
        if (res[i].doc) {
          savedDocs.push(res[i].doc);
        }
      }
      if (firstError) {
        return cb(firstError, savedDocs);
      }
      if (doc instanceof Array) {
        cb(null, savedDocs);
      } else {
        cb.apply(this, [null].concat(savedDocs));
      }
    });
  }, this.events);
};
Model.watch = function(pipeline, options) {
  return new ChangeStream(this, pipeline, options);
};
Model.startSession = function() {
  return this.db.startSession.apply(this.db, arguments);
};
Model.insertMany = function(arr, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  return utils.promiseOrCallback(callback, cb => {
    this.$__insertMany(arr, options, cb);
  }, this.events);
};
Model.$__insertMany = function(arr, options, callback) {
  const _this = this;
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  callback = callback || utils.noop;
  options = options || {};
  const limit = get(options, 'limit', 1000);
  const rawResult = get(options, 'rawResult', false);
  const ordered = get(options, 'ordered', true);
  if (!Array.isArray(arr)) {
    arr = [arr];
  }
  const toExecute = [];
  const validationErrors = [];
  arr.forEach(function(doc) {
    toExecute.push(function(callback) {
      if (!(doc instanceof _this)) {
        doc = new _this(doc);
      }
      if (options.session != null) {
        doc.$session(options.session);
      }
      doc.validate({ __noPromise: true }, function(error) {
        if (error) {
          if (ordered === false) {
            validationErrors.push(error);
            return callback(null, null);
          }
          return callback(error);
        }
        callback(null, doc);
      });
    });
  });
  parallelLimit(toExecute, limit, function(error, docs) {
    if (error) {
      callback(error, null);
      return;
    }
    const docAttributes = docs.filter(function(doc) {
      return doc != null;
    });
    if (docAttributes.length < 1) {
      callback(null, []);
      return;
    }
    const docObjects = docAttributes.map(function(doc) {
      if (doc.schema.options.versionKey) {
        doc[doc.schema.options.versionKey] = 0;
      }
      if (doc.initializeTimestamps) {
        return doc.initializeTimestamps().toObject(internalToObjectOptions);
      }
      return doc.toObject(internalToObjectOptions);
    });
    _this.collection.insertMany(docObjects, options, function(error, res) {
      if (error) {
        callback(error, null);
        return;
      }
      for (let i = 0; i < docAttributes.length; ++i) {
        docAttributes[i].$__reset();
        docAttributes[i].isNew = false;
        docAttributes[i].emit('isNew', false);
        docAttributes[i].constructor.emit('isNew', false);
      }
      if (rawResult) {
        if (ordered === false) {
          res.mongoose = {
            validationErrors: validationErrors
          };
        }
        return callback(null, res);
      }
      callback(null, docAttributes);
    });
  });
};
Model.bulkWrite = function(ops, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  options = options || {};
  const validations = ops.map(op => castBulkWrite(this, op, options));
  return utils.promiseOrCallback(callback, cb => {
    parallel(validations, error => {
      if (error) {
        return cb(error);
      }
      this.collection.bulkWrite(ops, options, (error, res) => {
        if (error) {
          return cb(error);
        }
        cb(null, res);
      });
    });
  }, this.events);
};
Model.hydrate = function(obj) {
  const model = require('./queryhelpers').createModel(this, obj);
  model.init(obj);
  return model;
};
Model.update = function update(conditions, doc, options, callback) {
  return _update(this, 'update', conditions, doc, options, callback);
};
Model.updateMany = function updateMany(conditions, doc, options, callback) {
  return _update(this, 'updateMany', conditions, doc, options, callback);
};
Model.updateOne = function updateOne(conditions, doc, options, callback) {
  return _update(this, 'updateOne', conditions, doc, options, callback);
};
Model.replaceOne = function replaceOne(conditions, doc, options, callback) {
  const versionKey = get(this, 'schema.options.versionKey', null);
  if (versionKey && !doc[versionKey]) {
    doc[versionKey] = 0;
  }
  return _update(this, 'replaceOne', conditions, doc, options, callback);
};
function _update(model, op, conditions, doc, options, callback) {
  const mq = new model.Query({}, {}, model, model.collection);
  if (callback) {
    callback = model.$wrapCallback(callback);
  }
  if (conditions instanceof Document) {
    conditions = conditions.toObject();
  } else {
    conditions = utils.clone(conditions);
  }
  options = typeof options === 'function' ? options : utils.clone(options);
  const versionKey = get(model, 'schema.options.versionKey', null);
  _decorateUpdateWithVersionKey(doc, options, versionKey);
  return mq[op](conditions, doc, options, callback);
}
Model.mapReduce = function mapReduce(o, callback) {
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return utils.promiseOrCallback(callback, cb => {
    if (!Model.mapReduce.schema) {
      const opts = {noId: true, noVirtualId: true, strict: false};
      Model.mapReduce.schema = new Schema({}, opts);
    }
    if (!o.out) o.out = {inline: 1};
    if (o.verbose !== false) o.verbose = true;
    o.map = String(o.map);
    o.reduce = String(o.reduce);
    if (o.query) {
      let q = new this.Query(o.query);
      q.cast(this);
      o.query = q._conditions;
      q = undefined;
    }
    this.collection.mapReduce(null, null, o, (err, res) => {
      if (err) {
        return cb(err);
      }
      if (res.collection) {
        const model = Model.compile('_mapreduce_' + res.collection.collectionName,
          Model.mapReduce.schema, res.collection.collectionName, this.db,
          this.base);
        model._mapreduce = true;
        res.model = model;
        return cb(null, res);
      }
      cb(null, res);
    });
  }, this.events);
};
Model.aggregate = function aggregate(pipeline, callback) {
  if (arguments.length > 2 || get(pipeline, 'constructor.name') === 'Object') {
    throw new Error('Mongoose 5.x disallows passing a spread of operators ' +
      'to `Model.aggregate()`. Instead of ' +
      '`Model.aggregate({ $match }, { $skip })`, do ' +
      '`Model.aggregate([{ $match }, { $skip }])`');
  }
  if (typeof pipeline === 'function') {
    callback = pipeline;
    pipeline = [];
  }
  const aggregate = new Aggregate(pipeline || []);
  aggregate.model(this);
  if (typeof callback === 'undefined') {
    return aggregate;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  aggregate.exec(callback);
  return aggregate;
};
Model.geoSearch = function(conditions, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  return utils.promiseOrCallback(callback, cb => {
    let error;
    if (conditions === undefined || !utils.isObject(conditions)) {
      error = new Error('Must pass conditions to geoSearch');
    } else if (!options.near) {
      error = new Error('Must specify the near option in geoSearch');
    } else if (!Array.isArray(options.near)) {
      error = new Error('near option must be an array [x, y]');
    }
    if (error) {
      return cb(error);
    }
    options.search = conditions;
    this.collection.geoHaystackSearch(options.near[0], options.near[1], options, (err, res) => {
      if (err) {
        return cb(err);
      }
      let count = res.results.length;
      if (options.lean || count === 0) {
        return cb(null, res.results);
      }
      const errSeen = false;
      function init(err) {
        if (err && !errSeen) {
          return cb(err);
        }
        if (!--count && !errSeen) {
          cb(null, res.results);
        }
      }
      for (let i = 0; i < res.results.length; ++i) {
        const temp = res.results[i];
        res.results[i] = new this();
        res.results[i].init(temp, {}, init);
      }
    });
  }, this.events);
};
Model.populate = function(docs, paths, callback) {
  const _this = this;
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  paths = utils.populate(paths);
  const cache = {};
  return utils.promiseOrCallback(callback, cb => {
    _populate(_this, docs, paths, cache, cb);
  }, this.events);
};
function _populate(model, docs, paths, cache, callback) {
  const length = paths.length;
  let pending = paths.length;
  if (length === 0) {
    return callback(null, docs);
  }
  for (let i = 0; i < length; ++i) {
    populate(model, docs, paths[i], next);
  }
  function next(err) {
    if (err) {
      return callback(err, null);
    }
    if (--pending) {
      return;
    }
    callback(null, docs);
  }
}
const excludeIdReg = /\s?-_id\s?/;
const excludeIdRegGlobal = /\s?-_id\s?/g;
function populate(model, docs, options, callback) {
  if (!Array.isArray(docs)) {
    docs = [docs];
  }
  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
    return callback();
  }
  const modelsMap = getModelsMapForPopulate(model, docs, options);
  if (modelsMap instanceof Error) {
    return immediate(function() {
      callback(modelsMap);
    });
  }
  const len = modelsMap.length;
  let mod;
  let match;
  let select;
  let vals = [];
  function flatten(item) {
    return undefined !== item;
  }
  let _remaining = len;
  let hasOne = false;
  for (let i = 0; i < len; ++i) {
    mod = modelsMap[i];
    select = mod.options.select;
    match = _formatMatch(mod.match);
    let ids = utils.array.flatten(mod.ids, flatten);
    ids = utils.array.unique(ids);
    const assignmentOpts = {};
    assignmentOpts.sort = get(mod, 'options.options.sort', void 0);
    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);
    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
      --_remaining;
      if (mod.count) {
        next(mod, assignmentOpts, null, []);
      }
      continue;
    }
    hasOne = true;
    if (mod.foreignField.size === 1) {
      const foreignField = Array.from(mod.foreignField)[0];
      const foreignSchemaType = mod.model.schema.path(foreignField);
      if (foreignField !== '_id' || !match['_id']) {
        ids = _filterInvalidIds(ids, foreignSchemaType, mod.options.skipInvalidIds);
        match[foreignField] = { $in: ids };
      }
    } else {
      const $or = [];
      if (Array.isArray(match.$or)) {
        match.$and = [{ $or: match.$or }, { $or: $or }];
        delete match.$or;
      } else {
        match.$or = $or;
      }
      for (const foreignField of mod.foreignField) {
        if (foreignField !== '_id' || !match['_id']) {
          const foreignSchemaType = mod.model.schema.path(foreignField);
          ids = _filterInvalidIds(ids, foreignSchemaType, mod.options.skipInvalidIds);
          $or.push({ [foreignField]: { $in: ids } });
        }
      }
    }
    if (assignmentOpts.excludeId) {
      if (typeof select === 'string') {
        select = select.replace(excludeIdRegGlobal, ' ');
      } else {
        select = utils.object.shallowCopy(select);
        delete select._id;
      }
    }
    if (mod.options.options && mod.options.options.limit) {
      assignmentOpts.originalLimit = mod.options.options.limit;
      mod.options.options.limit = mod.options.options.limit * ids.length;
    }
    const subPopulate = utils.clone(mod.options.populate);
    const query = mod.model.find(match, select, mod.options.options);
    if (mod.count) {
      for (const foreignField of mod.foreignField) {
        query.select(foreignField);
      }
    }
    for (const foreignField of mod.foreignField) {
      if (foreignField !== '_id' && query.selectedInclusively() &&
          !isPathSelectedInclusive(query._fields, foreignField)) {
        query.select(foreignField);
      }
    }
    if (subPopulate) {
      query.populate(subPopulate);
    }
    query.exec(next.bind(this, mod, assignmentOpts));
  }
  if (!hasOne) {
    return callback();
  }
  function next(options, assignmentOpts, err, valsFromDb) {
    if (mod.options.options && mod.options.options.limit) {
      mod.options.options.limit = assignmentOpts.originalLimit;
    }
    if (err) return callback(err, null);
    vals = vals.concat(valsFromDb);
    _assign(null, vals, options, assignmentOpts);
    if (--_remaining === 0) {
      callback();
    }
  }
  function _assign(err, vals, mod, assignmentOpts) {
    if (err) {
      return callback(err, null);
    }
    const options = mod.options;
    const isVirtual = mod.isVirtual;
    const justOne = mod.justOne;
    let _val;
    const lean = options.options && options.options.lean;
    const len = vals.length;
    const rawOrder = {};
    const rawDocs = {};
    let key;
    let val;
    const allIds = utils.clone(mod.allIds);
    for (let i = 0; i < len; i++) {
      val = vals[i];
      if (val == null) {
        continue;
      }
      for (const foreignField of mod.foreignField) {
        _val = utils.getValue(foreignField, val);
        if (Array.isArray(_val)) {
          _val = utils.array.flatten(_val);
          const _valLength = _val.length;
          for (let j = 0; j < _valLength; ++j) {
            let __val = _val[j];
            if (__val instanceof Document) {
              __val = __val._id;
            }
            key = String(__val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              if (isVirtual && !justOne) {
                rawDocs[key] = [val];
                rawOrder[key] = [i];
              } else {
                rawDocs[key] = val;
                rawOrder[key] = i;
              }
            }
          }
        } else {
          if (_val instanceof Document) {
            _val = _val._id;
          }
          key = String(_val);
          if (rawDocs[key]) {
            if (Array.isArray(rawDocs[key])) {
              rawDocs[key].push(val);
              rawOrder[key].push(i);
            } else {
              rawDocs[key] = [rawDocs[key], val];
              rawOrder[key] = [rawOrder[key], i];
            }
          } else {
            rawDocs[key] = val;
            rawOrder[key] = i;
          }
        }
        if (lean) {
          leanPopulateMap.set(val, mod.model);
        } else {
          val.$__.wasPopulated = true;
        }
      }
    }
    assignVals({
      originalModel: model,
      rawIds: mod.isVirtual ? allIds : mod.allIds,
      allIds: allIds,
      foreignField: mod.foreignField,
      rawDocs: rawDocs,
      rawOrder: rawOrder,
      docs: mod.docs,
      path: options.path,
      options: assignmentOpts,
      justOne: mod.justOne,
      isVirtual: mod.isVirtual,
      allOptions: mod,
      lean: lean,
      virtual: mod.virtual,
      count: mod.count,
      match: mod.match
    });
  }
}
function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
  if (!skipInvalidIds) {
    return ids;
  }
  return ids.filter(id => {
    try {
      foreignSchemaType.cast(id);
      return true;
    } catch (err) {
      return false;
    }
  });
}
function _formatMatch(match) {
  if (Array.isArray(match)) {
    if (match.length > 1) {
      return { $or: [].concat(match.map(m => Object.assign({}, m))) };
    }
    return Object.assign({}, match[0]);
  }
  return Object.assign({}, match);
}
function getModelsMapForPopulate(model, docs, options) {
  let i;
  let doc;
  const len = docs.length;
  const available = {};
  const map = [];
  const modelNameFromQuery = options.model && options.model.modelName || options.model;
  let schema;
  let refPath;
  let Model;
  let currentOptions;
  let modelNames;
  let modelName;
  let modelForFindSchema;
  const originalModel = options.model;
  let isVirtual = false;
  const modelSchema = model.schema;
  for (i = 0; i < len; i++) {
    doc = docs[i];
    schema = getSchemaTypes(modelSchema, doc, options.path);
    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
    if (isUnderneathDocArray && get(options, 'options.sort') != null) {
      return new Error('Cannot populate with `sort` on path ' + options.path +
        ' because it is a subproperty of a document array');
    }
    modelNames = null;
    let isRefPath = false;
    if (Array.isArray(schema)) {
      for (let j = 0; j < schema.length; ++j) {
        let _modelNames;
        try {
          const res = _getModelNames(doc, schema[j]);
          _modelNames = res.modelNames;
          isRefPath = res.isRefPath;
        } catch (error) {
          return error;
        }
        if (!_modelNames) {
          continue;
        }
        modelNames = modelNames || [];
        for (let x = 0; x < _modelNames.length; ++x) {
          if (modelNames.indexOf(_modelNames[x]) === -1) {
            modelNames.push(_modelNames[x]);
          }
        }
      }
    } else {
      try {
        const res = _getModelNames(doc, schema);
        modelNames = res.modelNames;
        isRefPath = res.isRefPath;
      } catch (error) {
        return error;
      }
      if (!modelNames) {
        continue;
      }
    }
    const virtual = getVirtual(model.schema, options.path);
    let localField;
    let count = false;
    if (virtual && virtual.options) {
      const virtualPrefix = virtual.$nestedSchemaPath ?
        virtual.$nestedSchemaPath + '.' : '';
      if (typeof virtual.options.localField === 'function') {
        localField = virtualPrefix + virtual.options.localField.call(doc, doc);
      } else {
        localField = virtualPrefix + virtual.options.localField;
      }
      count = virtual.options.count;
    } else {
      localField = options.path;
    }
    let foreignField = virtual && virtual.options ?
      virtual.options.foreignField :
      '_id';
    let justOne = null;
    if ('justOne' in options) {
      justOne = options.justOne;
    } else if (virtual && virtual.options && virtual.options.refPath) {
      const normalizedRefPath =
        normalizeRefPath(virtual.options.refPath, doc, options.path);
      justOne = !!virtual.options.justOne;
      isVirtual = true;
      const refValue = utils.getValue(normalizedRefPath, doc);
      modelNames = Array.isArray(refValue) ? refValue : [refValue];
    } else if (virtual && virtual.options && virtual.options.ref) {
      let normalizedRef;
      if (typeof virtual.options.ref === 'function') {
        normalizedRef = virtual.options.ref.call(doc, doc);
      } else {
        normalizedRef = virtual.options.ref;
      }
      justOne = !!virtual.options.justOne;
      isVirtual = true;
      if (!modelNames) {
        modelNames = [].concat(normalizedRef);
      }
    } else if (schema && !schema[schemaMixedSymbol]) {
      justOne = !schema.$isMongooseArray;
    }
    if (!modelNames) {
      continue;
    }
    if (virtual && (!localField || !foreignField)) {
      return new Error('If you are populating a virtual, you must set the ' +
        'localField and foreignField options');
    }
    options.isVirtual = isVirtual;
    options.virtual = virtual;
    if (typeof localField === 'function') {
      localField = localField.call(doc, doc);
    }
    if (typeof foreignField === 'function') {
      foreignField = foreignField.call(doc);
    }
    const localFieldPathType = modelSchema._getPathType(localField);
    const localFieldPath = localFieldPathType === 'real' ? modelSchema.paths[localField] : localFieldPathType.schema;
    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
    let ret;
    const _populateOptions = get(options, 'options', {});
    const getters = 'getters' in _populateOptions ?
      _populateOptions.getters :
      options.isVirtual && get(virtual, 'options.getters', false);
    if (localFieldGetters.length > 0 && getters) {
      const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);
      const localFieldValue = utils.getValue(localField, doc);
      if (Array.isArray(localFieldValue)) {
        const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);
        ret = localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>
          localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
      } else {
        ret = localFieldPath.applyGetters(localFieldValue, hydratedDoc);
      }
    } else {
      ret = convertTo_id(utils.getValue(localField, doc));
    }
    const id = String(utils.getValue(foreignField, doc));
    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
    let match = get(options, 'match', null) ||
      get(currentOptions, 'match', null) ||
      get(options, 'virtual.options.options.match', null);
    const hasMatchFunction = typeof match === 'function';
    if (hasMatchFunction) {
      match = match.call(doc, doc);
    }
    let k = modelNames.length;
    while (k--) {
      modelName = modelNames[k];
      if (modelName == null) {
        continue;
      }
      const connection = options.connection != null ? options.connection : model.db;
      try {
        Model = originalModel && originalModel[modelSymbol] ?
          originalModel :
          modelName[modelSymbol] ? modelName : connection.model(modelName);
      } catch (error) {
        return error;
      }
      let ids = ret;
      const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];
      if (isRefPath && Array.isArray(ret) && flat.length === modelNames.length) {
        ids = flat.filter((val, i) => modelNames[i] === modelName);
      }
      if (!available[modelName]) {
        currentOptions = {
          model: Model
        };
        if (isVirtual && virtual.options && virtual.options.options) {
          currentOptions.options = utils.clone(virtual.options.options);
        }
        utils.merge(currentOptions, options);
        options[populateModelSymbol] = Model;
        available[modelName] = {
          model: Model,
          options: currentOptions,
          match: hasMatchFunction ? [match] : match,
          docs: [doc],
          ids: [ids],
          allIds: [ret],
          localField: new Set([localField]),
          foreignField: new Set([foreignField]),
          justOne: justOne,
          isVirtual: isVirtual,
          virtual: virtual,
          count: count,
          [populateModelSymbol]: Model
        };
        map.push(available[modelName]);
      } else {
        available[modelName].localField.add(localField);
        available[modelName].foreignField.add(foreignField);
        available[modelName].docs.push(doc);
        available[modelName].ids.push(ids);
        available[modelName].allIds.push(ret);
        if (hasMatchFunction) {
          available[modelName].match.push(match);
        }
      }
    }
  }
  function _getModelNames(doc, schema) {
    let modelNames;
    let discriminatorKey;
    let isRefPath = false;
    if (schema && schema.caster) {
      schema = schema.caster;
    }
    if (schema && schema.$isSchemaMap) {
      schema = schema.$__schemaType;
    }
    if (!schema && model.discriminators) {
      discriminatorKey = model.schema.discriminatorMapping.key;
    }
    refPath = schema && schema.options && schema.options.refPath;
    const normalizedRefPath = normalizeRefPath(refPath, doc, options.path);
    if (modelNameFromQuery) {
      modelNames = [modelNameFromQuery]; 
    } else if (normalizedRefPath) {
      if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {
        throw new Error('refPath `' + normalizedRefPath +
          '` must not be excluded in projection, got ' +
          util.inspect(options._queryProjection));
      }
      modelNames = utils.getValue(normalizedRefPath, doc);
      if (Array.isArray(modelNames)) {
        modelNames = utils.array.flatten(modelNames);
      }
      isRefPath = true;
    } else {
      let modelForCurrentDoc = model;
      let schemaForCurrentDoc;
      if (!schema && discriminatorKey) {
        modelForFindSchema = utils.getValue(discriminatorKey, doc);
        if (modelForFindSchema) {
          try {
            modelForCurrentDoc = model.db.model(modelForFindSchema);
          } catch (error) {
            return error;
          }
          schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
          if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
            schemaForCurrentDoc = schemaForCurrentDoc.caster;
          }
        }
      } else {
        schemaForCurrentDoc = schema;
      }
      const virtual = getVirtual(modelForCurrentDoc.schema, options.path);
      let ref;
      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {
        ref = handleRefFunction(ref, doc);
        modelNames = [ref];
      } else if ((ref = get(virtual, 'options.ref')) != null) {
        ref = handleRefFunction(ref, doc);
        if (Array.isArray(ref)) {
          modelNames = ref;
        } else {
          modelNames = [ref];
        }
        isVirtual = true;
      } else {
        modelNames = discriminatorKey ? null : [model.modelName];
      }
    }
    if (!modelNames) {
      return { modelNames: modelNames, isRefPath: isRefPath };
    }
    if (!Array.isArray(modelNames)) {
      modelNames = [modelNames];
    }
    return { modelNames: modelNames, isRefPath: isRefPath };
  }
  return map;
}
function handleRefFunction(ref, doc) {
  if (typeof ref === 'function' && !ref[modelSymbol]) {
    return ref.call(doc, doc);
  }
  return ref;
}
function convertTo_id(val) {
  if (val instanceof Model) return val._id;
  if (Array.isArray(val)) {
    for (let i = 0; i < val.length; ++i) {
      if (val[i] instanceof Model) {
        val[i] = val[i]._id;
      }
    }
    if (val.isMongooseArray && val.$schema()) {
      return val.$schema().cast(val, val.$parent());
    }
    return [].concat(val);
  }
  if (val != null && val.constructor.name === 'Object') {
    const ret = [];
    for (const key of Object.keys(val)) {
      ret.push(val[key]);
    }
    return ret;
  }
  if (val instanceof Map) {
    return Array.from(val.values());
  }
  return val;
}
Model.compile = function compile(name, schema, collectionName, connection, base) {
  const versioningEnabled = schema.options.versionKey !== false;
  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
    const o = {};
    o[schema.options.versionKey] = Number;
    schema.add(o);
  }
  let model;
  if (typeof name === 'function' && name.prototype instanceof Model) {
    model = name;
    name = model.name;
    schema.loadClass(model, false);
    model.prototype.$isMongooseModelPrototype = true;
  } else {
    model = function model(doc, fields, skipId) {
      model.hooks.execPreSync('createModel', doc);
      if (!(this instanceof model)) {
        return new model(doc, fields, skipId);
      }
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {
        Model.call(this, doc, fields, skipId);
        return;
      }
      const Discriminator = model.discriminators[doc[discriminatorKey]] ||
        getDiscriminatorByValue(model, doc[discriminatorKey]);
      if (Discriminator != null) {
        return new Discriminator(doc, fields, skipId);
      }
      Model.call(this, doc, fields, skipId);
    };
  }
  model.hooks = schema.s.hooks.clone();
  model.base = base;
  model.modelName = name;
  if (!(model.prototype instanceof Model)) {
    model.__proto__ = Model;
    model.prototype.__proto__ = Model.prototype;
  }
  model.model = Model.prototype.model;
  model.db = model.prototype.db = connection;
  model.discriminators = model.prototype.discriminators = undefined;
  model[modelSymbol] = true;
  model.events = new EventEmitter();
  model.prototype.$__setSchema(schema);
  const _userProvidedOptions = schema._userProvidedOptions || {};
  let bufferCommands = true;
  if (connection.base.get('bufferCommands') != null) {
    bufferCommands = connection.base.get('bufferCommands');
  }
  if (connection.config.bufferCommands != null) {
    bufferCommands = connection.config.bufferCommands;
  }
  if (_userProvidedOptions.bufferCommands != null) {
    bufferCommands = _userProvidedOptions.bufferCommands;
  }
  const collectionOptions = {
    bufferCommands: bufferCommands,
    capped: schema.options.capped,
    Promise: model.base.Promise
  };
  model.prototype.collection = connection.collection(
    collectionName,
    collectionOptions
  );
  model.prototype[modelCollectionSymbol] = model.prototype.collection;
  applyMethods(model, schema);
  applyStatics(model, schema);
  applyHooks(model, schema);
  applyStaticHooks(model, schema.s.hooks, schema.statics);
  model.schema = model.prototype.schema;
  model.collection = model.prototype.collection;
  model.Query = function() {
    Query.apply(this, arguments);
  };
  model.Query.prototype = Object.create(Query.prototype);
  model.Query.base = Query.base;
  applyQueryMiddleware(model.Query, model);
  applyQueryMethods(model, schema.query);
  return model;
};
function applyQueryMethods(model, methods) {
  for (const i in methods) {
    model.Query.prototype[i] = methods[i];
  }
}
Model.__subclass = function subclass(conn, schema, collection) {
  const _this = this;
  const Model = function Model(doc, fields, skipId) {
    if (!(this instanceof Model)) {
      return new Model(doc, fields, skipId);
    }
    _this.call(this, doc, fields, skipId);
  };
  Model.__proto__ = _this;
  Model.prototype.__proto__ = _this.prototype;
  Model.db = Model.prototype.db = conn;
  _this[subclassedSymbol] = _this[subclassedSymbol] || [];
  _this[subclassedSymbol].push(Model);
  if (_this.discriminators != null) {
    Model.discriminators = {};
    for (const key of Object.keys(_this.discriminators)) {
      Model.discriminators[key] = _this.discriminators[key].
        __subclass(_this.db, _this.discriminators[key].schema, collection);
    }
  }
  const s = schema && typeof schema !== 'string'
    ? schema
    : _this.prototype.schema;
  const options = s.options || {};
  const _userProvidedOptions = s._userProvidedOptions || {};
  if (!collection) {
    collection = _this.prototype.schema.get('collection') ||
      utils.toCollectionName(_this.modelName, this.base.pluralize());
  }
  let bufferCommands = true;
  if (s) {
    if (conn.config.bufferCommands != null) {
      bufferCommands = conn.config.bufferCommands;
    }
    if (_userProvidedOptions.bufferCommands != null) {
      bufferCommands = _userProvidedOptions.bufferCommands;
    }
  }
  const collectionOptions = {
    bufferCommands: bufferCommands,
    capped: s && options.capped
  };
  Model.prototype.collection = conn.collection(collection, collectionOptions);
  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;
  Model.collection = Model.prototype.collection;
  Model.init(() => {});
  return Model;
};
Model.$wrapCallback = function(callback) {
  if (callback == null) {
    return callback;
  }
  if (typeof callback !== 'function') {
    throw new Error('Callback must be a function, got ' + callback);
  }
  const _this = this;
  return function() {
    try {
      callback.apply(null, arguments);
    } catch (error) {
      _this.emit('error', error);
    }
  };
};
Model.inspect = function() {
  return `Model { ${this.modelName} }`;
};
if (util.inspect.custom) {
  Model[util.inspect.custom] = Model.inspect;
}
module.exports = exports = Model;
