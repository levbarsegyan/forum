'use strict';
const MongooseError = require('./');
const util = require('util');
function ValidationError(instance) {
  this.errors = {};
  this._message = '';
  if (instance && instance.constructor.name === 'model') {
    this._message = instance.constructor.modelName + ' validation failed';
    MongooseError.call(this, this._message);
  } else {
    this._message = 'Validation failed';
    MongooseError.call(this, this._message);
  }
  this.name = 'ValidationError';
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  if (instance) {
    instance.errors = this.errors;
  }
}
ValidationError.prototype = Object.create(MongooseError.prototype);
ValidationError.prototype.constructor = MongooseError;
ValidationError.prototype.toString = function() {
  return this.name + ': ' + _generateMessage(this);
};
ValidationError.prototype.inspect = function() {
  return Object.assign(new Error(this.message), this);
};
if (util.inspect.custom) {
  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
}
ValidationError.prototype.toJSON = function() {
  return Object.assign({}, this, { message: this.message });
};
ValidationError.prototype.addError = function(path, error) {
  this.errors[path] = error;
  this.message = this._message + ': ' + _generateMessage(this);
};
function _generateMessage(err) {
  const keys = Object.keys(err.errors || {});
  const len = keys.length;
  const msgs = [];
  let key;
  for (let i = 0; i < len; ++i) {
    key = keys[i];
    if (err === err.errors[key]) {
      continue;
    }
    msgs.push(key + ': ' + err.errors[key].message);
  }
  return msgs.join(', ');
}
module.exports = exports = ValidationError;
