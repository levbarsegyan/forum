'use strict';
const EventEmitter = require('events').EventEmitter;
const Schema = require('./schema');
const Collection = require('./driver').get().Collection;
const STATES = require('./connectionstate');
const MongooseError = require('./error');
const PromiseProvider = require('./promise_provider');
const applyPlugins = require('./helpers/schema/applyPlugins');
const get = require('./helpers/get');
const mongodb = require('mongodb');
const utils = require('./utils');
const parseConnectionString = require('mongodb-core').parseConnectionString;
const noPasswordAuthMechanisms = [
  'MONGODB-X509'
];
function Connection(base) {
  this.base = base;
  this.collections = {};
  this.models = {};
  this.config = {autoIndex: true};
  this.replica = false;
  this.options = null;
  this.otherDbs = []; 
  this.relatedDbs = {}; 
  this.states = STATES;
  this._readyState = STATES.disconnected;
  this._closeCalled = false;
  this._hasOpened = false;
  this.plugins = [];
}
Connection.prototype.__proto__ = EventEmitter.prototype;
Object.defineProperty(Connection.prototype, 'readyState', {
  get: function() {
    return this._readyState;
  },
  set: function(val) {
    if (!(val in STATES)) {
      throw new Error('Invalid connection state: ' + val);
    }
    if (this._readyState !== val) {
      this._readyState = val;
      for (let i = 0; i < this.otherDbs.length; i++) {
        this.otherDbs[i].readyState = val;
      }
      for (const k in this.relatedDbs) {
        this.relatedDbs[k].readyState = val;
      }
      if (STATES.connected === val) {
        this._hasOpened = true;
      }
      this.emit(STATES[val]);
    }
  }
});
Connection.prototype.get = function(key) {
  return get(this.options, key);
};
Connection.prototype.set = function(key, val) {
  this.options = this.options || {};
  this.options[key] = val;
  return val;
};
Connection.prototype.collections;
Connection.prototype.name;
Object.defineProperty(Connection.prototype, 'plugins', {
  configurable: false,
  enumerable: true,
  writable: true
});
Object.defineProperty(Connection.prototype, 'host', {
  configurable: true,
  enumerable: true,
  writable: true
});
Object.defineProperty(Connection.prototype, 'port', {
  configurable: true,
  enumerable: true,
  writable: true
});
Object.defineProperty(Connection.prototype, 'user', {
  configurable: true,
  enumerable: true,
  writable: true
});
Object.defineProperty(Connection.prototype, 'pass', {
  configurable: true,
  enumerable: true,
  writable: true
});
Connection.prototype.db;
Connection.prototype.config;
Connection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }
  this.db.createCollection(collection, options, cb);
});
Connection.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }
  const session = this.client.startSession(options);
  cb(null, session);
});
Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
  this.db.dropCollection(collection, cb);
});
Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
  for (const name of Object.keys(this.models)) {
    delete this.models[name].$init;
  }
  this.db.dropDatabase(cb);
});
function _wrapConnHelper(fn) {
  return function() {
    const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
    const argsWithoutCb = typeof cb === 'function' ?
      Array.prototype.slice.call(arguments, 0, arguments.length - 1) :
      Array.prototype.slice.call(arguments);
    return utils.promiseOrCallback(cb, cb => {
      if (this.readyState !== STATES.connected) {
        this.once('open', function() {
          fn.apply(this, argsWithoutCb.concat([cb]));
        });
      } else {
        fn.apply(this, argsWithoutCb.concat([cb]));
      }
    });
  };
}
Connection.prototype.error = function(err, callback) {
  if (callback) {
    callback(err);
    return null;
  }
  if (this.listeners('error').length > 0) {
    this.emit('error', err);
  }
  return Promise.reject(err);
};
Connection.prototype.onOpen = function() {
  this.readyState = STATES.connected;
  for (const i in this.collections) {
    if (utils.object.hasOwnProperty(this.collections, i)) {
      this.collections[i].onOpen();
    }
  }
  this.emit('open');
};
Connection.prototype.openUri = function(uri, options, callback) {
  this.readyState = STATES.connecting;
  this._closeCalled = false;
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (['string', 'number'].indexOf(typeof options) !== -1) {
    throw new MongooseError('Mongoose 5.x no longer supports ' +
      '`mongoose.connect(host, dbname, port)` or ' +
      '`mongoose.createConnection(host, dbname, port)`. See ' +
      'http:
  }
  if (typeof uri !== 'string') {
    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +
      `string, got "${typeof uri}". Make sure the first parameter to ` +
      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');
  }
  const Promise = PromiseProvider.get();
  const _this = this;
  if (options) {
    options = utils.clone(options);
    const autoIndex = options.config && options.config.autoIndex != null ?
      options.config.autoIndex :
      options.autoIndex;
    if (autoIndex != null) {
      this.config.autoIndex = autoIndex !== false;
      delete options.config;
      delete options.autoIndex;
    }
    if ('autoCreate' in options) {
      this.config.autoCreate = !!options.autoCreate;
      delete options.autoCreate;
    }
    if ('useCreateIndex' in options) {
      this.config.useCreateIndex = !!options.useCreateIndex;
      delete options.useCreateIndex;
    }
    if ('useFindAndModify' in options) {
      this.config.useFindAndModify = !!options.useFindAndModify;
      delete options.useFindAndModify;
    }
    if (options.user || options.pass) {
      options.auth = options.auth || {};
      options.auth.user = options.user;
      options.auth.password = options.pass;
      this.user = options.user;
      this.pass = options.pass;
    }
    delete options.user;
    delete options.pass;
    if (options.bufferCommands != null) {
      options.bufferMaxEntries = 0;
      this.config.bufferCommands = options.bufferCommands;
      delete options.bufferCommands;
    }
    if (options.useMongoClient != null) {
      handleUseMongoClient(options);
    }
  } else {
    options = {};
  }
  this._connectionOptions = options;
  const dbName = options.dbName;
  if (dbName != null) {
    this.$dbName = dbName;
  }
  delete options.dbName;
  if (!('promiseLibrary' in options)) {
    options.promiseLibrary = PromiseProvider.get();
  }
  if (!('useNewUrlParser' in options)) {
    if ('useNewUrlParser' in this.base.options) {
      options.useNewUrlParser = this.base.options.useNewUrlParser;
    } else {
      options.useNewUrlParser = false;
    }
  }
  const parsePromise = new Promise((resolve, reject) => {
    parseConnectionString(uri, options, (err, parsed) => {
      if (err) {
        return reject(err);
      }
      this.name = dbName != null ? dbName : get(parsed, 'auth.db', null);
      this.host = get(parsed, 'hosts.0.host', 'localhost');
      this.port = get(parsed, 'hosts.0.port', 27017);
      this.user = this.user || get(parsed, 'auth.username');
      this.pass = this.pass || get(parsed, 'auth.password');
      resolve();
    });
  });
  const promise = new Promise((resolve, reject) => {
    const client = new mongodb.MongoClient(uri, options);
    _this.client = client;
    client.connect(function(error) {
      if (error) {
        _this.readyState = STATES.disconnected;
        return reject(error);
      }
      const db = dbName != null ? client.db(dbName) : client.db();
      _this.db = db;
      db.on('reconnect', function() {
        if (_this.readyState !== STATES.connected) {
          _this.readyState = STATES.connected;
          _this.emit('reconnect');
          _this.emit('reconnected');
        }
      });
      db.s.topology.on('reconnectFailed', function() {
        _this.emit('reconnectFailed');
      });
      db.s.topology.on('left', function(data) {
        _this.emit('left', data);
      });
      db.s.topology.on('joined', function(data) {
        _this.emit('joined', data);
      });
      db.s.topology.on('fullsetup', function(data) {
        _this.emit('fullsetup', data);
      });
      db.on('close', function() {
        _this.readyState = STATES.disconnected;
      });
      client.on('left', function() {
        if (_this.readyState === STATES.connected &&
            get(db, 's.topology.s.coreTopology.s.replicaSetState.topologyType') === 'ReplicaSetNoPrimary') {
          _this.readyState = STATES.disconnected;
        }
      });
      db.on('timeout', function() {
        _this.emit('timeout');
      });
      delete _this.then;
      delete _this.catch;
      _this.readyState = STATES.connected;
      for (const i in _this.collections) {
        if (utils.object.hasOwnProperty(_this.collections, i)) {
          _this.collections[i].onOpen();
        }
      }
      resolve(_this);
      _this.emit('open');
    });
  });
  this.$initialConnection = Promise.all([promise, parsePromise]).
    then(res => res[0]).
    catch(err => {
      if (this.listeners('error').length > 0) {
        process.nextTick(() => this.emit('error', err));
      }
      throw err;
    });
  this.then = function(resolve, reject) {
    return this.$initialConnection.then(resolve, reject);
  };
  this.catch = function(reject) {
    return this.$initialConnection.catch(reject);
  };
  if (callback != null) {
    this.$initialConnection = this.$initialConnection.then(
      () => callback(null, this),
      err => callback(err)
    );
  }
  return this;
};
const handleUseMongoClient = function handleUseMongoClient(options) {
  console.warn('WARNING: The `useMongoClient` option is no longer ' +
    'necessary in mongoose 5.x, please remove it.');
  const stack = new Error().stack;
  console.warn(stack.substr(stack.indexOf('\n') + 1));
  delete options.useMongoClient;
};
Connection.prototype.close = function(force, callback) {
  if (typeof force === 'function') {
    callback = force;
    force = false;
  }
  this.$wasForceClosed = !!force;
  return utils.promiseOrCallback(callback, cb => {
    this._close(force, cb);
  });
};
Connection.prototype._close = function(force, callback) {
  const _this = this;
  this._closeCalled = true;
  switch (this.readyState) {
    case STATES.disconnected:
      callback();
      break;
    case STATES.connected:
      this.readyState = STATES.disconnecting;
      this.doClose(force, function(err) {
        if (err) {
          return callback(err);
        }
        _this.onClose(force);
        callback(null);
      });
      break;
    case STATES.connecting:
      this.once('open', function() {
        _this.close(callback);
      });
      break;
    case STATES.disconnecting:
      this.once('close', function() {
        callback();
      });
      break;
  }
  return this;
};
Connection.prototype.onClose = function(force) {
  this.readyState = STATES.disconnected;
  for (const i in this.collections) {
    if (utils.object.hasOwnProperty(this.collections, i)) {
      this.collections[i].onClose(force);
    }
  }
  this.emit('close', force);
};
Connection.prototype.collection = function(name, options) {
  options = options ? utils.clone(options) : {};
  options.$wasForceClosed = this.$wasForceClosed;
  if (!(name in this.collections)) {
    this.collections[name] = new Collection(name, this, options);
  }
  return this.collections[name];
};
Connection.prototype.plugin = function(fn, opts) {
  this.plugins.push([fn, opts]);
  return this;
};
Connection.prototype.model = function(name, schema, collection) {
  if (!(this instanceof Connection)) {
    throw new MongooseError('`connection.model()` should not be run with ' +
      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +
      '`db.model(foo)(bar)` instead');
  }
  let fn;
  if (typeof name === 'function') {
    fn = name;
    name = fn.name;
  }
  if (typeof schema === 'string') {
    collection = schema;
    schema = false;
  }
  if (utils.isObject(schema) && !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }
  if (schema && !schema.instanceOfSchema) {
    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
      'schema or a POJO');
  }
  if (this.models[name] && !collection) {
    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
      throw new MongooseError.OverwriteModelError(name);
    }
    return this.models[name];
  }
  const opts = {cache: false, connection: this};
  let model;
  if (schema && schema.instanceOfSchema) {
    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');
    model = this.base.model(fn || name, schema, collection, opts);
    if (!this.models[name]) {
      this.models[name] = model;
    }
    model.init(function $modelInitNoop() {});
    return model;
  }
  if (this.models[name] && collection) {
    model = this.models[name];
    schema = model.prototype.schema;
    const sub = model.__subclass(this, schema, collection);
    return sub;
  }
  model = this.base.models[name];
  if (!model) {
    throw new MongooseError.MissingSchemaError(name);
  }
  if (this === model.prototype.db
      && (!collection || collection === model.collection.name)) {
    if (!this.models[name]) {
      this.models[name] = model;
    }
    return model;
  }
  this.models[name] = model.__subclass(this, schema, collection);
  return this.models[name];
};
Connection.prototype.deleteModel = function(name) {
  if (typeof name === 'string') {
    const model = this.model(name);
    if (model == null) {
      return this;
    }
    delete this.models[name];
    delete this.collections[model.collection.name];
    delete this.base.modelSchemas[name];
  } else if (name instanceof RegExp) {
    const pattern = name;
    const names = this.modelNames();
    for (const name of names) {
      if (pattern.test(name)) {
        this.deleteModel(name);
      }
    }
  } else {
    throw new Error('First parameter to `deleteModel()` must be a string ' +
      'or regexp, got "' + name + '"');
  }
  return this;
};
Connection.prototype.modelNames = function() {
  return Object.keys(this.models);
};
Connection.prototype.shouldAuthenticate = function() {
  return this.user != null &&
    (this.pass != null || this.authMechanismDoesNotRequirePassword());
};
Connection.prototype.authMechanismDoesNotRequirePassword = function() {
  if (this.options && this.options.auth) {
    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
  }
  return true;
};
Connection.prototype.optionsProvideAuthenticationData = function(options) {
  return (options) &&
      (options.user) &&
      ((options.pass) || this.authMechanismDoesNotRequirePassword());
};
Connection.STATES = STATES;
module.exports = Connection;
