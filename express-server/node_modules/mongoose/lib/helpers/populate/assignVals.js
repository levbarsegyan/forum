'use strict';
const assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');
const get = require('../get');
const getVirtual = require('./getVirtual');
const leanPopulateMap = require('./leanPopulateMap');
const mpath = require('mpath');
const sift = require('sift').default;
const utils = require('../../utils');
module.exports = function assignVals(o) {
  const userOptions = get(o, 'allOptions.options.options');
  const populateOptions = Object.assign({}, o.options, userOptions, {
    justOne: o.justOne
  });
  const originalIds = [].concat(o.rawIds);
  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
  const docs = o.docs;
  const rawIds = o.rawIds;
  const options = o.options;
  const count = o.count && o.isVirtual;
  function setValue(val) {
    if (count) {
      return val;
    }
    if (o.justOne === true && Array.isArray(val)) {
      return valueFilter(val[0], options, populateOptions);
    } else if (o.justOne === false && !Array.isArray(val)) {
      return valueFilter([val], options, populateOptions);
    }
    return valueFilter(val, options, populateOptions);
  }
  for (let i = 0; i < docs.length; ++i) {
    const existingVal = utils.getValue(o.path, docs[i]);
    if (existingVal == null && !getVirtual(o.originalModel.schema, o.path)) {
      continue;
    }
    let valueToSet;
    if (count) {
      valueToSet = numDocs(rawIds[i]);
    } else if (Array.isArray(o.match)) {
      valueToSet = Array.isArray(rawIds[i]) ?
        sift(o.match[i], rawIds[i]) :
        sift(o.match[i], [rawIds[i]])[0];
    } else {
      valueToSet = rawIds[i];
    }
    const originalSchema = o.originalModel.schema;
    const isDoc = get(docs[i], '$__', null) != null;
    let isMap = isDoc ?
      existingVal instanceof Map :
      utils.isPOJO(existingVal);
    isMap = isMap && get(originalSchema._getSchema(o.path), '$isSchemaMap');
    if (!o.isVirtual && isMap) {
      const _keys = existingVal instanceof Map ?
        Array.from(existingVal.keys()) :
        Object.keys(existingVal);
      valueToSet = valueToSet.reduce((cur, v, i) => {
        cur.set(_keys[i], v);
        return cur;
      }, new Map());
    }
    if (o.isVirtual && isDoc) {
      docs[i].populated(o.path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
      mpath.set(o.path, valueToSet, docs[i], setValue);
      continue;
    }
    const parts = o.path.split('.');
    let cur = docs[i];
    for (let j = 0; j < parts.length - 1; ++j) {
      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
        break;
      }
      if (cur[parts[j]] == null) {
        cur[parts[j]] = {};
      }
      cur = cur[parts[j]];
      if (typeof cur !== 'object') {
        return;
      }
    }
    if (docs[i].$__) {
      docs[i].populated(o.path, o.allIds[i], o.allOptions);
    }
    utils.setValue(o.path, valueToSet, docs[i], setValue, false);
  }
};
function numDocs(v) {
  if (Array.isArray(v)) {
    return v.length;
  }
  return v == null ? 0 : 1;
}
function valueFilter(val, assignmentOpts, populateOptions) {
  if (Array.isArray(val)) {
    const ret = [];
    const numValues = val.length;
    for (let i = 0; i < numValues; ++i) {
      const subdoc = val[i];
      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null)) {
        continue;
      }
      maybeRemoveId(subdoc, assignmentOpts);
      ret.push(subdoc);
      if (assignmentOpts.originalLimit &&
          ret.length >= assignmentOpts.originalLimit) {
        break;
      }
    }
    while (val.length > ret.length) {
      Array.prototype.pop.apply(val, []);
    }
    for (let i = 0; i < ret.length; ++i) {
      val[i] = ret[i];
    }
    return val;
  }
  if (isPopulatedObject(val)) {
    maybeRemoveId(val, assignmentOpts);
    return val;
  }
  if (val instanceof Map) {
    return val;
  }
  if (populateOptions.justOne === true) {
    return (val == null ? val : null);
  }
  if (populateOptions.justOne === false) {
    return [];
  }
  return val;
}
function maybeRemoveId(subdoc, assignmentOpts) {
  if (assignmentOpts.excludeId) {
    if (typeof subdoc.$__setValue === 'function') {
      delete subdoc._doc._id;
    } else {
      delete subdoc._id;
    }
  }
}
function isPopulatedObject(obj) {
  if (obj == null) {
    return false;
  }
  return Array.isArray(obj) ||
    obj.$isMongooseMap ||
    obj.$__ != null ||
    leanPopulateMap.has(obj);
}
