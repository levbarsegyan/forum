'use strict';
const Mixed = require('../../schema/mixed');
const get = require('../get');
const leanPopulateMap = require('./leanPopulateMap');
const mpath = require('mpath');
const populateModelSymbol = require('../symbols').populateModelSymbol;
module.exports = function getSchemaTypes(schema, doc, path) {
  const pathschema = schema.path(path);
  const topLevelDoc = doc;
  if (pathschema) {
    return pathschema;
  }
  function search(parts, schema, subdoc, nestedPath) {
    let p = parts.length + 1;
    let foundschema;
    let trypath;
    while (p--) {
      trypath = parts.slice(0, p).join('.');
      foundschema = schema.path(trypath);
      if (foundschema == null) {
        continue;
      }
      if (foundschema.caster) {
        if (foundschema.caster instanceof Mixed) {
          return foundschema.caster;
        }
        let schemas = null;
        if (doc != null && foundschema.schema != null && foundschema.schema.discriminators != null) {
          const discriminators = foundschema.schema.discriminators;
          const discriminatorKeyPath = trypath + '.' +
            foundschema.schema.options.discriminatorKey;
          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
          schemas = Object.keys(discriminators).
            reduce(function(cur, discriminator) {
              if (keys.indexOf(discriminator) !== -1) {
                cur.push(discriminators[discriminator]);
              }
              return cur;
            }, []);
        }
        if (p !== parts.length && foundschema.schema) {
          let ret;
          if (parts[p] === '$') {
            if (p + 1 === parts.length) {
              return foundschema;
            }
            ret = search(
              parts.slice(p + 1),
              schema,
              subdoc ? mpath.get(trypath, subdoc) : null,
              nestedPath.concat(parts.slice(0, p))
            );
            if (ret) {
              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
                !foundschema.schema.$isSingleNested;
            }
            return ret;
          }
          if (schemas != null && schemas.length > 0) {
            ret = [];
            for (let i = 0; i < schemas.length; ++i) {
              const _ret = search(
                parts.slice(p),
                schemas[i],
                subdoc ? mpath.get(trypath, subdoc) : null,
                nestedPath.concat(parts.slice(0, p))
              );
              if (_ret != null) {
                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray ||
                  !foundschema.schema.$isSingleNested;
                if (_ret.$isUnderneathDocArray) {
                  ret.$isUnderneathDocArray = true;
                }
                ret.push(_ret);
              }
            }
            return ret;
          } else {
            ret = search(
              parts.slice(p),
              foundschema.schema,
              subdoc ? mpath.get(trypath, subdoc) : null,
              nestedPath.concat(parts.slice(0, p))
            );
            if (ret) {
              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
                !foundschema.schema.$isSingleNested;
            }
            return ret;
          }
        } else if (p !== parts.length &&
            foundschema.$isMongooseArray &&
            foundschema.casterConstructor.$isMongooseArray) {
          let type = foundschema;
          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
            type = type.casterConstructor;
          }
          return search(
            parts.slice(p),
            type.schema,
            null,
            nestedPath.concat(parts.slice(0, p))
          );
        }
      }
      const fullPath = nestedPath.concat([trypath]).join('.');
      if (topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts.length) {
        const model = doc.$__.populated[fullPath].options[populateModelSymbol];
        if (model != null) {
          const ret = search(
            parts.slice(p),
            model.schema,
            subdoc ? mpath.get(trypath, subdoc) : null,
            nestedPath.concat(parts.slice(0, p))
          );
          if (ret) {
            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
              !model.schema.$isSingleNested;
          }
          return ret;
        }
      }
      const _val = get(topLevelDoc, trypath);
      if (_val != null) {
        const model = Array.isArray(_val) && _val.length > 0 ?
          leanPopulateMap.get(_val[0]) :
          leanPopulateMap.get(_val);
        const schema = model != null ? model.schema : null;
        if (schema != null) {
          const ret = search(
            parts.slice(p),
            schema,
            subdoc ? mpath.get(trypath, subdoc) : null,
            nestedPath.concat(parts.slice(0, p))
          );
          if (ret) {
            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
              !schema.$isSingleNested;
          }
          return ret;
        }
      }
      return foundschema;
    }
  }
  const parts = path.split('.');
  for (let i = 0; i < parts.length; ++i) {
    if (parts[i] === '$') {
      parts[i] = '0';
    }
  }
  return search(parts, schema, doc, []);
};
