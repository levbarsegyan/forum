'use strict';
const Binary = require('../driver').get().Binary;
const utils = require('../utils');
const Buffer = require('safe-buffer').Buffer;
const proto = Buffer.from('').constructor.prototype;
function MongooseBuffer(value, encode, offset) {
  const length = arguments.length;
  let val;
  if (length === 0 || arguments[0] === null || arguments[0] === undefined) {
    val = 0;
  } else {
    val = value;
  }
  let encoding;
  let path;
  let doc;
  if (Array.isArray(encode)) {
    path = encode[0];
    doc = encode[1];
  } else {
    encoding = encode;
  }
  let buf;
  if (typeof val === 'number' || val instanceof Number) {
    buf = Buffer.alloc(val);
  } else { 
    buf = Buffer.from(val, encoding, offset);
  }
  utils.decorate(buf, MongooseBuffer.mixin);
  buf.isMongooseBuffer = true;
  buf[MongooseBuffer.pathSymbol] = path;
  buf[parentSymbol] = doc;
  buf._subtype = 0;
  return buf;
}
const pathSymbol = Symbol.for('mongoose#Buffer#_path');
const parentSymbol = Symbol.for('mongoose#Buffer#_parent');
MongooseBuffer.pathSymbol = pathSymbol;
MongooseBuffer.mixin = {
  _subtype: undefined,
  _markModified: function() {
    const parent = this[parentSymbol];
    if (parent) {
      parent.markModified(this[MongooseBuffer.pathSymbol]);
    }
    return this;
  },
  write: function() {
    const written = proto.write.apply(this, arguments);
    if (written > 0) {
      this._markModified();
    }
    return written;
  },
  copy: function(target) {
    const ret = proto.copy.apply(this, arguments);
    if (target && target.isMongooseBuffer) {
      target._markModified();
    }
    return ret;
  }
};
(
  ('writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +
    'writeFloat writeDouble fill ' +
    'utf8Write binaryWrite asciiWrite set ' +
    'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +
    'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' + 'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE')
).split(' ').forEach(function(method) {
  if (!proto[method]) {
    return;
  }
  MongooseBuffer.mixin[method] = function() {
    const ret = proto[method].apply(this, arguments);
    this._markModified();
    return ret;
  };
});
MongooseBuffer.mixin.toObject = function(options) {
  const subtype = typeof options === 'number'
    ? options
    : (this._subtype || 0);
  return new Binary(Buffer.from(this), subtype);
};
MongooseBuffer.mixin.toBSON = function() {
  return new Binary(this, this._subtype || 0);
};
MongooseBuffer.mixin.equals = function(other) {
  if (!Buffer.isBuffer(other)) {
    return false;
  }
  if (this.length !== other.length) {
    return false;
  }
  for (let i = 0; i < this.length; ++i) {
    if (this[i] !== other[i]) {
      return false;
    }
  }
  return true;
};
MongooseBuffer.mixin.subtype = function(subtype) {
  if (typeof subtype !== 'number') {
    throw new TypeError('Invalid subtype. Expected a number');
  }
  if (this._subtype !== subtype) {
    this._markModified();
  }
  this._subtype = subtype;
};
MongooseBuffer.Binary = Binary;
module.exports = MongooseBuffer;
