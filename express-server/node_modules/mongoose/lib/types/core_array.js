'use strict';
const Document = require('../document');
const EmbeddedDocument = require('./embedded');
const ObjectId = require('./objectid');
const cleanModifiedSubpaths = require('../helpers/document/cleanModifiedSubpaths');
const get = require('../helpers/get');
const internalToObjectOptions = require('../options').internalToObjectOptions;
const utils = require('../utils');
const util = require('util');
const arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;
const arrayParentSymbol = require('../helpers/symbols').arrayParentSymbol;
const arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;
const arraySchemaSymbol = require('../helpers/symbols').arraySchemaSymbol;
const populateModelSymbol = require('../helpers/symbols').populateModelSymbol;
const _basePush = Array.prototype.push;
class CoreMongooseArray extends Array {
  get isMongooseArray() {
    return true;
  }
  $__getAtomics() {
    const ret = [];
    const keys = Object.keys(this[arrayAtomicsSymbol]);
    let i = keys.length;
    const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
    if (i === 0) {
      ret[0] = ['$set', this.toObject(opts)];
      return ret;
    }
    while (i--) {
      const op = keys[i];
      let val = this[arrayAtomicsSymbol][op];
      if (utils.isMongooseObject(val)) {
        val = val.toObject(opts);
      } else if (Array.isArray(val)) {
        val = this.toObject.call(val, opts);
      } else if (val != null && Array.isArray(val.$each)) {
        val.$each = this.toObject.call(val.$each, opts);
      } else if (val != null && typeof val.valueOf === 'function') {
        val = val.valueOf();
      }
      if (op === '$addToSet') {
        val = {$each: val};
      }
      ret.push([op, val]);
    }
    return ret;
  }
  $atomics() {
    return this[arrayAtomicsSymbol];
  }
  $parent() {
    return this[arrayParentSymbol];
  }
  $path() {
    return this[arrayPathSymbol];
  }
  $shift() {
    this._registerAtomic('$pop', -1);
    this._markModified();
    if (this._shifted) {
      return;
    }
    this._shifted = true;
    return [].shift.call(this);
  }
  $pop() {
    this._registerAtomic('$pop', 1);
    this._markModified();
    if (this._popped) {
      return;
    }
    this._popped = true;
    return [].pop.call(this);
  }
  $schema() {
    return this[arraySchemaSymbol];
  }
  _cast(value) {
    let populated = false;
    let Model;
    if (this[arrayParentSymbol]) {
      populated = this[arrayParentSymbol].populated(this[arrayPathSymbol], true);
    }
    if (populated && value !== null && value !== undefined) {
      Model = populated.options[populateModelSymbol];
      if (Buffer.isBuffer(value) ||
          value instanceof ObjectId || !utils.isObject(value)) {
        value = {_id: value};
      }
      const isDisc = value.schema && value.schema.discriminatorMapping &&
          value.schema.discriminatorMapping.key !== undefined;
      if (!isDisc) {
        value = new Model(value);
      }
      return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], true);
    }
    return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], false);
  }
  _mapCast(val, index) {
    return this._cast(val, this.length + index);
  }
  _markModified(elem, embeddedPath) {
    const parent = this[arrayParentSymbol];
    let dirtyPath;
    if (parent) {
      dirtyPath = this[arrayPathSymbol];
      if (arguments.length) {
        if (embeddedPath != null) {
          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;
        } else {
          dirtyPath = dirtyPath + '.' + elem;
        }
      }
      parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
    }
    return this;
  }
  _registerAtomic(op, val) {
    if (op === '$set') {
      this[arrayAtomicsSymbol] = {$set: val};
      cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
      this._markModified();
      return this;
    }
    const atomics = this[arrayAtomicsSymbol];
    if (op === '$pop' && !('$pop' in atomics)) {
      const _this = this;
      this[arrayParentSymbol].once('save', function() {
        _this._popped = _this._shifted = null;
      });
    }
    if (this[arrayAtomicsSymbol].$set ||
        Object.keys(atomics).length && !(op in atomics)) {
      this[arrayAtomicsSymbol] = {$set: this};
      return this;
    }
    let selector;
    if (op === '$pullAll' || op === '$addToSet') {
      atomics[op] || (atomics[op] = []);
      atomics[op] = atomics[op].concat(val);
    } else if (op === '$pullDocs') {
      const pullOp = atomics['$pull'] || (atomics['$pull'] = {});
      if (val[0] instanceof EmbeddedDocument) {
        selector = pullOp['$or'] || (pullOp['$or'] = []);
        Array.prototype.push.apply(selector, val.map(function(v) {
          return v.toObject({transform: false, virtuals: false});
        }));
      } else {
        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});
        selector['$in'] = selector['$in'].concat(val);
      }
    } else if (op === '$push') {
      atomics.$push = atomics.$push || { $each: [] };
      atomics.$push.$each = atomics.$push.$each.concat(val);
    } else {
      atomics[op] = val;
    }
    return this;
  }
  addToSet() {
    _checkManualPopulation(this, arguments);
    let values = [].map.call(arguments, this._mapCast, this);
    values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
    const added = [];
    let type = '';
    if (values[0] instanceof EmbeddedDocument) {
      type = 'doc';
    } else if (values[0] instanceof Date) {
      type = 'date';
    }
    values.forEach(function(v) {
      let found;
      const val = +v;
      switch (type) {
        case 'doc':
          found = this.some(function(doc) {
            return doc.equals(v);
          });
          break;
        case 'date':
          found = this.some(function(d) {
            return +d === val;
          });
          break;
        default:
          found = ~this.indexOf(v);
      }
      if (!found) {
        [].push.call(this, v);
        this._registerAtomic('$addToSet', v);
        this._markModified();
        [].push.call(added, v);
      }
    }, this);
    return added;
  }
  hasAtomics() {
    if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
      return 0;
    }
    return Object.keys(this[arrayAtomicsSymbol]).length;
  }
  includes(obj) {
    return this.indexOf(obj) !== -1;
  }
  indexOf(obj) {
    if (obj instanceof ObjectId) {
      obj = obj.toString();
    }
    for (let i = 0, len = this.length; i < len; ++i) {
      if (obj == this[i]) {
        return i;
      }
    }
    return -1;
  }
  inspect() {
    return JSON.stringify(this);
  }
  nonAtomicPush() {
    const values = [].map.call(arguments, this._mapCast, this);
    const ret = [].push.apply(this, values);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  }
  pop() {
    const ret = [].pop.call(this);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  }
  pull() {
    const values = [].map.call(arguments, this._cast, this);
    const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
    let i = cur.length;
    let mem;
    while (i--) {
      mem = cur[i];
      if (mem instanceof Document) {
        const some = values.some(function(v) {
          return mem.equals(v);
        });
        if (some) {
          [].splice.call(cur, i, 1);
        }
      } else if (~cur.indexOf.call(values, mem)) {
        [].splice.call(cur, i, 1);
      }
    }
    if (values[0] instanceof EmbeddedDocument) {
      this._registerAtomic('$pullDocs', values.map(function(v) {
        return v._id || v;
      }));
    } else {
      this._registerAtomic('$pullAll', values);
    }
    this._markModified();
    if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
      this._registerAtomic('$set', this);
    }
    return this;
  }
  push() {
    if (this[arraySchemaSymbol] == null) {
      return _basePush.apply(this, arguments);
    }
    _checkManualPopulation(this, arguments);
    let values = [].map.call(arguments, this._mapCast, this);
    values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol], undefined,
      undefined, { skipDocumentArrayCast: true });
    const ret = [].push.apply(this, values);
    this._registerAtomic('$push', values);
    this._markModified();
    return ret;
  }
  remove() {
    return this.pull.apply(this, arguments);
  }
  set(i, val) {
    const value = this._cast(val, i);
    this[i] = value;
    this._markModified(i);
    return this;
  }
  shift() {
    const ret = [].shift.call(this);
    this._registerAtomic('$set', this);
    this._markModified();
    return ret;
  }
  sort() {
    const ret = [].sort.apply(this, arguments);
    this._registerAtomic('$set', this);
    return ret;
  }
  splice() {
    let ret;
    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
    if (arguments.length) {
      const vals = [];
      for (let i = 0; i < arguments.length; ++i) {
        vals[i] = i < 2 ?
          arguments[i] :
          this._cast(arguments[i], arguments[0] + (i - 2));
      }
      ret = [].splice.apply(this, vals);
      this._registerAtomic('$set', this);
    }
    return ret;
  }
  toBSON() {
    return this.toObject(internalToObjectOptions);
  }
  toObject(options) {
    if (options && options.depopulate) {
      options = utils.clone(options);
      options._isNested = true;
      return this.map(function(doc) {
        return doc instanceof Document
          ? doc.toObject(options)
          : doc;
      });
    }
    return this.slice();
  }
  unshift() {
    _checkManualPopulation(this, arguments);
    let values = [].map.call(arguments, this._cast, this);
    values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
    [].unshift.apply(this, values);
    this._registerAtomic('$set', this);
    this._markModified();
    return this.length;
  }
}
if (util.inspect.custom) {
  CoreMongooseArray.prototype[util.inspect.custom] =
    CoreMongooseArray.prototype.inspect;
}
function _isAllSubdocs(docs, ref) {
  if (!ref) {
    return false;
  }
  for (let i = 0; i < docs.length; ++i) {
    const arg = docs[i];
    if (arg == null) {
      return false;
    }
    const model = arg.constructor;
    if (!(arg instanceof Document) ||
      (model.modelName !== ref && model.baseModelName !== ref)) {
      return false;
    }
  }
  return true;
}
function _checkManualPopulation(arr, docs) {
  const ref = arr == null ?
    null :
    get(arr[arraySchemaSymbol], 'caster.options.ref', null);
  if (arr.length === 0 &&
      docs.length > 0) {
    if (_isAllSubdocs(docs, ref)) {
      arr[arrayParentSymbol].populated(arr[arrayPathSymbol], [], {
        [populateModelSymbol]: docs[0].constructor
      });
    }
  }
}
module.exports = CoreMongooseArray;
