'use strict';
const checkEmbeddedDiscriminatorKeyProjection =
  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');
const get = require('./helpers/get');
const isDefiningProjection = require('./helpers/projection/isDefiningProjection');
const utils = require('./utils');
exports.preparePopulationOptions = function preparePopulationOptions(query, options) {
  const pop = utils.object.vals(query.options.populate);
  if (options.lean != null) {
    pop.
      filter(p => get(p, 'options.lean') == null).
      forEach(makeLean(options.lean));
  }
  return pop;
};
exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
  const pop = utils.object.vals(query._mongooseOptions.populate);
  if (options.lean != null) {
    pop.
      filter(p => get(p, 'options.lean') == null).
      forEach(makeLean(options.lean));
  }
  const session = get(query, 'options.session', null);
  if (session != null) {
    pop.forEach(path => {
      if (path.options == null) {
        path.options = { session: session };
        return;
      }
      if (!('session' in path.options)) {
        path.options.session = session;
      }
    });
  }
  const projection = query._fieldsForExec();
  pop.forEach(p => {
    p._queryProjection = projection;
  });
  return pop;
};
function getDiscriminatorByValue(model, value) {
  let discriminator = null;
  if (!model.discriminators) {
    return discriminator;
  }
  for (const name in model.discriminators) {
    const it = model.discriminators[name];
    if (
      it.schema &&
      it.schema.discriminatorMapping &&
      it.schema.discriminatorMapping.value == value
    ) {
      discriminator = it;
      break;
    }
  }
  return discriminator;
}
exports.getDiscriminatorByValue = getDiscriminatorByValue;
exports.createModel = function createModel(model, doc, fields, userProvidedFields) {
  model.hooks.execPreSync('createModel', doc);
  const discriminatorMapping = model.schema ?
    model.schema.discriminatorMapping :
    null;
  const key = discriminatorMapping && discriminatorMapping.isRoot ?
    discriminatorMapping.key :
    null;
  const value = doc[key];
  if (key && value && model.discriminators) {
    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);
    if (discriminator) {
      const _fields = utils.clone(userProvidedFields);
      exports.applyPaths(_fields, discriminator.schema);
      return new discriminator(undefined, _fields, true);
    }
  }
  return new model(undefined, fields, {
    skipId: true,
    isNew: false,
    willInit: true
  });
};
exports.applyPaths = function applyPaths(fields, schema) {
  let exclude;
  let keys;
  let ki;
  let field;
  if (fields) {
    keys = Object.keys(fields);
    ki = keys.length;
    while (ki--) {
      if (keys[ki][0] === '+') {
        continue;
      }
      field = fields[keys[ki]];
      if (!isDefiningProjection(field)) {
        continue;
      }
      exclude = field === 0;
      break;
    }
  }
  const selected = [];
  const excluded = [];
  const stack = [];
  const analyzePath = function(path, type) {
    const plusPath = '+' + path;
    const hasPlusPath = fields && plusPath in fields;
    if (hasPlusPath) {
      delete fields[plusPath];
    }
    if (typeof type.selected !== 'boolean') return;
    if (hasPlusPath) {
      delete fields[plusPath];
      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
        fields[path] = 1;
      }
      return;
    }
    const pieces = path.split('.');
    let cur = '';
    for (let i = 0; i < pieces.length; ++i) {
      cur += cur.length ? '.' + pieces[i] : pieces[i];
      if (excluded.indexOf(cur) !== -1) {
        return;
      }
    }
    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {
      let cur = '';
      for (let i = 0; i < pieces.length; ++i) {
        cur += (cur.length === 0 ? '' : '.') + pieces[i];
        const projection = get(fields, cur, false);
        if (projection && typeof projection !== 'object') {
          return;
        }
      }
    }
    (type.selected ? selected : excluded).push(path);
    return path;
  };
  analyzeSchema(schema);
  switch (exclude) {
    case true:
      for (let i = 0; i < excluded.length; ++i) {
        fields[excluded[i]] = 0;
      }
      break;
    case false:
      if (schema &&
          schema.paths['_id'] &&
          schema.paths['_id'].options &&
          schema.paths['_id'].options.select === false) {
        fields._id = 0;
      }
      for (let i = 0; i < selected.length; ++i) {
        fields[selected[i]] = 1;
      }
      break;
    case undefined:
      if (fields == null) {
        break;
      }
      for (const key of Object.keys(fields || {})) {
        if (key.startsWith('+')) {
          delete fields[key];
        }
      }
      for (let i = 0; i < excluded.length; ++i) {
        fields[excluded[i]] = 0;
      }
      break;
  }
  function analyzeSchema(schema, prefix) {
    prefix || (prefix = '');
    if (stack.indexOf(schema) !== -1) {
      return [];
    }
    stack.push(schema);
    const addedPaths = [];
    schema.eachPath(function(path, type) {
      if (prefix) path = prefix + '.' + path;
      const addedPath = analyzePath(path, type);
      if (addedPath != null) {
        addedPaths.push(addedPath);
      }
      if (type.schema) {
        const _addedPaths = analyzeSchema(type.schema, path);
        if (exclude === false) {
          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,
            selected, _addedPaths);
        }
      }
    });
    stack.pop();
    return addedPaths;
  }
};
function makeLean(val) {
  return function(option) {
    option.options || (option.options = {});
    option.options.lean = val;
  };
}
exports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {
  return function _handleDeleteWriteOpResult(error, res) {
    if (error) {
      return callback(error);
    }
    const mongooseResult = Object.assign({}, res.result);
    if (get(res, 'result.n', null) != null) {
      mongooseResult.deletedCount = res.result.n;
    }
    if (res.deletedCount != null) {
      mongooseResult.deletedCount = res.deletedCount;
    }
    return callback(null, mongooseResult);
  };
};
