'use strict';
const MongooseConnection = require('../../connection');
const STATES = require('../../connectionstate');
function NativeConnection() {
  MongooseConnection.apply(this, arguments);
  this._listening = false;
}
NativeConnection.STATES = STATES;
NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
NativeConnection.prototype.useDb = function(name, options) {
  if (options && options.useCache && this.relatedDbs[name]) {
    return this.relatedDbs[name];
  }
  const newConn = new this.constructor();
  newConn.name = name;
  newConn.base = this.base;
  newConn.collections = {};
  newConn.models = {};
  newConn.replica = this.replica;
  newConn.name = this.name;
  newConn.options = this.options;
  newConn._readyState = this._readyState;
  newConn._closeCalled = this._closeCalled;
  newConn._hasOpened = this._hasOpened;
  newConn._listening = false;
  newConn.host = this.host;
  newConn.port = this.port;
  newConn.user = this.user;
  newConn.pass = this.pass;
  const _this = this;
  newConn.client = _this.client;
  if (this.db && this._readyState === STATES.connected) {
    wireup();
  } else {
    this.once('connected', wireup);
  }
  function wireup() {
    newConn.client = _this.client;
    newConn.db = _this.client.db(name);
    newConn.onOpen();
    listen(newConn);
  }
  newConn.name = name;
  this.otherDbs.push(newConn);
  newConn.otherDbs.push(this);
  if (options && options.useCache) {
    this.relatedDbs[newConn.name] = newConn;
    newConn.relatedDbs = this.relatedDbs;
  }
  return newConn;
};
function listen(conn) {
  if (conn.db._listening) {
    return;
  }
  conn.db._listening = true;
  conn.db.on('close', function(force) {
    if (conn._closeCalled) return;
    if (conn.db.serverConfig.autoReconnect) {
      conn.readyState = STATES.disconnected;
      conn.emit('close');
      return;
    }
    conn.onClose(force);
  });
  conn.db.on('error', function(err) {
    conn.emit('error', err);
  });
  conn.db.on('reconnect', function() {
    conn.readyState = STATES.connected;
    conn.emit('reconnect');
    conn.emit('reconnected');
    conn.onOpen();
  });
  conn.db.on('timeout', function(err) {
    conn.emit('timeout', err);
  });
  conn.db.on('open', function(err, db) {
    if (STATES.disconnected === conn.readyState && db && db.databaseName) {
      conn.readyState = STATES.connected;
      conn.emit('reconnect');
      conn.emit('reconnected');
    }
  });
  conn.db.on('parseError', function(err) {
    conn.emit('parseError', err);
  });
}
NativeConnection.prototype.doClose = function(force, fn) {
  this.client.close(force, (err, res) => {
    setTimeout(() => fn(err, res), 1);
  });
  return this;
};
module.exports = NativeConnection;
