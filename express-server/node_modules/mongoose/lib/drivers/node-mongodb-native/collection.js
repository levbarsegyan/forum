'use strict';
const MongooseCollection = require('../../collection');
const Collection = require('mongodb').Collection;
const get = require('../../helpers/get');
const sliced = require('sliced');
const stream = require('stream');
const util = require('util');
function NativeCollection(name, options) {
  this.collection = null;
  this.Promise = options.Promise || Promise;
  MongooseCollection.apply(this, arguments);
}
NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
NativeCollection.prototype.onOpen = function() {
  const _this = this;
  if (!_this.opts.capped.size) {
    callback(null, _this.conn.db.collection(_this.name));
    return _this.collection;
  }
  return _this.conn.db.collection(_this.name, function(err, c) {
    if (err) return callback(err);
    _this.conn.db.listCollections({name: _this.name}).toArray(function(err, docs) {
      if (err) {
        return callback(err);
      }
      const doc = docs[0];
      const exists = !!doc;
      if (exists) {
        if (doc.options && doc.options.capped) {
          callback(null, c);
        } else {
          const msg = 'A non-capped collection exists with the name: ' + _this.name + '\n\n'
              + ' To use this collection as a capped collection, please '
              + 'first convert it.\n'
              + ' http:
          err = new Error(msg);
          callback(err);
        }
      } else {
        const opts = Object.assign({}, _this.opts.capped);
        opts.capped = true;
        _this.conn.db.createCollection(_this.name, opts, callback);
      }
    });
  });
  function callback(err, collection) {
    if (err) {
      _this.conn.emit('error', err);
    } else {
      _this.collection = collection;
      MongooseCollection.prototype.onOpen.call(_this);
    }
  }
};
NativeCollection.prototype.onClose = function(force) {
  MongooseCollection.prototype.onClose.call(this, force);
};
const syncCollectionMethods = { watch: true };
function iter(i) {
  NativeCollection.prototype[i] = function() {
    const collection = this.collection;
    const args = Array.from(arguments);
    const _this = this;
    const debug = get(_this, 'conn.base.options.debug');
    const lastArg = arguments[arguments.length - 1];
    if (this.opts.$wasForceClosed) {
      return this.conn.db.collection(this.name)[i].apply(collection, args);
    }
    if (this.buffer) {
      if (syncCollectionMethods[i]) {
        throw new Error('Collection method ' + i + ' is synchronous');
      }
      if (typeof lastArg === 'function') {
        this.addQueue(i, args);
        return;
      }
      return new this.Promise((resolve, reject) => {
        this.addQueue(i, [].concat(args).concat([(err, res) => {
          if (err != null) {
            return reject(err);
          }
          resolve(res);
        }]));
      });
    }
    if (debug) {
      if (typeof debug === 'function') {
        debug.apply(_this,
          [_this.name, i].concat(sliced(args, 0, args.length - 1)));
      } else if (debug instanceof stream.Writable) {
        this.$printToStream(_this.name, i, args, debug);
      } else {
        this.$print(_this.name, i, args, typeof debug.color === 'undefined' ? true : debug.color);
      }
    }
    try {
      return collection[i].apply(collection, args);
    } catch (error) {
      if (args.length > 0 &&
          typeof args[args.length - 1] === 'function') {
        args[args.length - 1](error);
      } else {
        throw error;
      }
    }
  };
}
for (const i in Collection.prototype) {
  try {
    if (typeof Collection.prototype[i] !== 'function') {
      continue;
    }
  } catch (e) {
    continue;
  }
  iter(i);
}
NativeCollection.prototype.$print = function(name, i, args, color) {
  const moduleName = color ? '\x1B[0;36mMongoose:\x1B[0m ' : 'Mongoose: ';
  const functionCall = [name, i].join('.');
  const _args = [];
  for (let j = args.length - 1; j >= 0; --j) {
    if (this.$format(args[j]) || _args.length) {
      _args.unshift(this.$format(args[j], color));
    }
  }
  const params = '(' + _args.join(', ') + ')';
  console.info(moduleName + functionCall + params);
};
NativeCollection.prototype.$printToStream = function(name, i, args, stream) {
  const functionCall = [name, i].join('.');
  const _args = [];
  for (let j = args.length - 1; j >= 0; --j) {
    if (this.$format(args[j]) || _args.length) {
      _args.unshift(this.$format(args[j]));
    }
  }
  const params = '(' + _args.join(', ') + ')';
  stream.write(functionCall + params, 'utf8');
};
NativeCollection.prototype.$format = function(arg, color) {
  const type = typeof arg;
  if (type === 'function' || type === 'undefined') return '';
  return format(arg, false, color);
};
function inspectable(representation) {
  const ret = {
    inspect: function() { return representation; },
  };
  if (util.inspect.custom) {
    ret[util.inspect.custom] = ret.inspect;
  }
  return ret;
}
function map(o) {
  return format(o, true);
}
function formatObjectId(x, key) {
  x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
}
function formatDate(x, key) {
  x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
}
function format(obj, sub, color) {
  if (obj && typeof obj.toBSON === 'function') {
    obj = obj.toBSON();
  }
  if (obj == null) {
    return obj;
  }
  let x = require('../../utils').clone(obj, {transform: false});
  if (x.constructor.name === 'Binary') {
    x = 'BinData(' + x.sub_type + ', "' + x.toString('base64') + '")';
  } else if (x.constructor.name === 'ObjectID') {
    x = inspectable('ObjectId("' + x.toHexString() + '")');
  } else if (x.constructor.name === 'Date') {
    x = inspectable('new Date("' + x.toUTCString() + '")');
  } else if (x.constructor.name === 'Object') {
    const keys = Object.keys(x);
    const numKeys = keys.length;
    let key;
    for (let i = 0; i < numKeys; ++i) {
      key = keys[i];
      if (x[key]) {
        let error;
        if (typeof x[key].toBSON === 'function') {
          try {
            x[key] = x[key].toBSON();
          } catch (_error) {
            error = _error;
          }
        }
        if (x[key].constructor.name === 'Binary') {
          x[key] = 'BinData(' + x[key].sub_type + ', "' +
            x[key].buffer.toString('base64') + '")';
        } else if (x[key].constructor.name === 'Object') {
          x[key] = format(x[key], true);
        } else if (x[key].constructor.name === 'ObjectID') {
          formatObjectId(x, key);
        } else if (x[key].constructor.name === 'Date') {
          formatDate(x, key);
        } else if (x[key].constructor.name === 'ClientSession') {
          x[key] = inspectable('ClientSession("' +
            get(x[key], 'id.id.buffer', '').toString('hex') + '")');
        } else if (Array.isArray(x[key])) {
          x[key] = x[key].map(map);
        } else if (error != null) {
          throw error;
        }
      }
    }
  }
  if (sub) {
    return x;
  }
  return util.
    inspect(x, false, 10, color).
    replace(/\n/g, '').
    replace(/\s{2,}/g, ' ');
}
NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
module.exports = NativeCollection;
