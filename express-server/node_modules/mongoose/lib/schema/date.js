'use strict';
const MongooseError = require('../error/index');
const castDate = require('../cast/date');
const utils = require('../utils');
const SchemaType = require('../schematype');
const CastError = SchemaType.CastError;
function SchemaDate(key, options) {
  SchemaType.call(this, key, options, 'Date');
}
SchemaDate.schemaName = 'Date';
SchemaDate.prototype = Object.create(SchemaType.prototype);
SchemaDate.prototype.constructor = SchemaDate;
SchemaDate._cast = castDate;
SchemaDate.cast = function cast(caster) {
  if (arguments.length === 0) {
    return this._cast;
  }
  if (caster === false) {
    caster = v => {
      if (v != null && !(v instanceof Date)) {
        throw new Error();
      }
      return v;
    };
  }
  this._cast = caster;
  return this._cast;
};
SchemaDate.prototype.expires = function(when) {
  if (!this._index || this._index.constructor.name !== 'Object') {
    this._index = {};
  }
  this._index.expires = when;
  utils.expires(this._index);
  return this;
};
SchemaDate._checkRequired = v => v instanceof Date;
SchemaDate.checkRequired = SchemaType.checkRequired;
SchemaDate.prototype.checkRequired = function(value, doc) {
  if (SchemaType._isRef(this, value, doc, true)) {
    return !!value;
  }
  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?
    this.constructor.checkRequired() :
    SchemaDate.checkRequired();
  return _checkRequired(value);
};
SchemaDate.prototype.min = function(value, message) {
  if (this.minValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.minValidator;
    }, this);
  }
  if (value) {
    let msg = message || MongooseError.messages.Date.min;
    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));
    const _this = this;
    this.validators.push({
      validator: this.minValidator = function(val) {
        let _value = value;
        if (typeof value === 'function' && value !== Date.now) {
          _value = _value.call(this);
        }
        const min = (_value === Date.now ? _value() : _this.cast(_value));
        return val === null || val.valueOf() >= min.valueOf();
      },
      message: msg,
      type: 'min',
      min: value
    });
  }
  return this;
};
SchemaDate.prototype.max = function(value, message) {
  if (this.maxValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.maxValidator;
    }, this);
  }
  if (value) {
    let msg = message || MongooseError.messages.Date.max;
    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));
    const _this = this;
    this.validators.push({
      validator: this.maxValidator = function(val) {
        let _value = value;
        if (typeof _value === 'function' && _value !== Date.now) {
          _value = _value.call(this);
        }
        const max = (_value === Date.now ? _value() : _this.cast(_value));
        return val === null || val.valueOf() <= max.valueOf();
      },
      message: msg,
      type: 'max',
      max: value
    });
  }
  return this;
};
SchemaDate.prototype.cast = function(value) {
  const castDate = typeof this.constructor.cast === 'function' ?
    this.constructor.cast() :
    SchemaDate.cast();
  try {
    return castDate(value);
  } catch (error) {
    throw new CastError('date', value, this.path);
  }
};
function handleSingle(val) {
  return this.cast(val);
}
SchemaDate.prototype.$conditionalHandlers =
    utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
SchemaDate.prototype.castForQuery = function($conditional, val) {
  if (arguments.length !== 2) {
    return this._castForQuery($conditional);
  }
  const handler = this.$conditionalHandlers[$conditional];
  if (!handler) {
    throw new Error('Can\'t use ' + $conditional + ' with Date.');
  }
  return handler.call(this, val);
};
module.exports = SchemaDate;
