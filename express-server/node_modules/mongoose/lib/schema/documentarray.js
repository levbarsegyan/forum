'use strict';
const ArrayType = require('./array');
const CastError = require('../error/cast');
const EventEmitter = require('events').EventEmitter;
const SchemaType = require('../schematype');
const discriminator = require('../helpers/model/discriminator');
const util = require('util');
const utils = require('../utils');
const getConstructor = require('../helpers/discriminator/getConstructor');
const arrayParentSymbol = require('../helpers/symbols').arrayParentSymbol;
const arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;
let MongooseDocumentArray;
let Subdocument;
function DocumentArray(key, schema, options, schemaOptions) {
  const EmbeddedDocument = _createConstructor(schema, options);
  EmbeddedDocument.prototype.$basePath = key;
  ArrayType.call(this, key, EmbeddedDocument, options);
  this.schema = schema;
  this.schemaOptions = schemaOptions || {};
  this.$isMongooseDocumentArray = true;
  this.Constructor = EmbeddedDocument;
  EmbeddedDocument.base = schema.base;
  const fn = this.defaultValue;
  if (!('defaultValue' in this) || fn !== void 0) {
    this.default(function() {
      let arr = fn.call(this);
      if (!Array.isArray(arr)) {
        arr = [arr];
      }
      return arr;
    });
  }
}
DocumentArray.schemaName = 'DocumentArray';
DocumentArray.options = { castNonArrays: true };
DocumentArray.prototype = Object.create(ArrayType.prototype);
DocumentArray.prototype.constructor = DocumentArray;
function _createConstructor(schema, options, baseClass) {
  Subdocument || (Subdocument = require('../types/embedded'));
  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);
    this.$session(this.ownerDocument().$session());
  }
  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
  EmbeddedDocument.prototype = Object.create(proto);
  EmbeddedDocument.prototype.$__setSchema(schema);
  EmbeddedDocument.schema = schema;
  EmbeddedDocument.prototype.constructor = EmbeddedDocument;
  EmbeddedDocument.$isArraySubdocument = true;
  EmbeddedDocument.events = new EventEmitter();
  for (const i in schema.methods) {
    EmbeddedDocument.prototype[i] = schema.methods[i];
  }
  for (const i in schema.statics) {
    EmbeddedDocument[i] = schema.statics[i];
  }
  for (const i in EventEmitter.prototype) {
    EmbeddedDocument[i] = EventEmitter.prototype[i];
  }
  EmbeddedDocument.options = options;
  return EmbeddedDocument;
}
DocumentArray.prototype.discriminator = function(name, schema) {
  if (typeof name === 'function') {
    name = utils.getFunctionName(name);
  }
  schema = discriminator(this.casterConstructor, name, schema);
  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
  try {
    Object.defineProperty(EmbeddedDocument, 'name', {
      value: name
    });
  } catch (error) {
  }
  this.casterConstructor.discriminators[name] = EmbeddedDocument;
  return this.casterConstructor.discriminators[name];
};
DocumentArray.prototype.doValidate = function(array, fn, scope, options) {
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));
  const _this = this;
  try {
    SchemaType.prototype.doValidate.call(this, array, cb, scope);
  } catch (err) {
    err.$isArrayValidatorError = true;
    return fn(err);
  }
  function cb(err) {
    if (err) {
      err.$isArrayValidatorError = true;
      return fn(err);
    }
    let count = array && array.length;
    let error;
    if (!count) {
      return fn();
    }
    if (options && options.updateValidator) {
      return fn();
    }
    if (!array.isMongooseDocumentArray) {
      array = new MongooseDocumentArray(array, _this.path, scope);
    }
    function callback(err) {
      if (err != null) {
        error = err;
        if (error.name !== 'ValidationError') {
          error.$isArrayValidatorError = true;
        }
      }
      --count || fn(error);
    }
    for (let i = 0, len = count; i < len; ++i) {
      let doc = array[i];
      if (doc == null) {
        --count || fn(error);
        continue;
      }
      if (!(doc instanceof Subdocument)) {
        const Constructor = getConstructor(_this.casterConstructor, array[i]);
        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
      }
      doc.$__validate(callback);
    }
  }
};
DocumentArray.prototype.doValidateSync = function(array, scope) {
  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
  if (schemaTypeError != null) {
    schemaTypeError.$isArrayValidatorError = true;
    return schemaTypeError;
  }
  const count = array && array.length;
  let resultError = null;
  if (!count) {
    return;
  }
  for (let i = 0, len = count; i < len; ++i) {
    let doc = array[i];
    if (!doc) {
      continue;
    }
    if (!(doc instanceof Subdocument)) {
      const Constructor = getConstructor(this.casterConstructor, array[i]);
      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
    }
    const subdocValidateError = doc.validateSync();
    if (subdocValidateError && resultError == null) {
      resultError = subdocValidateError;
    }
  }
  return resultError;
};
DocumentArray.prototype.getDefault = function(scope) {
  let ret = typeof this.defaultValue === 'function'
    ? this.defaultValue.call(scope)
    : this.defaultValue;
  if (ret == null) {
    return ret;
  }
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));
  if (!Array.isArray(ret)) {
    ret = [ret];
  }
  ret = new MongooseDocumentArray(ret, this.path, scope);
  const _parent = ret[arrayParentSymbol];
  ret[arrayParentSymbol] = null;
  for (let i = 0; i < ret.length; ++i) {
    const Constructor = getConstructor(this.casterConstructor, ret[i]);
    ret[i] = new Constructor(ret[i], ret, undefined,
      undefined, i);
  }
  ret[arrayParentSymbol] = _parent;
  return ret;
};
DocumentArray.prototype.cast = function(value, doc, init, prev, options) {
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));
  let selected;
  let subdoc;
  let i;
  const _opts = { transform: false, virtuals: false };
  if (!Array.isArray(value)) {
    if (!init && !DocumentArray.options.castNonArrays) {
      throw new CastError('DocumentArray', util.inspect(value), this.path);
    }
    if (!!doc && init) {
      doc.markModified(this.path);
    }
    return this.cast([value], doc, init, prev);
  }
  if (!(value && value.isMongooseDocumentArray) &&
      (!options || !options.skipDocumentArrayCast)) {
    value = new MongooseDocumentArray(value, this.path, doc);
    _clearListeners(prev);
  } else if (value && value.isMongooseDocumentArray) {
    value = new MongooseDocumentArray(value, this.path, doc);
  }
  i = value.length;
  while (i--) {
    if (!value[i]) {
      continue;
    }
    const Constructor = getConstructor(this.casterConstructor, value[i]);
    if ((value[i].$__) &&
        !(value[i] instanceof Constructor)) {
      value[i] = value[i].toObject({
        transform: false,
        virtuals: value[i].schema === Constructor.schema
      });
    }
    if (value[i] instanceof Subdocument) {
      if (value[i].__index == null) {
        value[i].$setIndex(i);
      }
    } else if (value[i] != null) {
      if (init) {
        if (doc) {
          selected || (selected = scopePaths(this, doc.$__.selected, init));
        } else {
          selected = true;
        }
        subdoc = new Constructor(null, value, true, selected, i);
        value[i] = subdoc.init(value[i]);
      } else {
        if (prev && typeof prev.id === 'function') {
          subdoc = prev.id(value[i]._id);
        }
        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {
          subdoc.set(value[i]);
          value[i] = subdoc;
        } else {
          try {
            subdoc = new Constructor(value[i], value, undefined,
              undefined, i);
            value[i] = subdoc;
          } catch (error) {
            _clearListeners(value);
            const valueInErrorMessage = util.inspect(value[i]);
            throw new CastError('embedded', valueInErrorMessage,
              value[arrayPathSymbol], error);
          }
        }
      }
    }
  }
  return value;
};
DocumentArray.prototype.clone = function() {
  const options = Object.assign({}, this.options);
  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
  schematype.validators = this.validators.slice();
  schematype.Constructor.discriminators = Object.assign({},
    this.Constructor.discriminators);
  return schematype;
};
function _clearListeners(arr) {
  if (arr == null || arr[arrayParentSymbol] == null) {
    return;
  }
  for (const key in arr._handlers) {
    arr[arrayParentSymbol].removeListener(key, arr._handlers[key]);
  }
}
function scopePaths(array, fields, init) {
  if (!(init && fields)) {
    return undefined;
  }
  const path = array.path + '.';
  const keys = Object.keys(fields);
  let i = keys.length;
  const selected = {};
  let hasKeys;
  let key;
  let sub;
  while (i--) {
    key = keys[i];
    if (key.startsWith(path)) {
      sub = key.substring(path.length);
      if (sub === '$') {
        continue;
      }
      if (sub.startsWith('$.')) {
        sub = sub.substr(2);
      }
      hasKeys || (hasKeys = true);
      selected[sub] = fields[key];
    }
  }
  return hasKeys && selected || undefined;
}
module.exports = DocumentArray;
