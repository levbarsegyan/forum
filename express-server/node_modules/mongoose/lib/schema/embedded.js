'use strict';
const CastError = require('../error/cast');
const EventEmitter = require('events').EventEmitter;
const ObjectExpectedError = require('../error/objectExpected');
const SchemaType = require('../schematype');
const $exists = require('./operators/exists');
const castToNumber = require('./operators/helpers').castToNumber;
const discriminator = require('../helpers/model/discriminator');
const geospatial = require('./operators/geospatial');
const get = require('../helpers/get');
const getConstructor = require('../helpers/discriminator/getConstructor');
const internalToObjectOptions = require('../options').internalToObjectOptions;
let Subdocument;
module.exports = Embedded;
function Embedded(schema, path, options) {
  this.caster = _createConstructor(schema);
  this.caster.path = path;
  this.caster.prototype.$basePath = path;
  this.schema = schema;
  this.$isSingleNested = true;
  SchemaType.call(this, path, options, 'Embedded');
}
Embedded.prototype = Object.create(SchemaType.prototype);
Embedded.prototype.constructor = Embedded;
function _createConstructor(schema) {
  Subdocument || (Subdocument = require('../types/subdocument'));
  const _embedded = function SingleNested(value, path, parent) {
    const _this = this;
    this.$parent = parent;
    Subdocument.apply(this, arguments);
    this.$session(this.ownerDocument().$session());
    if (parent) {
      parent.on('save', function() {
        _this.emit('save', _this);
        _this.constructor.emit('save', _this);
      });
      parent.on('isNew', function(val) {
        _this.isNew = val;
        _this.emit('isNew', val);
        _this.constructor.emit('isNew', val);
      });
    }
  };
  _embedded.prototype = Object.create(Subdocument.prototype);
  _embedded.prototype.$__setSchema(schema);
  _embedded.prototype.constructor = _embedded;
  _embedded.schema = schema;
  _embedded.$isSingleNested = true;
  _embedded.events = new EventEmitter();
  _embedded.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  for (const i in schema.methods) {
    _embedded.prototype[i] = schema.methods[i];
  }
  for (const i in schema.statics) {
    _embedded[i] = schema.statics[i];
  }
  for (const i in EventEmitter.prototype) {
    _embedded[i] = EventEmitter.prototype[i];
  }
  return _embedded;
}
Embedded.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
  return { $geometry: this.castForQuery(val.$geometry) };
};
Embedded.prototype.$conditionalHandlers.$near =
Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
Embedded.prototype.$conditionalHandlers.$within =
Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
Embedded.prototype.$conditionalHandlers.$geoIntersects =
  geospatial.cast$geoIntersects;
Embedded.prototype.$conditionalHandlers.$minDistance = castToNumber;
Embedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;
Embedded.prototype.$conditionalHandlers.$exists = $exists;
Embedded.prototype.cast = function(val, doc, init, priorVal) {
  if (val && val.$isSingleNested) {
    return val;
  }
  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {
    throw new ObjectExpectedError(this.path, val);
  }
  const Constructor = getConstructor(this.caster, val);
  let subdoc;
  const parentSelected = get(doc, '$__.selected', {});
  const path = this.path;
  const selected = Object.keys(parentSelected).reduce((obj, key) => {
    if (key.startsWith(path + '.')) {
      obj[key.substr(path.length + 1)] = parentSelected[key];
    }
    return obj;
  }, {});
  if (init) {
    subdoc = new Constructor(void 0, selected, doc);
    subdoc.init(val);
  } else {
    if (Object.keys(val).length === 0) {
      return new Constructor({}, selected, doc);
    }
    return new Constructor(val, selected, doc, undefined, { priorDoc: priorVal });
  }
  return subdoc;
};
Embedded.prototype.castForQuery = function($conditional, val) {
  let handler;
  if (arguments.length === 2) {
    handler = this.$conditionalHandlers[$conditional];
    if (!handler) {
      throw new Error('Can\'t use ' + $conditional);
    }
    return handler.call(this, val);
  }
  val = $conditional;
  if (val == null) {
    return val;
  }
  if (this.options.runSetters) {
    val = this._applySetters(val);
  }
  const Constructor = getConstructor(this.caster, val);
  try {
    val = new Constructor(val);
  } catch (error) {
    if (!(error instanceof CastError)) {
      throw new CastError('Embedded', val, this.path, error);
    }
    throw error;
  }
  return val;
};
Embedded.prototype.doValidate = function(value, fn, scope, options) {
  const Constructor = getConstructor(this.caster, value);
  if (options && options.skipSchemaValidators) {
    if (!(value instanceof Constructor)) {
      value = new Constructor(value, null, scope);
    }
    return value.validate(fn);
  }
  SchemaType.prototype.doValidate.call(this, value, function(error) {
    if (error) {
      return fn(error);
    }
    if (!value) {
      return fn(null);
    }
    value.validate(fn);
  }, scope);
};
Embedded.prototype.doValidateSync = function(value, scope, options) {
  if (!options || !options.skipSchemaValidators) {
    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
    if (schemaTypeError) {
      return schemaTypeError;
    }
  }
  if (!value) {
    return;
  }
  return value.validateSync();
};
Embedded.prototype.discriminator = function(name, schema) {
  discriminator(this.caster, name, schema);
  this.caster.discriminators[name] = _createConstructor(schema);
  return this.caster.discriminators[name];
};
Embedded.prototype.clone = function() {
  const options = Object.assign({}, this.options);
  const schematype = new this.constructor(this.schema, this.path, options);
  schematype.validators = this.validators.slice();
  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
  return schematype;
};
