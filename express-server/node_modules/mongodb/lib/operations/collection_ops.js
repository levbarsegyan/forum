'use strict';
const applyWriteConcern = require('../utils').applyWriteConcern;
const applyRetryableWrites = require('../utils').applyRetryableWrites;
const checkCollectionName = require('../utils').checkCollectionName;
const Code = require('mongodb-core').BSON.Code;
const createIndexDb = require('./db_ops').createIndex;
const decorateCommand = require('../utils').decorateCommand;
const decorateWithCollation = require('../utils').decorateWithCollation;
const decorateWithReadConcern = require('../utils').decorateWithReadConcern;
const ensureIndexDb = require('./db_ops').ensureIndex;
const evaluate = require('./db_ops').evaluate;
const executeCommand = require('./db_ops').executeCommand;
const executeDbAdminCommand = require('./db_ops').executeDbAdminCommand;
const formattedOrderClause = require('../utils').formattedOrderClause;
const resolveReadPreference = require('../utils').resolveReadPreference;
const handleCallback = require('../utils').handleCallback;
const indexInformationDb = require('./db_ops').indexInformation;
const isObject = require('../utils').isObject;
const Long = require('mongodb-core').BSON.Long;
const MongoError = require('mongodb-core').MongoError;
const ReadPreference = require('mongodb-core').ReadPreference;
const toError = require('../utils').toError;
let collection;
function loadCollection() {
  if (!collection) {
    collection = require('../collection');
  }
  return collection;
}
let db;
function loadDb() {
  if (!db) {
    db = require('../db');
  }
  return db;
}
const groupFunction =
  'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
function bulkWrite(coll, operations, options, callback) {
  if (coll.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = coll.s.options.ignoreUndefined;
  }
  const bulk =
    options.ordered === true || options.ordered == null
      ? coll.initializeOrderedBulkOp(options)
      : coll.initializeUnorderedBulkOp(options);
  let collation = false;
  try {
    for (let i = 0; i < operations.length; i++) {
      const key = Object.keys(operations[i])[0];
      if (operations[i][key].collation) {
        collation = true;
      }
      bulk.raw(operations[i]);
    }
  } catch (err) {
    return callback(err, null);
  }
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
  const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
  const capabilities = coll.s.topology.capabilities();
  if (collation && capabilities && !capabilities.commandsTakeCollation) {
    return callback(new MongoError('server/primary/mongos does not support collation'));
  }
  bulk.execute(writeCon, finalOptions, (err, r) => {
    if (!r && err) {
      return callback(err, null);
    }
    r.insertedCount = r.nInserted;
    r.matchedCount = r.nMatched;
    r.modifiedCount = r.nModified || 0;
    r.deletedCount = r.nRemoved;
    r.upsertedCount = r.getUpsertedIds().length;
    r.upsertedIds = {};
    r.insertedIds = {};
    r.n = r.insertedCount;
    const inserted = r.getInsertedIds();
    for (let i = 0; i < inserted.length; i++) {
      r.insertedIds[inserted[i].index] = inserted[i]._id;
    }
    const upserted = r.getUpsertedIds();
    for (let i = 0; i < upserted.length; i++) {
      r.upsertedIds[upserted[i].index] = upserted[i]._id;
    }
    callback(null, r);
  });
}
function checkForAtomicOperators(update) {
  const keys = Object.keys(update);
  if (keys.length === 0) {
    return toError('The update operation document must contain at least one atomic operator.');
  }
  if (keys[0][0] !== '$') {
    return toError('the update operation document must contain atomic operators.');
  }
}
function count(coll, query, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);
  options.collectionName = coll.s.name;
  options.readPreference = resolveReadPreference(options, {
    db: coll.s.db,
    collection: coll
  });
  let cmd;
  try {
    cmd = buildCountCommand(coll, query, options);
  } catch (err) {
    return callback(err);
  }
  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.n);
  });
}
function countDocuments(coll, query, options, callback) {
  const skip = options.skip;
  const limit = options.limit;
  options = Object.assign({}, options);
  const pipeline = [{ $match: query }];
  if (typeof skip === 'number') {
    pipeline.push({ $skip: skip });
  }
  if (typeof limit === 'number') {
    pipeline.push({ $limit: limit });
  }
  pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
  delete options.limit;
  delete options.skip;
  coll.aggregate(pipeline, options).toArray((err, docs) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, docs.length ? docs[0].n : 0);
  });
}
function buildCountCommand(collectionOrCursor, query, options) {
  const skip = options.skip;
  const limit = options.limit;
  let hint = options.hint;
  const maxTimeMS = options.maxTimeMS;
  query = query || {};
  const cmd = {
    count: options.collectionName,
    query: query
  };
  if (collectionOrCursor.s.numberOfRetries) {
    if (collectionOrCursor.s.options.hint) {
      hint = collectionOrCursor.s.options.hint;
    } else if (collectionOrCursor.s.cmd.hint) {
      hint = collectionOrCursor.s.cmd.hint;
    }
    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.s.cmd);
  } else {
    decorateWithCollation(cmd, collectionOrCursor, options);
  }
  if (typeof skip === 'number') cmd.skip = skip;
  if (typeof limit === 'number') cmd.limit = limit;
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;
  if (hint) cmd.hint = hint;
  decorateWithReadConcern(cmd, collectionOrCursor);
  return cmd;
}
function createIndex(coll, fieldOrSpec, options, callback) {
  createIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);
}
function createIndexes(coll, indexSpecs, options, callback) {
  const capabilities = coll.s.topology.capabilities();
  for (let i = 0; i < indexSpecs.length; i++) {
    if (indexSpecs[i].name == null) {
      const keys = [];
      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
        return callback(new MongoError('server/primary/mongos does not support collation'));
      }
      for (let name in indexSpecs[i].key) {
        keys.push(`${name}_${indexSpecs[i].key[name]}`);
      }
      indexSpecs[i].name = keys.join('_');
    }
  }
  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
  executeCommand(
    coll.s.db,
    {
      createIndexes: coll.s.name,
      indexes: indexSpecs
    },
    options,
    callback
  );
}
function deleteCallback(err, r, callback) {
  if (callback == null) return;
  if (err && callback) return callback(err);
  if (r == null) return callback(null, { result: { ok: 1 } });
  r.deletedCount = r.result.n;
  if (callback) callback(null, r);
}
function deleteMany(coll, filter, options, callback) {
  options.single = false;
  removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
}
function deleteOne(coll, filter, options, callback) {
  options.single = true;
  removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
}
function distinct(coll, key, query, options, callback) {
  const maxTimeMS = options.maxTimeMS;
  const cmd = {
    distinct: coll.s.name,
    key: key,
    query: query
  };
  options = Object.assign({}, options);
  options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });
  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;
  decorateWithReadConcern(cmd, coll, options);
  try {
    decorateWithCollation(cmd, coll, options);
  } catch (err) {
    return callback(err, null);
  }
  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.values);
  });
}
function dropIndex(coll, indexName, options, callback) {
  const cmd = { dropIndexes: coll.s.name, index: indexName };
  applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options);
  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (typeof callback !== 'function') return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  });
}
function dropIndexes(coll, options, callback) {
  dropIndex(coll, '*', options, err => {
    if (err) return handleCallback(callback, err, false);
    handleCallback(callback, null, true);
  });
}
function ensureIndex(coll, fieldOrSpec, options, callback) {
  ensureIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);
}
function findAndModify(coll, query, sort, doc, options, callback) {
  const queryObject = {
    findAndModify: coll.s.name,
    query: query
  };
  sort = formattedOrderClause(sort);
  if (sort) {
    queryObject.sort = sort;
  }
  queryObject.new = options.new ? true : false;
  queryObject.remove = options.remove ? true : false;
  queryObject.upsert = options.upsert ? true : false;
  const projection = options.projection || options.fields;
  if (projection) {
    queryObject.fields = projection;
  }
  if (options.arrayFilters) {
    queryObject.arrayFilters = options.arrayFilters;
    delete options.arrayFilters;
  }
  if (doc && !options.remove) {
    queryObject.update = doc;
  }
  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;
  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
  options.checkKeys = false;
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
  if (finalOptions.writeConcern) {
    queryObject.writeConcern = finalOptions.writeConcern;
  }
  if (finalOptions.bypassDocumentValidation === true) {
    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
  }
  finalOptions.readPreference = ReadPreference.primary;
  try {
    decorateWithCollation(queryObject, coll, finalOptions);
  } catch (err) {
    return callback(err, null);
  }
  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
    if (err) return handleCallback(callback, err, null);
    return handleCallback(callback, null, result);
  });
}
function findAndRemove(coll, query, sort, options, callback) {
  options.remove = true;
  findAndModify(coll, query, sort, null, options, callback);
}
function findOne(coll, query, options, callback) {
  const cursor = coll
    .find(query, options)
    .limit(-1)
    .batchSize(1);
  cursor.next((err, item) => {
    if (err != null) return handleCallback(callback, toError(err), null);
    handleCallback(callback, null, item);
  });
}
function findOneAndDelete(coll, filter, options, callback) {
  const finalOptions = Object.assign({}, options);
  finalOptions.fields = options.projection;
  finalOptions.remove = true;
  findAndModify(coll, filter, options.sort, null, finalOptions, callback);
}
function findOneAndReplace(coll, filter, replacement, options, callback) {
  const finalOptions = Object.assign({}, options);
  finalOptions.fields = options.projection;
  finalOptions.update = true;
  finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
  finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false;
  findAndModify(coll, filter, options.sort, replacement, finalOptions, callback);
}
function findOneAndUpdate(coll, filter, update, options, callback) {
  const finalOptions = Object.assign({}, options);
  finalOptions.fields = options.projection;
  finalOptions.update = true;
  finalOptions.new = typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;
  finalOptions.upsert = typeof options.upsert === 'boolean' ? options.upsert : false;
  findAndModify(coll, filter, options.sort, update, finalOptions, callback);
}
function geoHaystackSearch(coll, x, y, options, callback) {
  let commandObject = {
    geoSearch: coll.s.name,
    near: [x, y]
  };
  commandObject = decorateCommand(commandObject, options, ['readPreference', 'session']);
  options = Object.assign({}, options);
  options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });
  decorateWithReadConcern(commandObject, coll, options);
  executeCommand(coll.s.db, commandObject, options, (err, res) => {
    if (err) return handleCallback(callback, err);
    if (res.err || res.errmsg) handleCallback(callback, toError(res));
    handleCallback(callback, null, res);
  });
}
function group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {
  if (command) {
    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);
    const selector = {
      group: {
        ns: coll.s.name,
        $reduce: reduceFunction,
        cond: condition,
        initial: initial,
        out: 'inline'
      }
    };
    if (finalize != null) selector.group['finalize'] = finalize;
    if ('function' === typeof keys || (keys && keys._bsontype === 'Code')) {
      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);
    } else {
      const hash = {};
      keys.forEach(key => {
        hash[key] = 1;
      });
      selector.group.key = hash;
    }
    options = Object.assign({}, options);
    options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });
    decorateWithReadConcern(selector, coll, options);
    try {
      decorateWithCollation(selector, coll, options);
    } catch (err) {
      return callback(err, null);
    }
    executeCommand(coll.s.db, selector, options, (err, result) => {
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, result.retval);
    });
  } else {
    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};
    scope.ns = coll.s.name;
    scope.keys = keys;
    scope.condition = condition;
    scope.initial = initial;
    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');
    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => {
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, results.result || results);
    });
  }
}
function indexes(coll, options, callback) {
  options = Object.assign({}, { full: true }, options);
  indexInformationDb(coll.s.db, coll.s.name, options, callback);
}
function indexExists(coll, indexes, options, callback) {
  indexInformation(coll, options, (err, indexInformation) => {
    if (err != null) return handleCallback(callback, err, null);
    if (!Array.isArray(indexes))
      return handleCallback(callback, null, indexInformation[indexes] != null);
    for (let i = 0; i < indexes.length; i++) {
      if (indexInformation[indexes[i]] == null) {
        return handleCallback(callback, null, false);
      }
    }
    return handleCallback(callback, null, true);
  });
}
function indexInformation(coll, options, callback) {
  indexInformationDb(coll.s.db, coll.s.name, options, callback);
}
function insertDocuments(coll, docs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  docs = Array.isArray(docs) ? docs : [docs];
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
  if (finalOptions.keepGoing === true) finalOptions.ordered = false;
  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
  docs = prepareDocs(coll, docs, options);
  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
    if (callback == null) return;
    if (err) return handleCallback(callback, err);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    result.ops = docs;
    handleCallback(callback, null, result);
  });
}
function insertOne(coll, doc, options, callback) {
  if (Array.isArray(doc)) {
    return callback(
      MongoError.create({ message: 'doc parameter must be an object', driver: true })
    );
  }
  insertDocuments(coll, [doc], options, (err, r) => {
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, { result: { ok: 1 } });
    r.insertedCount = r.result.n;
    r.insertedId = doc._id;
    if (callback) callback(null, r);
  });
}
function insertMany(coll, docs, options, callback) {
  if (!Array.isArray(docs)) {
    return callback(
      MongoError.create({ message: 'docs parameter must be an array of documents', driver: true })
    );
  }
  options['serializeFunctions'] = options['serializeFunctions'] || coll.s.serializeFunctions;
  docs = prepareDocs(coll, docs, options);
  const operations = [
    {
      insertMany: docs
    }
  ];
  bulkWrite(coll, operations, options, (err, result) => {
    if (err) return callback(err, null);
    callback(null, mapInsertManyResults(docs, result));
  });
}
function mapInsertManyResults(docs, r) {
  const finalResult = {
    result: { ok: 1, n: r.insertedCount },
    ops: docs,
    insertedCount: r.insertedCount,
    insertedIds: r.insertedIds
  };
  if (r.getLastOp()) {
    finalResult.result.opTime = r.getLastOp();
  }
  return finalResult;
}
function isCapped(coll, options, callback) {
  optionsOp(coll, options, (err, document) => {
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, !!(document && document.capped));
  });
}
function mapReduce(coll, map, reduce, options, callback) {
  const mapCommandHash = {
    mapreduce: coll.s.name,
    map: map,
    reduce: reduce
  };
  const exclusionList = ['readPreference', 'session', 'bypassDocumentValidation'];
  for (let n in options) {
    if ('scope' === n) {
      mapCommandHash[n] = processScope(options[n]);
    } else {
      if (exclusionList.indexOf(n) === -1) {
        mapCommandHash[n] = options[n];
      }
    }
  }
  options = Object.assign({}, options);
  options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });
  if (
    options.readPreference !== false &&
    options.readPreference !== 'primary' &&
    options['out'] &&
    (options['out'].inline !== 1 && options['out'] !== 'inline')
  ) {
    options.readPreference = 'primary';
    applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);
  } else {
    decorateWithReadConcern(mapCommandHash, coll, options);
  }
  if (options.bypassDocumentValidation === true) {
    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
  }
  try {
    decorateWithCollation(mapCommandHash, coll, options);
  } catch (err) {
    return callback(err, null);
  }
  executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    if (1 !== result.ok || result.err || result.errmsg) {
      return handleCallback(callback, toError(result));
    }
    const stats = {};
    if (result.timeMillis) stats['processtime'] = result.timeMillis;
    if (result.counts) stats['counts'] = result.counts;
    if (result.timing) stats['timing'] = result.timing;
    if (result.results) {
      if (options['verbose'] == null || !options['verbose']) {
        return handleCallback(callback, null, result.results);
      }
      return handleCallback(callback, null, { results: result.results, stats: stats });
    }
    let collection = null;
    if (result.result != null && typeof result.result === 'object') {
      const doc = result.result;
      let Db = loadDb();
      collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(
        doc.collection
      );
    } else {
      collection = coll.s.db.collection(result.result);
    }
    if (options['verbose'] == null || !options['verbose']) {
      return handleCallback(callback, err, collection);
    }
    handleCallback(callback, err, { collection: collection, stats: stats });
  });
}
function optionsOp(coll, opts, callback) {
  coll.s.db.listCollections({ name: coll.s.name }, opts).toArray((err, collections) => {
    if (err) return handleCallback(callback, err);
    if (collections.length === 0) {
      return handleCallback(
        callback,
        MongoError.create({ message: `collection ${coll.s.namespace} not found`, driver: true })
      );
    }
    handleCallback(callback, err, collections[0].options || null);
  });
}
function parallelCollectionScan(coll, options, callback) {
  const commandObject = {
    parallelCollectionScan: coll.s.name,
    numCursors: options.numCursors
  };
  decorateWithReadConcern(commandObject, coll, options);
  const raw = options.raw;
  delete options['raw'];
  executeCommand(coll.s.db, commandObject, options, (err, result) => {
    if (err) return handleCallback(callback, err, null);
    if (result == null)
      return handleCallback(
        callback,
        new Error('no result returned for parallelCollectionScan'),
        null
      );
    options = Object.assign({ explicitlyIgnoreSession: true }, options);
    const cursors = [];
    if (raw) options.raw = raw;
    for (let i = 0; i < result.cursors.length; i++) {
      const rawId = result.cursors[i].cursor.id;
      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId;
      cursors.push(coll.s.topology.cursor(coll.s.namespace, cursorId, options));
    }
    handleCallback(callback, null, cursors);
  });
}
function prepareDocs(coll, docs, options) {
  const forceServerObjectId =
    typeof options.forceServerObjectId === 'boolean'
      ? options.forceServerObjectId
      : coll.s.db.options.forceServerObjectId;
  if (forceServerObjectId === true) {
    return docs;
  }
  return docs.map(doc => {
    if (forceServerObjectId !== true && doc._id == null) {
      doc._id = coll.s.pkFactory.createPk();
    }
    return doc;
  });
}
function processScope(scope) {
  if (!isObject(scope) || scope._bsontype === 'ObjectID') {
    return scope;
  }
  const keys = Object.keys(scope);
  let key;
  const new_scope = {};
  for (let i = keys.length - 1; i >= 0; i--) {
    key = keys[i];
    if ('function' === typeof scope[key]) {
      new_scope[key] = new Code(String(scope[key]));
    } else {
      new_scope[key] = processScope(scope[key]);
    }
  }
  return new_scope;
}
function reIndex(coll, options, callback) {
  const cmd = { reIndex: coll.s.name };
  executeCommand(coll.s.db, cmd, options, (err, result) => {
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  });
}
function removeDocuments(coll, selector, options, callback) {
  if (typeof options === 'function') {
    (callback = options), (options = {});
  } else if (typeof selector === 'function') {
    callback = selector;
    options = {};
    selector = {};
  }
  options = options || {};
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
  if (selector == null) selector = {};
  const op = { q: selector, limit: 0 };
  if (options.single) {
    op.limit = 1;
  } else if (finalOptions.retryWrites) {
    finalOptions.retryWrites = false;
  }
  try {
    decorateWithCollation(finalOptions, coll, options);
  } catch (err) {
    return callback(err, null);
  }
  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    handleCallback(callback, null, result);
  });
}
function rename(coll, newName, options, callback) {
  let Collection = loadCollection();
  checkCollectionName(newName);
  const renameCollection = `${coll.s.dbName}.${coll.s.name}`;
  const toCollection = `${coll.s.dbName}.${newName}`;
  const dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;
  const cmd = { renameCollection: renameCollection, to: toCollection, dropTarget: dropTarget };
  applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options);
  executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, (err, doc) => {
    if (err) return handleCallback(callback, err, null);
    if (doc.errmsg) return handleCallback(callback, toError(doc), null);
    try {
      return handleCallback(
        callback,
        null,
        new Collection(
          coll.s.db,
          coll.s.topology,
          coll.s.dbName,
          newName,
          coll.s.pkFactory,
          coll.s.options
        )
      );
    } catch (err) {
      return handleCallback(callback, toError(err), null);
    }
  });
}
function replaceOne(coll, filter, doc, options, callback) {
  options.multi = false;
  updateDocuments(coll, filter, doc, options, (err, r) => {
    if (callback == null) return;
    if (err && callback) return callback(err);
    if (r == null) return callback(null, { result: { ok: 1 } });
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0
        ? r.result.upserted[0] 
        : null;
    r.upsertedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount =
      Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    r.ops = [doc];
    if (callback) callback(null, r);
  });
}
function save(coll, doc, options, callback) {
  const finalOptions = applyWriteConcern(
    Object.assign({}, options),
    { db: coll.s.db, collection: coll },
    options
  );
  if (doc._id != null) {
    finalOptions.upsert = true;
    return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);
  }
  insertDocuments(coll, [doc], finalOptions, (err, result) => {
    if (callback == null) return;
    if (doc == null) return handleCallback(callback, null, null);
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  });
}
function stats(coll, options, callback) {
  const commandObject = {
    collStats: coll.s.name
  };
  if (options['scale'] != null) commandObject['scale'] = options['scale'];
  options = Object.assign({}, options);
  options.readPreference = resolveReadPreference(options, { db: coll.s.db, collection: coll });
  executeCommand(coll.s.db, commandObject, options, callback);
}
function updateCallback(err, r, callback) {
  if (callback == null) return;
  if (err) return callback(err);
  if (r == null) return callback(null, { result: { ok: 1 } });
  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
  r.upsertedId =
    Array.isArray(r.result.upserted) && r.result.upserted.length > 0
      ? r.result.upserted[0] 
      : null;
  r.upsertedCount =
    Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
  r.matchedCount =
    Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
  callback(null, r);
}
function updateDocuments(coll, selector, document, options, callback) {
  if ('function' === typeof options) (callback = options), (options = null);
  if (options == null) options = {};
  if (!('function' === typeof callback)) callback = null;
  if (selector == null || typeof selector !== 'object')
    return callback(toError('selector must be a valid JavaScript object'));
  if (document == null || typeof document !== 'object')
    return callback(toError('document must be a valid JavaScript object'));
  let finalOptions = Object.assign({}, options);
  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
  const op = { q: selector, u: document };
  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
  op.multi = options.multi !== void 0 ? !!options.multi : false;
  if (finalOptions.arrayFilters) {
    op.arrayFilters = finalOptions.arrayFilters;
    delete finalOptions.arrayFilters;
  }
  if (finalOptions.retryWrites && op.multi) {
    finalOptions.retryWrites = false;
  }
  try {
    decorateWithCollation(finalOptions, coll, options);
  } catch (err) {
    return callback(err, null);
  }
  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    if (result == null) return handleCallback(callback, null, null);
    if (result.result.code) return handleCallback(callback, toError(result.result));
    if (result.result.writeErrors)
      return handleCallback(callback, toError(result.result.writeErrors[0]));
    handleCallback(callback, null, result);
  });
}
function updateMany(coll, filter, update, options, callback) {
  options.multi = true;
  updateDocuments(coll, filter, update, options, (err, r) => updateCallback(err, r, callback));
}
function updateOne(coll, filter, update, options, callback) {
  options.multi = false;
  updateDocuments(coll, filter, update, options, (err, r) => updateCallback(err, r, callback));
}
module.exports = {
  bulkWrite,
  checkForAtomicOperators,
  count,
  countDocuments,
  buildCountCommand,
  createIndex,
  createIndexes,
  deleteMany,
  deleteOne,
  distinct,
  dropIndex,
  dropIndexes,
  ensureIndex,
  findAndModify,
  findAndRemove,
  findOne,
  findOneAndDelete,
  findOneAndReplace,
  findOneAndUpdate,
  geoHaystackSearch,
  group,
  indexes,
  indexExists,
  indexInformation,
  insertMany,
  insertOne,
  isCapped,
  mapReduce,
  optionsOp,
  parallelCollectionScan,
  prepareDocs,
  reIndex,
  removeDocuments,
  rename,
  replaceOne,
  save,
  stats,
  updateDocuments,
  updateMany,
  updateOne
};
