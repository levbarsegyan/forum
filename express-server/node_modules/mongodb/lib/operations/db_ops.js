'use strict';
const applyWriteConcern = require('../utils').applyWriteConcern;
const Code = require('mongodb-core').BSON.Code;
const resolveReadPreference = require('../utils').resolveReadPreference;
const crypto = require('crypto');
const debugOptions = require('../utils').debugOptions;
const handleCallback = require('../utils').handleCallback;
const MongoError = require('mongodb-core').MongoError;
const parseIndexOptions = require('../utils').parseIndexOptions;
const ReadPreference = require('mongodb-core').ReadPreference;
const toError = require('../utils').toError;
const CONSTANTS = require('../constants');
const count = require('./collection_ops').count;
const findOne = require('./collection_ops').findOne;
const remove = require('./collection_ops').remove;
const updateOne = require('./collection_ops').updateOne;
let collection;
function loadCollection() {
  if (!collection) {
    collection = require('../collection');
  }
  return collection;
}
let db;
function loadDb() {
  if (!db) {
    db = require('../db');
  }
  return db;
}
const debugFields = [
  'authSource',
  'w',
  'wtimeout',
  'j',
  'native_parser',
  'forceServerObjectId',
  'serializeFunctions',
  'raw',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'bufferMaxEntries',
  'numberOfRetries',
  'retryMiliSeconds',
  'readPreference',
  'pkFactory',
  'parentDb',
  'promiseLibrary',
  'noListener'
];
const illegalCommandFields = [
  'w',
  'wtimeout',
  'j',
  'fsync',
  'autoIndexId',
  'strict',
  'serializeFunctions',
  'pkFactory',
  'raw',
  'readPreference',
  'session'
];
function addUser(db, username, password, options, callback) {
  let Db = loadDb();
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  executeAuthCreateUserCommand(db, username, password, options, (err, r) => {
    if (err && err.code === -5000) {
      const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);
      const md5 = crypto.createHash('md5');
      md5.update(username + ':mongo:' + password);
      const userPassword = md5.digest('hex');
      const dbToUse = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;
      const collection = dbToUse.collection(CONSTANTS.SYSTEM_USER_COLLECTION);
      count(collection, {}, finalOptions, (err, count) => {
        if (err != null) return handleCallback(callback, err, null);
        const findOptions = Object.assign({ projection: { dbName: 1 } }, finalOptions);
        collection.find({ user: username }, findOptions).toArray(err => {
          if (err != null) return handleCallback(callback, err, null);
          finalOptions.upsert = true;
          updateOne(
            collection,
            { user: username },
            { $set: { user: username, pwd: userPassword } },
            finalOptions,
            err => {
              if (count === 0 && err)
                return handleCallback(callback, null, [{ user: username, pwd: userPassword }]);
              if (err) return handleCallback(callback, err, null);
              handleCallback(callback, null, [{ user: username, pwd: userPassword }]);
            }
          );
        });
      });
      return;
    }
    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, r);
  });
}
function collections(db, options, callback) {
  let Collection = loadCollection();
  options = Object.assign({}, options, { nameOnly: true });
  db.listCollections({}, options).toArray((err, documents) => {
    if (err != null) return handleCallback(callback, err, null);
    documents = documents.filter(doc => {
      return doc.name.indexOf('$') === -1;
    });
    handleCallback(
      callback,
      null,
      documents.map(d => {
        return new Collection(
          db,
          db.s.topology,
          db.s.databaseName,
          d.name,
          db.s.pkFactory,
          db.s.options
        );
      })
    );
  });
}
function createCollection(db, name, options, callback) {
  let Collection = loadCollection();
  const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);
  if (db.serverConfig && db.serverConfig.isDestroyed()) {
    return callback(new MongoError('topology was destroyed'));
  }
  const listCollectionOptions = Object.assign({}, finalOptions, { nameOnly: true });
  db
    .listCollections({ name }, listCollectionOptions)
    .setReadPreference(ReadPreference.PRIMARY)
    .toArray((err, collections) => {
      if (err != null) return handleCallback(callback, err, null);
      if (collections.length > 0 && finalOptions.strict) {
        return handleCallback(
          callback,
          MongoError.create({
            message: `Collection ${name} already exists. Currently in strict mode.`,
            driver: true
          }),
          null
        );
      } else if (collections.length > 0) {
        try {
          return handleCallback(
            callback,
            null,
            new Collection(db, db.s.topology, db.s.databaseName, name, db.s.pkFactory, options)
          );
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      const cmd = { create: name };
      applyWriteConcern(cmd, { db }, options);
      for (let n in options) {
        if (
          options[n] != null &&
          typeof options[n] !== 'function' &&
          illegalCommandFields.indexOf(n) === -1
        ) {
          cmd[n] = options[n];
        }
      }
      finalOptions.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd, finalOptions, err => {
        if (err) return handleCallback(callback, err);
        try {
          return handleCallback(
            callback,
            null,
            new Collection(db, db.s.topology, db.s.databaseName, name, db.s.pkFactory, options)
          );
        } catch (err) {
          return handleCallback(callback, err);
        }
      });
    });
}
function createIndex(db, name, fieldOrSpec, options, callback) {
  let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);
  finalOptions = applyWriteConcern(finalOptions, { db }, options);
  if (finalOptions.writeConcern && typeof callback !== 'function') {
    throw MongoError.create({
      message: 'Cannot use a writeConcern without a provided callback',
      driver: true
    });
  }
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
    if (err == null) return handleCallback(callback, err, result);
    if (
      err.code === 67 ||
      err.code === 11000 ||
      err.code === 85 ||
      err.code === 86 ||
      err.code === 11600 ||
      err.code === 197
    ) {
      return handleCallback(callback, err, result);
    }
    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
    finalOptions.checkKeys = false;
    db.s.topology.insert(
      `${db.s.databaseName}.${CONSTANTS.SYSTEM_INDEX_COLLECTION}`,
      doc,
      finalOptions,
      (err, result) => {
        if (callback == null) return;
        if (err) return handleCallback(callback, err);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.writeErrors)
          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
        handleCallback(callback, null, doc.name);
      }
    );
  });
}
function createListener(db, e, object) {
  function listener(err) {
    if (object.listeners(e).length > 0) {
      object.emit(e, err, db);
      for (let i = 0; i < db.s.children.length; i++) {
        db.s.children[i].emit(e, err, db.s.children[i]);
      }
    }
  }
  return listener;
}
function dropCollection(db, name, options, callback) {
  executeCommand(db, name, options, (err, result) => {
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }
    if (err) return handleCallback(callback, err);
    if (result.ok) return handleCallback(callback, null, true);
    handleCallback(callback, null, false);
  });
}
function dropDatabase(db, cmd, options, callback) {
  executeCommand(db, cmd, options, (err, result) => {
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }
    if (callback == null) return;
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  });
}
function ensureIndex(db, name, fieldOrSpec, options, callback) {
  const finalOptions = applyWriteConcern({}, { db }, options);
  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
  const index_name = selector.name;
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  finalOptions.readPreference = ReadPreference.PRIMARY;
  indexInformation(db, name, finalOptions, (err, indexInformation) => {
    if (err != null && err.code !== 26) return handleCallback(callback, err, null);
    if (indexInformation == null || !indexInformation[index_name]) {
      createIndex(db, name, fieldOrSpec, options, callback);
    } else {
      if (typeof callback === 'function') return handleCallback(callback, null, index_name);
    }
  });
}
function evaluate(db, code, parameters, options, callback) {
  let finalCode = code;
  let finalParameters = [];
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);
  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {
    finalParameters = [parameters];
  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {
    finalParameters = parameters;
  }
  let cmd = { $eval: finalCode, args: finalParameters };
  if (options['nolock']) {
    cmd['nolock'] = options['nolock'];
  }
  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);
  executeCommand(db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err, null);
    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);
    if (result)
      return handleCallback(
        callback,
        MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }),
        null
      );
    handleCallback(callback, err, result);
  });
}
function executeCommand(db, command, options, callback) {
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  const dbName = options.dbName || options.authdb || db.s.databaseName;
  options.readPreference = resolveReadPreference(options, { db, default: ReadPreference.primary });
  if (db.s.logger.isDebug())
    db.s.logger.debug(
      `executing command ${JSON.stringify(
        command
      )} against ${dbName}.$cmd with options [${JSON.stringify(
        debugOptions(debugFields, options)
      )}]`
    );
  db.s.topology.command(`${dbName}.$cmd`, command, options, (err, result) => {
    if (err) return handleCallback(callback, err);
    if (options.full) return handleCallback(callback, null, result);
    handleCallback(callback, null, result.result);
  });
}
function executeDbAdminCommand(db, command, options, callback) {
  db.s.topology.command('admin.$cmd', command, options, (err, result) => {
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, result.result);
  });
}
function indexInformation(db, name, options, callback) {
  const full = options['full'] == null ? false : options['full'];
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  function processResults(indexes) {
    let info = {};
    for (let i = 0; i < indexes.length; i++) {
      const index = indexes[i];
      info[index.name] = [];
      for (let name in index.key) {
        info[index.name].push([name, index.key[name]]);
      }
    }
    return info;
  }
  db
    .collection(name)
    .listIndexes(options)
    .toArray((err, indexes) => {
      if (err) return callback(toError(err));
      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);
      if (full) return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    });
}
function listCollectionsTransforms(databaseName) {
  const matching = `${databaseName}.`;
  return {
    doc: doc => {
      const index = doc.name.indexOf(matching);
      if (doc.name && index === 0) {
        doc.name = doc.name.substr(index + matching.length);
      }
      return doc;
    }
  };
}
function profilingInfo(db, options, callback) {
  try {
    db
      .collection('system.profile')
      .find({}, options)
      .toArray(callback);
  } catch (err) {
    return callback(err, null);
  }
}
function profilingLevel(db, options, callback) {
  executeCommand(db, { profile: -1 }, options, (err, doc) => {
    if (err == null && doc.ok === 1) {
      const was = doc.was;
      if (was === 0) return callback(null, 'off');
      if (was === 1) return callback(null, 'slow_only');
      if (was === 2) return callback(null, 'all');
      return callback(new Error('Error: illegal profiling level value ' + was), null);
    } else {
      err != null ? callback(err, null) : callback(new Error('Error with profile command'), null);
    }
  });
}
function removeUser(db, username, options, callback) {
  let Db = loadDb();
  executeAuthRemoveUserCommand(db, username, options, (err, result) => {
    if (err && err.code === -5000) {
      const finalOptions = applyWriteConcern(Object.assign({}, options), { db }, options);
      const db = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db;
      const collection = db.collection(CONSTANTS.SYSTEM_USER_COLLECTION);
      findOne(collection, { user: username }, finalOptions, (err, user) => {
        if (user == null) return handleCallback(callback, err, false);
        remove(collection, { user: username }, finalOptions, err => {
          handleCallback(callback, err, true);
        });
      });
      return;
    }
    if (err) return handleCallback(callback, err);
    handleCallback(callback, err, result);
  });
}
function setProfilingLevel(db, level, options, callback) {
  const command = {};
  let profile = 0;
  if (level === 'off') {
    profile = 0;
  } else if (level === 'slow_only') {
    profile = 1;
  } else if (level === 'all') {
    profile = 2;
  } else {
    return callback(new Error('Error: illegal profiling level value ' + level));
  }
  command['profile'] = profile;
  executeCommand(db, command, options, (err, doc) => {
    if (err == null && doc.ok === 1) return callback(null, level);
    return err != null
      ? callback(err, null)
      : callback(new Error('Error with profile command'), null);
  });
}
function validateDatabaseName(databaseName) {
  if (typeof databaseName !== 'string')
    throw MongoError.create({ message: 'database name must be a string', driver: true });
  if (databaseName.length === 0)
    throw MongoError.create({ message: 'database name cannot be the empty string', driver: true });
  if (databaseName === '$external') return;
  const invalidChars = [' ', '.', '$', '/', '\\'];
  for (let i = 0; i < invalidChars.length; i++) {
    if (databaseName.indexOf(invalidChars[i]) !== -1)
      throw MongoError.create({
        message: "database names cannot contain the character '" + invalidChars[i] + "'",
        driver: true
      });
  }
}
function createCreateIndexCommand(db, name, fieldOrSpec, options) {
  const indexParameters = parseIndexOptions(fieldOrSpec);
  const fieldHash = indexParameters.fieldHash;
  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;
  const selector = {
    ns: db.databaseName + '.' + name,
    key: fieldHash,
    name: indexName
  };
  const finalUnique = options == null || 'object' === typeof options ? false : options;
  options = options == null || typeof options === 'boolean' ? {} : options;
  const keysToOmit = Object.keys(selector);
  for (let optionName in options) {
    if (keysToOmit.indexOf(optionName) === -1) {
      selector[optionName] = options[optionName];
    }
  }
  if (selector['unique'] == null) selector['unique'] = finalUnique;
  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];
  for (let i = 0; i < removeKeys.length; i++) {
    delete selector[removeKeys[i]];
  }
  return selector;
}
function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {
  const indexParameters = parseIndexOptions(fieldOrSpec);
  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;
  const indexes = [{ name: indexName, key: indexParameters.fieldHash }];
  const keysToOmit = Object.keys(indexes[0]).concat([
    'writeConcern',
    'w',
    'wtimeout',
    'j',
    'fsync',
    'readPreference',
    'session'
  ]);
  for (let optionName in options) {
    if (keysToOmit.indexOf(optionName) === -1) {
      indexes[0][optionName] = options[optionName];
    }
  }
  const capabilities = db.s.topology.capabilities();
  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
    const error = new MongoError('server/primary/mongos does not support collation');
    error.code = 67;
    return callback(error);
  }
  const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options);
  options.readPreference = ReadPreference.PRIMARY;
  executeCommand(db, cmd, options, (err, result) => {
    if (err) return handleCallback(callback, err, null);
    if (result.ok === 0) return handleCallback(callback, toError(result), null);
    handleCallback(callback, null, indexName);
  });
}
function executeAuthCreateUserCommand(db, username, password, options, callback) {
  if (typeof username === 'string' && password != null && typeof password === 'object') {
    options = password;
    password = null;
  }
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  if (options.digestPassword != null) {
    return callback(
      toError(
        "The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."
      )
    );
  }
  const customData = options.customData != null ? options.customData : {};
  let roles = Array.isArray(options.roles) ? options.roles : [];
  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;
  if (roles.length === 0) {
    console.log('Creating a user without roles is deprecated in MongoDB >= 2.6');
  }
  const commandOptions = { writeCommand: true };
  if (options['dbName']) commandOptions.dbName = options['dbName'];
  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
  if (
    (db.databaseName.toLowerCase() === 'admin' || options.dbName === 'admin') &&
    !Array.isArray(options.roles)
  ) {
    roles = ['root'];
  } else if (!Array.isArray(options.roles)) {
    roles = ['dbOwner'];
  }
  const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
  let command = {
    createUser: username,
    customData: customData,
    roles: roles,
    digestPassword
  };
  command = applyWriteConcern(command, { db }, options);
  let userPassword = password;
  if (!digestPassword) {
    const md5 = crypto.createHash('md5');
    md5.update(username + ':mongo:' + password);
    userPassword = md5.digest('hex');
  }
  if (typeof password === 'string') {
    command.pwd = userPassword;
  }
  commandOptions.readPreference = ReadPreference.primary;
  executeCommand(db, command, commandOptions, (err, result) => {
    if (err && err.ok === 0 && err.code === undefined)
      return handleCallback(callback, { code: -5000 }, null);
    if (err) return handleCallback(callback, err, null);
    handleCallback(
      callback,
      !result.ok ? toError(result) : null,
      result.ok ? [{ user: username, pwd: '' }] : null
    );
  });
}
function executeAuthRemoveUserCommand(db, username, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (db.serverConfig && db.serverConfig.isDestroyed())
    return callback(new MongoError('topology was destroyed'));
  const commandOptions = { writeCommand: true };
  if (options['dbName']) commandOptions.dbName = options['dbName'];
  const maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null;
  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
  let command = {
    dropUser: username
  };
  command = applyWriteConcern(command, { db }, options);
  commandOptions.readPreference = ReadPreference.primary;
  executeCommand(db, command, commandOptions, (err, result) => {
    if (err && !err.ok && err.code === undefined) return handleCallback(callback, { code: -5000 });
    if (err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  });
}
module.exports = {
  addUser,
  collections,
  createCollection,
  createListener,
  createIndex,
  dropCollection,
  dropDatabase,
  ensureIndex,
  evaluate,
  executeCommand,
  executeDbAdminCommand,
  listCollectionsTransforms,
  indexInformation,
  profilingInfo,
  profilingLevel,
  removeUser,
  setProfilingLevel,
  validateDatabaseName
};
