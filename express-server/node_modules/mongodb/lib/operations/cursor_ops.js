'use strict';
const buildCountCommand = require('./collection_ops').buildCountCommand;
const formattedOrderClause = require('../utils').formattedOrderClause;
const handleCallback = require('../utils').handleCallback;
const MongoError = require('mongodb-core').MongoError;
const push = Array.prototype.push;
let cursor;
function loadCursor() {
  if (!cursor) {
    cursor = require('../cursor');
  }
  return cursor;
}
function count(cursor, applySkipLimit, opts, callback) {
  if (applySkipLimit) {
    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();
    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();
  }
  if (opts.readPreference) {
    cursor.setReadPreference(opts.readPreference);
  }
  if (
    typeof opts.maxTimeMS !== 'number' &&
    cursor.s.cmd &&
    typeof cursor.s.cmd.maxTimeMS === 'number'
  ) {
    opts.maxTimeMS = cursor.s.cmd.maxTimeMS;
  }
  let options = {};
  options.skip = opts.skip;
  options.limit = opts.limit;
  options.hint = opts.hint;
  options.maxTimeMS = opts.maxTimeMS;
  const delimiter = cursor.s.ns.indexOf('.');
  options.collectionName = cursor.s.ns.substr(delimiter + 1);
  let command;
  try {
    command = buildCountCommand(cursor, cursor.s.cmd.query, options);
  } catch (err) {
    return callback(err);
  }
  cursor.server = cursor.topology.s.coreTopology;
  cursor.s.topology.command(
    `${cursor.s.ns.substr(0, delimiter)}.$cmd`,
    command,
    cursor.s.options,
    (err, result) => {
      callback(err, result ? result.result.n : null);
    }
  );
}
function each(cursor, callback) {
  let Cursor = loadCursor();
  if (!callback) throw MongoError.create({ message: 'callback is mandatory', driver: true });
  if (cursor.isNotified()) return;
  if (cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
    return handleCallback(
      callback,
      MongoError.create({ message: 'Cursor is closed', driver: true })
    );
  }
  if (cursor.s.state === Cursor.INIT) cursor.s.state = Cursor.OPEN;
  let fn = null;
  if (cursor.bufferedCount() > 0) {
    while ((fn = loop(cursor, callback))) fn(cursor, callback);
    each(cursor, callback);
  } else {
    cursor.next((err, item) => {
      if (err) return handleCallback(callback, err);
      if (item == null) {
        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));
      }
      if (handleCallback(callback, null, item) === false) return;
      each(cursor, callback);
    });
  }
}
function hasNext(cursor, callback) {
  let Cursor = loadCursor();
  if (cursor.s.currentDoc) {
    return callback(null, true);
  }
  if (cursor.isNotified()) {
    return callback(null, false);
  }
  nextObject(cursor, (err, doc) => {
    if (err) return callback(err, null);
    if (cursor.s.state === Cursor.CLOSED || cursor.isDead()) return callback(null, false);
    if (!doc) return callback(null, false);
    cursor.s.currentDoc = doc;
    callback(null, true);
  });
}
function loop(cursor, callback) {
  if (cursor.bufferedCount() === 0) return;
  cursor._next(callback);
  return loop;
}
function next(cursor, callback) {
  if (cursor.s.currentDoc) {
    const doc = cursor.s.currentDoc;
    cursor.s.currentDoc = null;
    return callback(null, doc);
  }
  nextObject(cursor, callback);
}
function nextObject(cursor, callback) {
  let Cursor = loadCursor();
  if (cursor.s.state === Cursor.CLOSED || (cursor.isDead && cursor.isDead()))
    return handleCallback(
      callback,
      MongoError.create({ message: 'Cursor is closed', driver: true })
    );
  if (cursor.s.state === Cursor.INIT && cursor.s.cmd.sort) {
    try {
      cursor.s.cmd.sort = formattedOrderClause(cursor.s.cmd.sort);
    } catch (err) {
      return handleCallback(callback, err);
    }
  }
  cursor._next((err, doc) => {
    cursor.s.state = Cursor.OPEN;
    if (err) return handleCallback(callback, err);
    handleCallback(callback, null, doc);
  });
}
function toArray(cursor, callback) {
  let Cursor = loadCursor();
  const items = [];
  cursor.rewind();
  cursor.s.state = Cursor.INIT;
  const fetchDocs = () => {
    cursor._next((err, doc) => {
      if (err) {
        return cursor._endSession
          ? cursor._endSession(() => handleCallback(callback, err))
          : handleCallback(callback, err);
      }
      if (doc == null) {
        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));
      }
      items.push(doc);
      if (cursor.bufferedCount() > 0) {
        let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {
          docs = docs.map(cursor.s.transforms.doc);
        }
        push.apply(items, docs);
      }
      fetchDocs();
    });
  };
  fetchDocs();
}
module.exports = { count, each, hasNext, next, toArray };
