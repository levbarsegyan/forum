'use strict';
const Long = require('mongodb-core').BSON.Long;
const MongoError = require('mongodb-core').MongoError;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const BSON = require('mongodb-core').BSON;
const MongoWriteConcernError = require('mongodb-core').MongoWriteConcernError;
const toError = require('../utils').toError;
const handleCallback = require('../utils').handleCallback;
const applyRetryableWrites = require('../utils').applyRetryableWrites;
const applyWriteConcern = require('../utils').applyWriteConcern;
const executeOperation = require('../utils').executeOperation;
const isPromiseLike = require('../utils').isPromiseLike;
const WRITE_CONCERN_ERROR = 64;
const INSERT = 1;
const UPDATE = 2;
const REMOVE = 3;
const bson = new BSON([
  BSON.Binary,
  BSON.Code,
  BSON.DBRef,
  BSON.Decimal128,
  BSON.Double,
  BSON.Int32,
  BSON.Long,
  BSON.Map,
  BSON.MaxKey,
  BSON.MinKey,
  BSON.ObjectId,
  BSON.BSONRegExp,
  BSON.Symbol,
  BSON.Timestamp
]);
class Batch {
  constructor(batchType, originalZeroIndex) {
    this.originalZeroIndex = originalZeroIndex;
    this.currentIndex = 0;
    this.originalIndexes = [];
    this.batchType = batchType;
    this.operations = [];
    this.size = 0;
    this.sizeBytes = 0;
  }
}
class BulkWriteResult {
  constructor(bulkResult) {
    this.result = bulkResult;
  }
  get ok() {
    return this.result.ok;
  }
  get nInserted() {
    return this.result.nInserted;
  }
  get nUpserted() {
    return this.result.nUpserted;
  }
  get nMatched() {
    return this.result.nMatched;
  }
  get nModified() {
    return this.result.nModified;
  }
  get nRemoved() {
    return this.result.nRemoved;
  }
  getInsertedIds() {
    return this.result.insertedIds;
  }
  getUpsertedIds() {
    return this.result.upserted;
  }
  getUpsertedIdAt(index) {
    return this.result.upserted[index];
  }
  getRawResponse() {
    return this.result;
  }
  hasWriteErrors() {
    return this.result.writeErrors.length > 0;
  }
  getWriteErrorCount() {
    return this.result.writeErrors.length;
  }
  getWriteErrorAt(index) {
    if (index < this.result.writeErrors.length) {
      return this.result.writeErrors[index];
    }
    return null;
  }
  getWriteErrors() {
    return this.result.writeErrors;
  }
  getLastOp() {
    return this.result.lastOp;
  }
  getWriteConcernError() {
    if (this.result.writeConcernErrors.length === 0) {
      return null;
    } else if (this.result.writeConcernErrors.length === 1) {
      return this.result.writeConcernErrors[0];
    } else {
      let errmsg = '';
      for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
        const err = this.result.writeConcernErrors[i];
        errmsg = errmsg + err.errmsg;
        if (i === 0) errmsg = errmsg + ' and ';
      }
      return new WriteConcernError({ errmsg: errmsg, code: WRITE_CONCERN_ERROR });
    }
  }
  toJSON() {
    return this.result;
  }
  toString() {
    return `BulkWriteResult(${this.toJSON(this.result)})`;
  }
  isOk() {
    return this.result.ok === 1;
  }
}
class WriteConcernError {
  constructor(err) {
    this.err = err;
  }
  get code() {
    return this.err.code;
  }
  get errmsg() {
    return this.err.errmsg;
  }
  toJSON() {
    return { code: this.err.code, errmsg: this.err.errmsg };
  }
  toString() {
    return `WriteConcernError(${this.err.errmsg})`;
  }
}
class WriteError {
  constructor(err) {
    this.err = err;
  }
  get code() {
    return this.err.code;
  }
  get index() {
    return this.err.index;
  }
  get errmsg() {
    return this.err.errmsg;
  }
  getOperation() {
    return this.err.op;
  }
  toJSON() {
    return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
  }
  toString() {
    return `WriteError(${JSON.stringify(this.toJSON())})`;
  }
}
function mergeBatchResults(batch, bulkResult, err, result) {
  if (err) {
    result = err;
  } else if (result && result.result) {
    result = result.result;
  } else if (result == null) {
    return;
  }
  if (result.ok === 0 && bulkResult.ok === 1) {
    bulkResult.ok = 0;
    const writeError = {
      index: 0,
      code: result.code || 0,
      errmsg: result.message,
      op: batch.operations[0]
    };
    bulkResult.writeErrors.push(new WriteError(writeError));
    return;
  } else if (result.ok === 0 && bulkResult.ok === 0) {
    return;
  }
  if (result.opTime || result.lastOp) {
    const opTime = result.lastOp || result.opTime;
    let lastOpTS = null;
    let lastOpT = null;
    if (opTime && opTime._bsontype === 'Timestamp') {
      if (bulkResult.lastOp == null) {
        bulkResult.lastOp = opTime;
      } else if (opTime.greaterThan(bulkResult.lastOp)) {
        bulkResult.lastOp = opTime;
      }
    } else {
      if (bulkResult.lastOp) {
        lastOpTS =
          typeof bulkResult.lastOp.ts === 'number'
            ? Long.fromNumber(bulkResult.lastOp.ts)
            : bulkResult.lastOp.ts;
        lastOpT =
          typeof bulkResult.lastOp.t === 'number'
            ? Long.fromNumber(bulkResult.lastOp.t)
            : bulkResult.lastOp.t;
      }
      const opTimeTS = typeof opTime.ts === 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;
      const opTimeT = typeof opTime.t === 'number' ? Long.fromNumber(opTime.t) : opTime.t;
      if (bulkResult.lastOp == null) {
        bulkResult.lastOp = opTime;
      } else if (opTimeTS.greaterThan(lastOpTS)) {
        bulkResult.lastOp = opTime;
      } else if (opTimeTS.equals(lastOpTS)) {
        if (opTimeT.greaterThan(lastOpT)) {
          bulkResult.lastOp = opTime;
        }
      }
    }
  }
  if (batch.batchType === INSERT && result.n) {
    bulkResult.nInserted = bulkResult.nInserted + result.n;
  }
  if (batch.batchType === REMOVE && result.n) {
    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
  }
  let nUpserted = 0;
  if (Array.isArray(result.upserted)) {
    nUpserted = result.upserted.length;
    for (let i = 0; i < result.upserted.length; i++) {
      bulkResult.upserted.push({
        index: result.upserted[i].index + batch.originalZeroIndex,
        _id: result.upserted[i]._id
      });
    }
  } else if (result.upserted) {
    nUpserted = 1;
    bulkResult.upserted.push({
      index: batch.originalZeroIndex,
      _id: result.upserted
    });
  }
  if (batch.batchType === UPDATE && result.n) {
    const nModified = result.nModified;
    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
    if (typeof nModified === 'number') {
      bulkResult.nModified = bulkResult.nModified + nModified;
    } else {
      bulkResult.nModified = null;
    }
  }
  if (Array.isArray(result.writeErrors)) {
    for (let i = 0; i < result.writeErrors.length; i++) {
      const writeError = {
        index: batch.originalZeroIndex + result.writeErrors[i].index,
        code: result.writeErrors[i].code,
        errmsg: result.writeErrors[i].errmsg,
        op: batch.operations[result.writeErrors[i].index]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
    }
  }
  if (result.writeConcernError) {
    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
  }
}
function executeCommands(bulkOperation, options, callback) {
  if (bulkOperation.s.batches.length === 0) {
    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
  }
  const batch = bulkOperation.s.batches.shift();
  function resultHandler(err, result) {
    if (((err && err.driver) || (err && err.message)) && !(err instanceof MongoWriteConcernError)) {
      return handleCallback(callback, err);
    }
    if (err) err.ok = 0;
    if (err instanceof MongoWriteConcernError) {
      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
    }
    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
    const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
    if (mergeResult != null) {
      return handleCallback(callback, null, writeResult);
    }
    if (bulkOperation.handleWriteError(callback, writeResult)) return;
    executeCommands(bulkOperation, options, callback);
  }
  bulkOperation.finalOptionsHandler({ options, batch, resultHandler }, callback);
}
function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
  mergeBatchResults(batch, bulkResult, null, err.result);
  const wrappedWriteConcernError = new WriteConcernError({
    errmsg: err.result.writeConcernError.errmsg,
    code: err.result.writeConcernError.result
  });
  return handleCallback(
    callback,
    new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)),
    null
  );
}
class BulkWriteError extends MongoError {
  constructor(error, result) {
    const message = error.err || error.errmsg || error.errMessage || error;
    super(message);
    Object.assign(this, error);
    this.name = 'BulkWriteError';
    this.result = result;
  }
}
class FindOperators {
  constructor(bulkOperation) {
    this.s = bulkOperation.s;
  }
  update(updateDocument) {
    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;
    const document = {
      q: this.s.currentOp.selector,
      u: updateDocument,
      multi: true,
      upsert: upsert
    };
    this.s.currentOp = null;
    return this.s.options.addToOperationsList(this, UPDATE, document);
  }
  updateOne(updateDocument) {
    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;
    const document = {
      q: this.s.currentOp.selector,
      u: updateDocument,
      multi: false,
      upsert: upsert
    };
    this.s.currentOp = null;
    return this.s.options.addToOperationsList(this, UPDATE, document);
  }
  replaceOne(updateDocument) {
    this.updateOne(updateDocument);
  }
  upsert() {
    this.s.currentOp.upsert = true;
    return this;
  }
  deleteOne() {
    const document = {
      q: this.s.currentOp.selector,
      limit: 1
    };
    this.s.currentOp = null;
    return this.s.options.addToOperationsList(this, REMOVE, document);
  }
  delete() {
    const document = {
      q: this.s.currentOp.selector,
      limit: 0
    };
    this.s.currentOp = null;
    return this.s.options.addToOperationsList(this, REMOVE, document);
  }
  removeOne() {
    return this.deleteOne();
  }
  remove() {
    return this.delete();
  }
}
class BulkOperationBase {
  constructor(topology, collection, options, isOrdered) {
    this.isOrdered = isOrdered;
    options = options == null ? {} : options;
    const namespace = collection.collectionName;
    const executed = false;
    const currentOp = null;
    const bson = topology.bson;
    const isMaster = topology.lastIsMaster();
    const maxBatchSizeBytes =
      isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
    const maxWriteBatchSize =
      isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000;
    const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
    finalOptions = applyWriteConcern(finalOptions, { collection: collection }, options);
    const writeConcern = finalOptions.writeConcern;
    const promiseLibrary = options.promiseLibrary || Promise;
    const bulkResult = {
      ok: 1,
      writeErrors: [],
      writeConcernErrors: [],
      insertedIds: [],
      nInserted: 0,
      nUpserted: 0,
      nMatched: 0,
      nModified: 0,
      nRemoved: 0,
      upserted: []
    };
    this.s = {
      bulkResult: bulkResult,
      currentBatch: null,
      currentIndex: 0,
      currentBatchSize: 0,
      currentBatchSizeBytes: 0,
      currentInsertBatch: null,
      currentUpdateBatch: null,
      currentRemoveBatch: null,
      batches: [],
      writeConcern: writeConcern,
      maxBatchSizeBytes: maxBatchSizeBytes,
      maxWriteBatchSize: maxWriteBatchSize,
      maxKeySize,
      namespace: namespace,
      bson: bson,
      topology: topology,
      options: finalOptions,
      currentOp: currentOp,
      executed: executed,
      collection: collection,
      promiseLibrary: promiseLibrary,
      err: null,
      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true
    };
    if (options.bypassDocumentValidation === true) {
      this.s.bypassDocumentValidation = true;
    }
  }
  insert(document) {
    if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null)
      document._id = new ObjectID();
    return this.s.options.addToOperationsList(this, INSERT, document);
  }
  find(selector) {
    if (!selector) {
      throw toError('Bulk find operation must specify a selector');
    }
    this.s.currentOp = {
      selector: selector
    };
    return new FindOperators(this);
  }
  raw(op) {
    const key = Object.keys(op)[0];
    const forceServerObjectId =
      typeof this.s.options.forceServerObjectId === 'boolean'
        ? this.s.options.forceServerObjectId
        : this.s.collection.s.db.options.forceServerObjectId;
    if (
      (op.updateOne && op.updateOne.q) ||
      (op.updateMany && op.updateMany.q) ||
      (op.replaceOne && op.replaceOne.q)
    ) {
      op[key].multi = op.updateOne || op.replaceOne ? false : true;
      return this.s.options.addToOperationsList(this, UPDATE, op[key]);
    }
    if (op.updateOne || op.updateMany || op.replaceOne) {
      const multi = op.updateOne || op.replaceOne ? false : true;
      const operation = {
        q: op[key].filter,
        u: op[key].update || op[key].replacement,
        multi: multi
      };
      if (this.isOrdered) {
        operation.upsert = op[key].upsert ? true : false;
        if (op.collation) operation.collation = op.collation;
      } else {
        if (op[key].upsert) operation.upsert = true;
      }
      if (op[key].arrayFilters) operation.arrayFilters = op[key].arrayFilters;
      return this.s.options.addToOperationsList(this, UPDATE, operation);
    }
    if (
      op.removeOne ||
      op.removeMany ||
      (op.deleteOne && op.deleteOne.q) ||
      (op.deleteMany && op.deleteMany.q)
    ) {
      op[key].limit = op.removeOne ? 1 : 0;
      return this.s.options.addToOperationsList(this, REMOVE, op[key]);
    }
    if (op.deleteOne || op.deleteMany) {
      const limit = op.deleteOne ? 1 : 0;
      const operation = { q: op[key].filter, limit: limit };
      if (this.isOrdered) {
        if (op.collation) operation.collation = op.collation;
      }
      return this.s.options.addToOperationsList(this, REMOVE, operation);
    }
    if (op.insertOne && op.insertOne.document == null) {
      if (forceServerObjectId !== true && op.insertOne._id == null)
        op.insertOne._id = new ObjectID();
      return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
    } else if (op.insertOne && op.insertOne.document) {
      if (forceServerObjectId !== true && op.insertOne.document._id == null)
        op.insertOne.document._id = new ObjectID();
      return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
    }
    if (op.insertMany) {
      for (let i = 0; i < op.insertMany.length; i++) {
        if (forceServerObjectId !== true && op.insertMany[i]._id == null)
          op.insertMany[i]._id = new ObjectID();
        this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
      }
      return;
    }
    throw toError(
      'bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany'
    );
  }
  _handleEarlyError(err, callback) {
    if (typeof callback === 'function') {
      callback(err, null);
      return;
    }
    return this.s.promiseLibrary.reject(err);
  }
  bulkExecute(_writeConcern, options, callback) {
    if (typeof options === 'function') (callback = options), (options = {});
    options = options || {};
    if (typeof _writeConcern === 'function') {
      callback = _writeConcern;
    } else if (_writeConcern && typeof _writeConcern === 'object') {
      this.s.writeConcern = _writeConcern;
    }
    if (this.s.executed) {
      const executedError = toError('batch cannot be re-executed');
      return this._handleEarlyError(executedError, callback);
    }
    if (this.isOrdered) {
      if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);
    } else {
      if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
      if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
      if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
    }
    if (this.s.batches.length === 0) {
      const emptyBatchError = toError('Invalid Operation, no operations specified');
      return this._handleEarlyError(emptyBatchError, callback);
    }
    return { options, callback };
  }
  execute(_writeConcern, options, callback) {
    const ret = this.bulkExecute(_writeConcern, options, callback);
    if (!ret || isPromiseLike(ret)) {
      return ret;
    }
    options = ret.options;
    callback = ret.callback;
    return executeOperation(this.s.topology, executeCommands, [this, options, callback]);
  }
  finalOptionsHandler(config, callback) {
    const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);
    if (this.s.writeConcern != null) {
      finalOptions.writeConcern = this.s.writeConcern;
    }
    if (finalOptions.bypassDocumentValidation !== true) {
      delete finalOptions.bypassDocumentValidation;
    }
    if (this.operationId) {
      config.resultHandler.operationId = this.operationId;
    }
    if (this.s.options.serializeFunctions) {
      finalOptions.serializeFunctions = true;
    }
    if (this.s.options.ignoreUndefined) {
      finalOptions.ignoreUndefined = true;
    }
    if (this.s.bypassDocumentValidation === true) {
      finalOptions.bypassDocumentValidation = true;
    }
    if (this.s.checkKeys === false) {
      finalOptions.checkKeys = false;
    }
    if (finalOptions.retryWrites) {
      if (config.batch.batchType === UPDATE) {
        finalOptions.retryWrites =
          finalOptions.retryWrites && !config.batch.operations.some(op => op.multi);
      }
      if (config.batch.batchType === REMOVE) {
        finalOptions.retryWrites =
          finalOptions.retryWrites && !config.batch.operations.some(op => op.limit === 0);
      }
    }
    try {
      if (config.batch.batchType === INSERT) {
        this.s.topology.insert(
          this.s.collection.namespace,
          config.batch.operations,
          finalOptions,
          config.resultHandler
        );
      } else if (config.batch.batchType === UPDATE) {
        this.s.topology.update(
          this.s.collection.namespace,
          config.batch.operations,
          finalOptions,
          config.resultHandler
        );
      } else if (config.batch.batchType === REMOVE) {
        this.s.topology.remove(
          this.s.collection.namespace,
          config.batch.operations,
          finalOptions,
          config.resultHandler
        );
      }
    } catch (err) {
      err.ok = 0;
      handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
    }
  }
  handleWriteError(callback, writeResult) {
    if (this.s.bulkResult.writeErrors.length > 0) {
      if (this.s.bulkResult.writeErrors.length === 1) {
        handleCallback(
          callback,
          new BulkWriteError(toError(this.s.bulkResult.writeErrors[0]), writeResult),
          null
        );
        return true;
      }
      handleCallback(
        callback,
        new BulkWriteError(
          toError({
            message: 'write operation failed',
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }),
          writeResult
        ),
        null
      );
      return true;
    } else if (writeResult.getWriteConcernError()) {
      handleCallback(
        callback,
        new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult),
        null
      );
      return true;
    }
  }
}
Object.defineProperty(BulkOperationBase.prototype, 'length', {
  enumerable: true,
  get: function() {
    return this.s.currentIndex;
  }
});
module.exports = {
  Batch,
  BulkOperationBase,
  bson,
  INSERT: INSERT,
  UPDATE: UPDATE,
  REMOVE: REMOVE
};
