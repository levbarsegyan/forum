'use strict';
const Chunk = require('./chunk');
const ObjectID = require('mongodb-core').BSON.ObjectID;
const ReadPreference = require('mongodb-core').ReadPreference;
const Buffer = require('safe-buffer').Buffer;
const fs = require('fs');
const f = require('util').format;
const util = require('util');
const MongoError = require('mongodb-core').MongoError;
const inherits = util.inherits;
const Duplex = require('stream').Duplex;
const shallowClone = require('../utils').shallowClone;
const executeOperation = require('../utils').executeOperation;
const deprecate = require('util').deprecate;
var REFERENCE_BY_FILENAME = 0,
  REFERENCE_BY_ID = 1;
const deprecationFn = deprecate(() => {},
'GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead');
var GridStore = function GridStore(db, id, filename, mode, options) {
  deprecationFn();
  if (!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
  this.db = db;
  if (typeof options === 'undefined') options = {};
  if (typeof mode === 'undefined') {
    mode = filename;
    filename = undefined;
  } else if (typeof mode === 'object') {
    options = mode;
    mode = filename;
    filename = undefined;
  }
  if (id && id._bsontype === 'ObjectID') {
    this.referenceBy = REFERENCE_BY_ID;
    this.fileId = id;
    this.filename = filename;
  } else if (typeof filename === 'undefined') {
    this.referenceBy = REFERENCE_BY_FILENAME;
    this.filename = id;
    if (mode.indexOf('w') != null) {
      this.fileId = new ObjectID();
    }
  } else {
    this.referenceBy = REFERENCE_BY_ID;
    this.fileId = id;
    this.filename = filename;
  }
  this.mode = mode == null ? 'r' : mode;
  this.options = options || {};
  this.isOpen = false;
  this.root =
    this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
  this.position = 0;
  this.readPreference =
    this.options.readPreference || db.options.readPreference || ReadPreference.primary;
  this.writeConcern = _getWriteConcern(db, this.options);
  this.internalChunkSize =
    this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];
  var promiseLibrary = this.options.promiseLibrary || Promise;
  this.promiseLibrary = promiseLibrary;
  Object.defineProperty(this, 'chunkSize', {
    enumerable: true,
    get: function() {
      return this.internalChunkSize;
    },
    set: function(value) {
      if (!(this.mode[0] === 'w' && this.position === 0 && this.uploadDate == null)) {
        this.internalChunkSize = this.internalChunkSize;
      } else {
        this.internalChunkSize = value;
      }
    }
  });
  Object.defineProperty(this, 'md5', {
    enumerable: true,
    get: function() {
      return this.internalMd5;
    }
  });
  Object.defineProperty(this, 'chunkNumber', {
    enumerable: true,
    get: function() {
      return this.currentChunk && this.currentChunk.chunkNumber
        ? this.currentChunk.chunkNumber
        : null;
    }
  });
};
GridStore.prototype.open = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (this.mode !== 'w' && this.mode !== 'w+' && this.mode !== 'r') {
    throw MongoError.create({ message: 'Illegal mode ' + this.mode, driver: true });
  }
  return executeOperation(this.db.s.topology, open, [this, options, callback], {
    skipSessions: true
  });
};
var open = function(self, options, callback) {
  var writeConcern = _getWriteConcern(self.db, self.options);
  if (self.mode === 'w' || self.mode === 'w+') {
    var collection = self.collection();
    collection.ensureIndex([['filename', 1]], writeConcern, function() {
      var chunkCollection = self.chunkCollection();
      var chunkIndexOptions = shallowClone(writeConcern);
      chunkIndexOptions.unique = true;
      chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], chunkIndexOptions, function() {
        _open(self, writeConcern, function(err, r) {
          if (err) return callback(err);
          self.isOpen = true;
          callback(err, r);
        });
      });
    });
  } else {
    _open(self, writeConcern, function(err, r) {
      if (err) return callback(err);
      self.isOpen = true;
      callback(err, r);
    });
  }
};
GridStore.prototype.eof = function() {
  return this.position === this.length ? true : false;
};
GridStore.prototype.getc = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.db.s.topology, getc, [this, options, callback], {
    skipSessions: true
  });
};
var getc = function(self, options, callback) {
  if (self.eof()) {
    callback(null, null);
  } else if (self.currentChunk.eof()) {
    nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
      self.currentChunk = chunk;
      self.position = self.position + 1;
      callback(err, self.currentChunk.getc());
    });
  } else {
    self.position = self.position + 1;
    callback(null, self.currentChunk.getc());
  }
};
GridStore.prototype.puts = function(string, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  var finalString = string.match(/\n$/) == null ? string + '\n' : string;
  return executeOperation(
    this.db.s.topology,
    this.write.bind(this),
    [finalString, options, callback],
    { skipSessions: true }
  );
};
GridStore.prototype.stream = function() {
  return new GridStoreStream(this);
};
GridStore.prototype.write = function write(data, close, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(
    this.db.s.topology,
    _writeNormal,
    [this, data, close, options, callback],
    { skipSessions: true }
  );
};
GridStore.prototype.destroy = function destroy() {
  if (!this.writable) return;
  this.readable = false;
  if (this.writable) {
    this.writable = false;
    this._q.length = 0;
    this.emit('close');
  }
};
GridStore.prototype.writeFile = function(file, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.db.s.topology, writeFile, [this, file, options, callback], {
    skipSessions: true
  });
};
var writeFile = function(self, file, options, callback) {
  if (typeof file === 'string') {
    fs.open(file, 'r', function(err, fd) {
      if (err) return callback(err);
      self.writeFile(fd, callback);
    });
    return;
  }
  self.open(function(err, self) {
    if (err) return callback(err, self);
    fs.fstat(file, function(err, stats) {
      if (err) return callback(err, self);
      var offset = 0;
      var index = 0;
      var writeChunk = function() {
        var _buffer = Buffer.alloc(self.chunkSize);
        fs.read(file, _buffer, 0, _buffer.length, offset, function(err, bytesRead, data) {
          if (err) return callback(err, self);
          offset = offset + bytesRead;
          var chunk = new Chunk(self, { n: index++ }, self.writeConcern);
          chunk.write(data.slice(0, bytesRead), function(err, chunk) {
            if (err) return callback(err, self);
            chunk.save({}, function(err) {
              if (err) return callback(err, self);
              self.position = self.position + bytesRead;
              self.currentChunk = chunk;
              if (offset >= stats.size) {
                fs.close(file, function(err) {
                  if (err) return callback(err);
                  self.close(function(err) {
                    if (err) return callback(err, self);
                    return callback(null, self);
                  });
                });
              } else {
                return process.nextTick(writeChunk);
              }
            });
          });
        });
      };
      process.nextTick(writeChunk);
    });
  });
};
GridStore.prototype.close = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.db.s.topology, close, [this, options, callback], {
    skipSessions: true
  });
};
var close = function(self, options, callback) {
  if (self.mode[0] === 'w') {
    options = Object.assign({}, self.writeConcern, options);
    if (self.currentChunk != null && self.currentChunk.position > 0) {
      self.currentChunk.save({}, function(err) {
        if (err && typeof callback === 'function') return callback(err);
        self.collection(function(err, files) {
          if (err && typeof callback === 'function') return callback(err);
          if (self.uploadDate != null) {
            buildMongoObject(self, function(err, mongoObject) {
              if (err) {
                if (typeof callback === 'function') return callback(err);
                else throw err;
              }
              files.save(mongoObject, options, function(err) {
                if (typeof callback === 'function') callback(err, mongoObject);
              });
            });
          } else {
            self.uploadDate = new Date();
            buildMongoObject(self, function(err, mongoObject) {
              if (err) {
                if (typeof callback === 'function') return callback(err);
                else throw err;
              }
              files.save(mongoObject, options, function(err) {
                if (typeof callback === 'function') callback(err, mongoObject);
              });
            });
          }
        });
      });
    } else {
      self.collection(function(err, files) {
        if (err && typeof callback === 'function') return callback(err);
        self.uploadDate = new Date();
        buildMongoObject(self, function(err, mongoObject) {
          if (err) {
            if (typeof callback === 'function') return callback(err);
            else throw err;
          }
          files.save(mongoObject, options, function(err) {
            if (typeof callback === 'function') callback(err, mongoObject);
          });
        });
      });
    }
  } else if (self.mode[0] === 'r') {
    if (typeof callback === 'function') callback(null, null);
  } else {
    if (typeof callback === 'function')
      callback(MongoError.create({ message: f('Illegal mode %s', self.mode), driver: true }));
  }
};
GridStore.prototype.chunkCollection = function(callback) {
  if (typeof callback === 'function') return this.db.collection(this.root + '.chunks', callback);
  return this.db.collection(this.root + '.chunks');
};
GridStore.prototype.unlink = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.db.s.topology, unlink, [this, options, callback], {
    skipSessions: true
  });
};
var unlink = function(self, options, callback) {
  deleteChunks(self, function(err) {
    if (err !== null) {
      err.message = 'at deleteChunks: ' + err.message;
      return callback(err);
    }
    self.collection(function(err, collection) {
      if (err !== null) {
        err.message = 'at collection: ' + err.message;
        return callback(err);
      }
      collection.remove({ _id: self.fileId }, self.writeConcern, function(err) {
        callback(err, self);
      });
    });
  });
};
GridStore.prototype.collection = function(callback) {
  if (typeof callback === 'function') this.db.collection(this.root + '.files', callback);
  return this.db.collection(this.root + '.files');
};
GridStore.prototype.readlines = function(separator, options, callback) {
  var args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  separator = args.length ? args.shift() : '\n';
  separator = separator || '\n';
  options = args.length ? args.shift() : {};
  return executeOperation(this.db.s.topology, readlines, [this, separator, options, callback], {
    skipSessions: true
  });
};
var readlines = function(self, separator, options, callback) {
  self.read(function(err, data) {
    if (err) return callback(err);
    var items = data.toString().split(separator);
    items = items.length > 0 ? items.splice(0, items.length - 1) : [];
    for (var i = 0; i < items.length; i++) {
      items[i] = items[i] + separator;
    }
    callback(null, items);
  });
};
GridStore.prototype.rewind = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.db.s.topology, rewind, [this, options, callback], {
    skipSessions: true
  });
};
var rewind = function(self, options, callback) {
  if (self.currentChunk.chunkNumber !== 0) {
    if (self.mode[0] === 'w') {
      deleteChunks(self, function(err) {
        if (err) return callback(err);
        self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);
        self.position = 0;
        callback(null, self);
      });
    } else {
      self.currentChunk(0, function(err, chunk) {
        if (err) return callback(err);
        self.currentChunk = chunk;
        self.currentChunk.rewind();
        self.position = 0;
        callback(null, self);
      });
    }
  } else {
    self.currentChunk.rewind();
    self.position = 0;
    callback(null, self);
  }
};
GridStore.prototype.read = function(length, buffer, options, callback) {
  var args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  length = args.length ? args.shift() : null;
  buffer = args.length ? args.shift() : null;
  options = args.length ? args.shift() : {};
  return executeOperation(this.db.s.topology, read, [this, length, buffer, options, callback], {
    skipSessions: true
  });
};
var read = function(self, length, buffer, options, callback) {
  var finalLength = length == null ? self.length - self.position : length;
  var finalBuffer = buffer == null ? Buffer.alloc(finalLength) : buffer;
  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
  if (self.currentChunk.length() - self.currentChunk.position + finalBuffer._index >= finalLength) {
    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
    slice.copy(finalBuffer, finalBuffer._index);
    self.position = self.position + finalBuffer.length;
    if (finalLength === 0 && finalBuffer.length === 0)
      return callback(MongoError.create({ message: 'File does not exist', driver: true }), null);
    return callback(null, finalBuffer);
  }
  slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
  slice.copy(finalBuffer, finalBuffer._index);
  finalBuffer._index += slice.length;
  nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
    if (err) return callback(err);
    if (chunk.length() > 0) {
      self.currentChunk = chunk;
      self.read(length, finalBuffer, callback);
    } else {
      if (finalBuffer._index > 0) {
        callback(null, finalBuffer);
      } else {
        callback(
          MongoError.create({
            message: 'no chunks found for file, possibly corrupt',
            driver: true
          }),
          null
        );
      }
    }
  });
};
GridStore.prototype.tell = function(callback) {
  var self = this;
  if (typeof callback === 'function') return callback(null, this.position);
  return new self.promiseLibrary(function(resolve) {
    resolve(self.position);
  });
};
GridStore.prototype.seek = function(position, seekLocation, options, callback) {
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  seekLocation = args.length ? args.shift() : null;
  options = args.length ? args.shift() : {};
  return executeOperation(
    this.db.s.topology,
    seek,
    [this, position, seekLocation, options, callback],
    { skipSessions: true }
  );
};
var seek = function(self, position, seekLocation, options, callback) {
  if (self.mode !== 'r') {
    return callback(
      MongoError.create({ message: 'seek is only supported for mode r', driver: true })
    );
  }
  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
  var finalPosition = position;
  var targetPosition = 0;
  if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
    targetPosition = self.position + finalPosition;
  } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
    targetPosition = self.length + finalPosition;
  } else {
    targetPosition = finalPosition;
  }
  var newChunkNumber = Math.floor(targetPosition / self.chunkSize);
  var seekChunk = function() {
    nthChunk(self, newChunkNumber, function(err, chunk) {
      if (err) return callback(err, null);
      if (chunk == null) return callback(new Error('no chunk found'));
      self.currentChunk = chunk;
      self.position = targetPosition;
      self.currentChunk.position = self.position % self.chunkSize;
      callback(err, self);
    });
  };
  seekChunk();
};
var _open = function(self, options, callback) {
  var collection = self.collection();
  var query =
    self.referenceBy === REFERENCE_BY_ID ? { _id: self.fileId } : { filename: self.filename };
  query = null == self.fileId && self.filename == null ? null : query;
  options.readPreference = self.readPreference;
  if (query != null) {
    collection.findOne(query, options, function(err, doc) {
      if (err) {
        return error(err);
      }
      if (doc != null) {
        self.fileId = doc._id;
        self.filename =
          self.mode === 'r' || self.filename === undefined ? doc.filename : self.filename;
        self.contentType = doc.contentType;
        self.internalChunkSize = doc.chunkSize;
        self.uploadDate = doc.uploadDate;
        self.aliases = doc.aliases;
        self.length = doc.length;
        self.metadata = doc.metadata;
        self.internalMd5 = doc.md5;
      } else if (self.mode !== 'r') {
        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self.internalChunkSize =
          self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
        self.length = 0;
      } else {
        self.length = 0;
        var txtId = self.fileId._bsontype === 'ObjectID' ? self.fileId.toHexString() : self.fileId;
        return error(
          MongoError.create({
            message: f(
              'file with id %s not opened for writing',
              self.referenceBy === REFERENCE_BY_ID ? txtId : self.filename
            ),
            driver: true
          }),
          self
        );
      }
      if (self.mode === 'r') {
        nthChunk(self, 0, options, function(err, chunk) {
          if (err) return error(err);
          self.currentChunk = chunk;
          self.position = 0;
          callback(null, self);
        });
      } else if (self.mode === 'w' && doc) {
        deleteChunks(self, options, function(err) {
          if (err) return error(err);
          self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);
          self.contentType =
            self.options['content_type'] == null ? self.contentType : self.options['content_type'];
          self.internalChunkSize =
            self.options['chunk_size'] == null
              ? self.internalChunkSize
              : self.options['chunk_size'];
          self.metadata =
            self.options['metadata'] == null ? self.metadata : self.options['metadata'];
          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
          self.position = 0;
          callback(null, self);
        });
      } else if (self.mode === 'w') {
        self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);
        self.contentType =
          self.options['content_type'] == null ? self.contentType : self.options['content_type'];
        self.internalChunkSize =
          self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
        self.position = 0;
        callback(null, self);
      } else if (self.mode === 'w+') {
        nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
          if (err) return error(err);
          self.currentChunk = chunk == null ? new Chunk(self, { n: 0 }, self.writeConcern) : chunk;
          self.currentChunk.position = self.currentChunk.data.length();
          self.metadata =
            self.options['metadata'] == null ? self.metadata : self.options['metadata'];
          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
          self.position = self.length;
          callback(null, self);
        });
      }
    });
  } else {
    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
    self.internalChunkSize =
      self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
    self.length = 0;
    if (self.mode === 'w') {
      deleteChunks(self, options, function(err) {
        if (err) return error(err);
        self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);
        self.contentType =
          self.options['content_type'] == null ? self.contentType : self.options['content_type'];
        self.internalChunkSize =
          self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
        self.position = 0;
        callback(null, self);
      });
    } else if (self.mode === 'w+') {
      nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
        if (err) return error(err);
        self.currentChunk = chunk == null ? new Chunk(self, { n: 0 }, self.writeConcern) : chunk;
        self.currentChunk.position = self.currentChunk.data.length();
        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
        self.position = self.length;
        callback(null, self);
      });
    }
  }
  function error(err) {
    if (error.err) return;
    callback((error.err = err));
  }
};
var writeBuffer = function(self, buffer, close, callback) {
  if (typeof close === 'function') {
    callback = close;
    close = null;
  }
  var finalClose = typeof close === 'boolean' ? close : false;
  if (self.mode !== 'w') {
    callback(
      MongoError.create({
        message: f(
          'file with id %s not opened for writing',
          self.referenceBy === REFERENCE_BY_ID ? self.referenceBy : self.filename
        ),
        driver: true
      }),
      null
    );
  } else {
    if (self.currentChunk.position + buffer.length >= self.chunkSize) {
      var previousChunkNumber = self.currentChunk.chunkNumber;
      var leftOverDataSize = self.chunkSize - self.currentChunk.position;
      var firstChunkData = buffer.slice(0, leftOverDataSize);
      var leftOverData = buffer.slice(leftOverDataSize);
      var chunksToWrite = [self.currentChunk.write(firstChunkData)];
      while (leftOverData.length >= self.chunkSize) {
        var newChunk = new Chunk(self, { n: previousChunkNumber + 1 }, self.writeConcern);
        firstChunkData = leftOverData.slice(0, self.chunkSize);
        leftOverData = leftOverData.slice(self.chunkSize);
        previousChunkNumber = previousChunkNumber + 1;
        newChunk.write(firstChunkData);
        chunksToWrite.push(newChunk);
      }
      self.currentChunk = new Chunk(self, { n: previousChunkNumber + 1 }, self.writeConcern);
      if (leftOverData.length > 0) self.currentChunk.write(leftOverData);
      self.position = self.position + buffer.length;
      var numberOfChunksToWrite = chunksToWrite.length;
      for (var i = 0; i < chunksToWrite.length; i++) {
        chunksToWrite[i].save({}, function(err) {
          if (err) return callback(err);
          numberOfChunksToWrite = numberOfChunksToWrite - 1;
          if (numberOfChunksToWrite <= 0) {
            if (finalClose) {
              return self.close(function(err) {
                callback(err, self);
              });
            }
            return callback(null, self);
          }
        });
      }
    } else {
      self.position = self.position + buffer.length;
      self.currentChunk.write(buffer);
      if (finalClose) {
        return self.close(function(err) {
          callback(err, self);
        });
      }
      return callback(null, self);
    }
  }
};
var buildMongoObject = function(self, callback) {
  var mongoObject = {
    _id: self.fileId,
    filename: self.filename,
    contentType: self.contentType,
    length: self.position ? self.position : 0,
    chunkSize: self.chunkSize,
    uploadDate: self.uploadDate,
    aliases: self.aliases,
    metadata: self.metadata
  };
  var md5Command = { filemd5: self.fileId, root: self.root };
  self.db.command(md5Command, function(err, results) {
    if (err) return callback(err);
    mongoObject.md5 = results.md5;
    callback(null, mongoObject);
  });
};
var nthChunk = function(self, chunkNumber, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || self.writeConcern;
  options.readPreference = self.readPreference;
  self
    .chunkCollection()
    .findOne({ files_id: self.fileId, n: chunkNumber }, options, function(err, chunk) {
      if (err) return callback(err);
      var finalChunk = chunk == null ? {} : chunk;
      callback(null, new Chunk(self, finalChunk, self.writeConcern));
    });
};
var lastChunkNumber = function(self) {
  return Math.floor((self.length ? self.length - 1 : 0) / self.chunkSize);
};
var deleteChunks = function(self, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || self.writeConcern;
  if (self.fileId != null) {
    self.chunkCollection().remove({ files_id: self.fileId }, options, function(err) {
      if (err) return callback(err, false);
      callback(null, true);
    });
  } else {
    callback(null, true);
  }
};
GridStore.DEFAULT_ROOT_COLLECTION = 'fs';
GridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';
GridStore.IO_SEEK_SET = 0;
GridStore.IO_SEEK_CUR = 1;
GridStore.IO_SEEK_END = 2;
GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
  var args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  rootCollection = args.length ? args.shift() : null;
  options = args.length ? args.shift() : {};
  options = options || {};
  return executeOperation(
    db.s.topology,
    exists,
    [db, fileIdObject, rootCollection, options, callback],
    { skipSessions: true }
  );
};
var exists = function(db, fileIdObject, rootCollection, options, callback) {
  var readPreference = options.readPreference || ReadPreference.PRIMARY;
  var rootCollectionFinal =
    rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
  db.collection(rootCollectionFinal + '.files', function(err, collection) {
    if (err) return callback(err);
    var query =
      typeof fileIdObject === 'string' ||
      Object.prototype.toString.call(fileIdObject) === '[object RegExp]'
        ? { filename: fileIdObject }
        : { _id: fileIdObject }; 
    if (
      fileIdObject != null &&
      typeof fileIdObject === 'object' &&
      Object.prototype.toString.call(fileIdObject) !== '[object RegExp]'
    ) {
      query = fileIdObject;
    }
    collection.findOne(query, { readPreference: readPreference }, function(err, item) {
      if (err) return callback(err);
      callback(null, item == null ? false : true);
    });
  });
};
GridStore.list = function(db, rootCollection, options, callback) {
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  rootCollection = args.length ? args.shift() : null;
  options = args.length ? args.shift() : {};
  options = options || {};
  return executeOperation(db.s.topology, list, [db, rootCollection, options, callback], {
    skipSessions: true
  });
};
var list = function(db, rootCollection, options, callback) {
  if (rootCollection != null && typeof rootCollection === 'object') {
    options = rootCollection;
    rootCollection = null;
  }
  var readPreference = options.readPreference || ReadPreference.primary;
  var byId = options['id'] != null ? options['id'] : false;
  var rootCollectionFinal =
    rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
  var items = [];
  db.collection(rootCollectionFinal + '.files', function(err, collection) {
    if (err) return callback(err);
    collection.find({}, { readPreference: readPreference }, function(err, cursor) {
      if (err) return callback(err);
      cursor.each(function(err, item) {
        if (item != null) {
          items.push(byId ? item._id : item.filename);
        } else {
          callback(err, items);
        }
      });
    });
  });
};
GridStore.read = function(db, name, length, offset, options, callback) {
  var args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  length = args.length ? args.shift() : null;
  offset = args.length ? args.shift() : null;
  options = args.length ? args.shift() : null;
  options = options || {};
  return executeOperation(
    db.s.topology,
    readStatic,
    [db, name, length, offset, options, callback],
    { skipSessions: true }
  );
};
var readStatic = function(db, name, length, offset, options, callback) {
  new GridStore(db, name, 'r', options).open(function(err, gridStore) {
    if (err) return callback(err);
    if (offset && offset >= gridStore.length)
      return callback('offset larger than size of file', null);
    if (length && length > gridStore.length)
      return callback('length is larger than the size of the file', null);
    if (offset && length && offset + length > gridStore.length)
      return callback('offset and length is larger than the size of the file', null);
    if (offset != null) {
      gridStore.seek(offset, function(err, gridStore) {
        if (err) return callback(err);
        gridStore.read(length, callback);
      });
    } else {
      gridStore.read(length, callback);
    }
  });
};
GridStore.readlines = function(db, name, separator, options, callback) {
  var args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  separator = args.length ? args.shift() : null;
  options = args.length ? args.shift() : null;
  options = options || {};
  return executeOperation(
    db.s.topology,
    readlinesStatic,
    [db, name, separator, options, callback],
    { skipSessions: true }
  );
};
var readlinesStatic = function(db, name, separator, options, callback) {
  var finalSeperator = separator == null ? '\n' : separator;
  new GridStore(db, name, 'r', options).open(function(err, gridStore) {
    if (err) return callback(err);
    gridStore.readlines(finalSeperator, callback);
  });
};
GridStore.unlink = function(db, names, options, callback) {
  var args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() : {};
  options = options || {};
  return executeOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {
    skipSessions: true
  });
};
var unlinkStatic = function(self, db, names, options, callback) {
  var writeConcern = _getWriteConcern(db, options);
  if (names.constructor === Array) {
    var tc = 0;
    for (var i = 0; i < names.length; i++) {
      ++tc;
      GridStore.unlink(db, names[i], options, function() {
        if (--tc === 0) {
          callback(null, self);
        }
      });
    }
  } else {
    new GridStore(db, names, 'w', options).open(function(err, gridStore) {
      if (err) return callback(err);
      deleteChunks(gridStore, function(err) {
        if (err) return callback(err);
        gridStore.collection(function(err, collection) {
          if (err) return callback(err);
          collection.remove({ _id: gridStore.fileId }, writeConcern, function(err) {
            callback(err, self);
          });
        });
      });
    });
  }
};
var _writeNormal = function(self, data, close, options, callback) {
  if (Buffer.isBuffer(data)) {
    return writeBuffer(self, data, close, callback);
  } else {
    return writeBuffer(self, Buffer.from(data, 'binary'), close, callback);
  }
};
var _setWriteConcernHash = function(options) {
  var finalOptions = {};
  if (options.w != null) finalOptions.w = options.w;
  if (options.journal === true) finalOptions.j = options.journal;
  if (options.j === true) finalOptions.j = options.j;
  if (options.fsync === true) finalOptions.fsync = options.fsync;
  if (options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
  return finalOptions;
};
var _getWriteConcern = function(self, options) {
  var finalOptions = { w: 1 };
  options = options || {};
  if (
    options.w != null ||
    typeof options.j === 'boolean' ||
    typeof options.journal === 'boolean' ||
    typeof options.fsync === 'boolean'
  ) {
    finalOptions = _setWriteConcernHash(options);
  } else if (options.safe != null && typeof options.safe === 'object') {
    finalOptions = _setWriteConcernHash(options.safe);
  } else if (typeof options.safe === 'boolean') {
    finalOptions = { w: options.safe ? 1 : 0 };
  } else if (
    self.options.w != null ||
    typeof self.options.j === 'boolean' ||
    typeof self.options.journal === 'boolean' ||
    typeof self.options.fsync === 'boolean'
  ) {
    finalOptions = _setWriteConcernHash(self.options);
  } else if (
    self.safe &&
    (self.safe.w != null ||
      typeof self.safe.j === 'boolean' ||
      typeof self.safe.journal === 'boolean' ||
      typeof self.safe.fsync === 'boolean')
  ) {
    finalOptions = _setWriteConcernHash(self.safe);
  } else if (typeof self.safe === 'boolean') {
    finalOptions = { w: self.safe ? 1 : 0 };
  }
  if (
    finalOptions.w < 1 &&
    (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true)
  )
    throw MongoError.create({
      message: 'No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true',
      driver: true
    });
  return finalOptions;
};
var GridStoreStream = function(gs) {
  Duplex.call(this);
  this.gs = gs;
  this.endCalled = false;
  this.totalBytesToRead = this.gs.length - this.gs.position;
  this.seekPosition = this.gs.position;
};
inherits(GridStoreStream, Duplex);
GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
GridStoreStream.prototype.pipe = function(destination) {
  var self = this;
  if (!self.gs.isOpen) {
    self.gs.open(function(err) {
      if (err) return self.emit('error', err);
      self.totalBytesToRead = self.gs.length - self.gs.position;
      self._pipe.apply(self, [destination]);
    });
  } else {
    self.totalBytesToRead = self.gs.length - self.gs.position;
    self._pipe.apply(self, [destination]);
  }
  return destination;
};
GridStoreStream.prototype._read = function() {
  var self = this;
  var read = function() {
    self.gs.read(length, function(err, buffer) {
      if (err && !self.endCalled) return self.emit('error', err);
      if (self.endCalled || buffer == null) return self.push(null);
      if (buffer.length <= self.totalBytesToRead) {
        self.totalBytesToRead = self.totalBytesToRead - buffer.length;
        self.push(buffer);
      } else if (buffer.length > self.totalBytesToRead) {
        self.totalBytesToRead = self.totalBytesToRead - buffer._index;
        self.push(buffer.slice(0, buffer._index));
      }
      if (self.totalBytesToRead <= 0) {
        self.endCalled = true;
      }
    });
  };
  var length =
    self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
  if (!self.gs.isOpen) {
    self.gs.open(function(err) {
      self.totalBytesToRead = self.gs.length - self.gs.position;
      if (err) return self.emit('error', err);
      read();
    });
  } else {
    read();
  }
};
GridStoreStream.prototype.destroy = function() {
  this.pause();
  this.endCalled = true;
  this.gs.close();
  this.emit('end');
};
GridStoreStream.prototype.write = function(chunk) {
  var self = this;
  if (self.endCalled)
    return self.emit(
      'error',
      MongoError.create({ message: 'attempting to write to stream after end called', driver: true })
    );
  if (!self.gs.isOpen) {
    self.gs.open(function() {
      self.gs.isOpen = true;
      self.gs.write(chunk, function() {
        process.nextTick(function() {
          self.emit('drain');
        });
      });
    });
    return false;
  } else {
    self.gs.write(chunk, function() {
      self.emit('drain');
    });
    return true;
  }
};
GridStoreStream.prototype.end = function(chunk, encoding, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  chunk = args.length ? args.shift() : null;
  encoding = args.length ? args.shift() : null;
  self.endCalled = true;
  if (chunk) {
    self.gs.write(chunk, function() {
      self.gs.close(function() {
        if (typeof callback === 'function') callback();
        self.emit('end');
      });
    });
  }
  self.gs.close(function() {
    if (typeof callback === 'function') callback();
    self.emit('end');
  });
};
module.exports = GridStore;
