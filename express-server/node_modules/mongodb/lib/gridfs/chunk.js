'use strict';
var Binary = require('mongodb-core').BSON.Binary,
  ObjectID = require('mongodb-core').BSON.ObjectID;
var Buffer = require('safe-buffer').Buffer;
var Chunk = function(file, mongoObject, writeConcern) {
  if (!(this instanceof Chunk)) return new Chunk(file, mongoObject);
  this.file = file;
  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
  this.writeConcern = writeConcern || { w: 1 };
  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
  this.data = new Binary();
  if (typeof mongoObjectFinal.data === 'string') {
    var buffer = Buffer.alloc(mongoObjectFinal.data.length);
    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');
    this.data = new Binary(buffer);
  } else if (Array.isArray(mongoObjectFinal.data)) {
    buffer = Buffer.alloc(mongoObjectFinal.data.length);
    var data = mongoObjectFinal.data.join('');
    buffer.write(data, 0, data.length, 'binary');
    this.data = new Binary(buffer);
  } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') {
    this.data = mongoObjectFinal.data;
  } else if (!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
    throw Error('Illegal chunk format');
  }
  this.internalPosition = 0;
};
Chunk.prototype.write = function(data, callback) {
  this.data.write(data, this.internalPosition, data.length, 'binary');
  this.internalPosition = this.data.length();
  if (callback != null) return callback(null, this);
  return this;
};
Chunk.prototype.read = function(length) {
  length = length == null || length === 0 ? this.length() : length;
  if (this.length() - this.internalPosition + 1 >= length) {
    var data = this.data.read(this.internalPosition, length);
    this.internalPosition = this.internalPosition + length;
    return data;
  } else {
    return '';
  }
};
Chunk.prototype.readSlice = function(length) {
  if (this.length() - this.internalPosition >= length) {
    var data = null;
    if (this.data.buffer != null) {
      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
    } else {
      data = Buffer.alloc(length);
      length = this.data.readInto(data, this.internalPosition);
    }
    this.internalPosition = this.internalPosition + length;
    return data;
  } else {
    return null;
  }
};
Chunk.prototype.eof = function() {
  return this.internalPosition === this.length() ? true : false;
};
Chunk.prototype.getc = function() {
  return this.read(1);
};
Chunk.prototype.rewind = function() {
  this.internalPosition = 0;
  this.data = new Binary();
};
Chunk.prototype.save = function(options, callback) {
  var self = this;
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  self.file.chunkCollection(function(err, collection) {
    if (err) return callback(err);
    var writeOptions = { upsert: true };
    for (var name in options) writeOptions[name] = options[name];
    for (name in self.writeConcern) writeOptions[name] = self.writeConcern[name];
    if (self.data.length() > 0) {
      self.buildMongoObject(function(mongoObject) {
        var options = { forceServerObjectId: true };
        for (var name in self.writeConcern) {
          options[name] = self.writeConcern[name];
        }
        collection.replaceOne({ _id: self.objectId }, mongoObject, writeOptions, function(err) {
          callback(err, self);
        });
      });
    } else {
      callback(null, self);
    }
  });
};
Chunk.prototype.buildMongoObject = function(callback) {
  var mongoObject = {
    files_id: this.file.fileId,
    n: this.chunkNumber,
    data: this.data
  };
  if (this.objectId != null) mongoObject._id = this.objectId;
  callback(mongoObject);
};
Chunk.prototype.length = function() {
  return this.data.length();
};
Object.defineProperty(Chunk.prototype, 'position', {
  enumerable: true,
  get: function() {
    return this.internalPosition;
  },
  set: function(value) {
    this.internalPosition = value;
  }
});
Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
module.exports = Chunk;
