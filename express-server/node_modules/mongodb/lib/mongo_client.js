'use strict';
const ChangeStream = require('./change_stream');
const Db = require('./db');
const EventEmitter = require('events').EventEmitter;
const executeOperation = require('./utils').executeOperation;
const inherits = require('util').inherits;
const MongoError = require('mongodb-core').MongoError;
const deprecate = require('util').deprecate;
const connectOp = require('./operations/mongo_client_ops').connectOp;
const validOptions = require('./operations/mongo_client_ops').validOptions;
const closeOperation = require('./operations/mongo_client_ops').closeOperation;
function MongoClient(url, options) {
  if (!(this instanceof MongoClient)) return new MongoClient(url, options);
  EventEmitter.call(this);
  this.s = {
    url: url,
    options: options || {},
    promiseLibrary: null,
    dbCache: {},
    sessions: []
  };
  const promiseLibrary = this.s.options.promiseLibrary || Promise;
  this.s.promiseLibrary = promiseLibrary;
}
inherits(MongoClient, EventEmitter);
MongoClient.prototype.connect = function(callback) {
  const err = validOptions(this.s.options);
  if (typeof callback === 'string') {
    throw new TypeError('`connect` only accepts a callback');
  }
  return executeOperation(this, connectOp, [this, err, callback], {
    skipSessions: true
  });
};
MongoClient.prototype.logout = deprecate(function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  if (typeof callback === 'function') callback(null, true);
}, 'Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient');
MongoClient.prototype.close = function(force, callback) {
  if (typeof force === 'function') (callback = force), (force = false);
  return executeOperation(this, closeOperation, [this, force, callback], {
    skipSessions: true
  });
};
MongoClient.prototype.db = function(dbName, options) {
  options = options || {};
  if (!dbName) {
    dbName = this.s.options.dbName;
  }
  const finalOptions = Object.assign({}, this.s.options, options);
  if (this.s.dbCache[dbName] && finalOptions.returnNonCachedInstance !== true) {
    return this.s.dbCache[dbName];
  }
  finalOptions.promiseLibrary = this.s.promiseLibrary;
  if (!this.topology) {
    throw new MongoError('MongoClient must be connected before calling MongoClient.prototype.db');
  }
  const db = new Db(dbName, this.topology, finalOptions);
  this.s.dbCache[dbName] = db;
  return db;
};
MongoClient.prototype.isConnected = function(options) {
  options = options || {};
  if (!this.topology) return false;
  return this.topology.isConnected(options);
};
MongoClient.connect = function(url, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() : null;
  options = options || {};
  const mongoClient = new MongoClient(url, options);
  return mongoClient.connect(callback);
};
MongoClient.prototype.startSession = function(options) {
  options = Object.assign({ explicit: true }, options);
  if (!this.topology) {
    throw new MongoError('Must connect to a server before calling this method');
  }
  if (!this.topology.hasSessionSupport()) {
    throw new MongoError('Current topology does not support sessions');
  }
  return this.topology.startSession(options, this.s.options);
};
MongoClient.prototype.withSession = function(options, operation) {
  if (typeof options === 'function') (operation = options), (options = undefined);
  const session = this.startSession(options);
  let cleanupHandler = (err, result, opts) => {
    cleanupHandler = () => {
      throw new ReferenceError('cleanupHandler was called too many times');
    };
    opts = Object.assign({ throw: true }, opts);
    session.endSession();
    if (err) {
      if (opts.throw) throw err;
      return Promise.reject(err);
    }
  };
  try {
    const result = operation(session);
    return Promise.resolve(result)
      .then(result => cleanupHandler(null, result))
      .catch(err => cleanupHandler(err, null, { throw: true }));
  } catch (err) {
    return cleanupHandler(err, null, { throw: false });
  }
};
MongoClient.prototype.watch = function(pipeline, options) {
  pipeline = pipeline || [];
  options = options || {};
  if (!Array.isArray(pipeline)) {
    options = pipeline;
    pipeline = [];
  }
  return new ChangeStream(this, pipeline, options);
};
MongoClient.prototype.getLogger = function() {
  return this.s.options.logger;
};
module.exports = MongoClient;
