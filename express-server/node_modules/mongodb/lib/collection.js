'use strict';
const deprecate = require('util').deprecate;
const deprecateOptions = require('./utils').deprecateOptions;
const checkCollectionName = require('./utils').checkCollectionName;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const MongoError = require('mongodb-core').MongoError;
const toError = require('./utils').toError;
const normalizeHintField = require('./utils').normalizeHintField;
const handleCallback = require('./utils').handleCallback;
const decorateCommand = require('./utils').decorateCommand;
const decorateWithCollation = require('./utils').decorateWithCollation;
const decorateWithReadConcern = require('./utils').decorateWithReadConcern;
const formattedOrderClause = require('./utils').formattedOrderClause;
const ReadPreference = require('mongodb-core').ReadPreference;
const CommandCursor = require('./command_cursor');
const unordered = require('./bulk/unordered');
const ordered = require('./bulk/ordered');
const ChangeStream = require('./change_stream');
const executeOperation = require('./utils').executeOperation;
const resolveReadPreference = require('./utils').resolveReadPreference;
const aggregate = require('./operations/aggregate').aggregate;
const bulkWrite = require('./operations/collection_ops').bulkWrite;
const checkForAtomicOperators = require('./operations/collection_ops').checkForAtomicOperators;
const count = require('./operations/collection_ops').count;
const countDocuments = require('./operations/collection_ops').countDocuments;
const createIndex = require('./operations/collection_ops').createIndex;
const createIndexes = require('./operations/collection_ops').createIndexes;
const deleteMany = require('./operations/collection_ops').deleteMany;
const deleteOne = require('./operations/collection_ops').deleteOne;
const distinct = require('./operations/collection_ops').distinct;
const dropIndex = require('./operations/collection_ops').dropIndex;
const dropIndexes = require('./operations/collection_ops').dropIndexes;
const ensureIndex = require('./operations/collection_ops').ensureIndex;
const findAndModify = require('./operations/collection_ops').findAndModify;
const findAndRemove = require('./operations/collection_ops').findAndRemove;
const findOne = require('./operations/collection_ops').findOne;
const findOneAndDelete = require('./operations/collection_ops').findOneAndDelete;
const findOneAndReplace = require('./operations/collection_ops').findOneAndReplace;
const findOneAndUpdate = require('./operations/collection_ops').findOneAndUpdate;
const geoHaystackSearch = require('./operations/collection_ops').geoHaystackSearch;
const group = require('./operations/collection_ops').group;
const indexes = require('./operations/collection_ops').indexes;
const indexExists = require('./operations/collection_ops').indexExists;
const indexInformation = require('./operations/collection_ops').indexInformation;
const insertMany = require('./operations/collection_ops').insertMany;
const insertOne = require('./operations/collection_ops').insertOne;
const isCapped = require('./operations/collection_ops').isCapped;
const mapReduce = require('./operations/collection_ops').mapReduce;
const optionsOp = require('./operations/collection_ops').optionsOp;
const parallelCollectionScan = require('./operations/collection_ops').parallelCollectionScan;
const reIndex = require('./operations/collection_ops').reIndex;
const removeDocuments = require('./operations/collection_ops').removeDocuments;
const rename = require('./operations/collection_ops').rename;
const replaceOne = require('./operations/collection_ops').replaceOne;
const save = require('./operations/collection_ops').save;
const stats = require('./operations/collection_ops').stats;
const updateDocuments = require('./operations/collection_ops').updateDocuments;
const updateMany = require('./operations/collection_ops').updateMany;
const updateOne = require('./operations/collection_ops').updateOne;
const mergeKeys = ['ignoreUndefined'];
function Collection(db, topology, dbName, name, pkFactory, options) {
  checkCollectionName(name);
  const internalHint = null;
  const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
  const serializeFunctions =
    options == null || options.serializeFunctions == null
      ? db.s.options.serializeFunctions
      : options.serializeFunctions;
  const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
  const promoteLongs =
    options == null || options.promoteLongs == null
      ? db.s.options.promoteLongs
      : options.promoteLongs;
  const promoteValues =
    options == null || options.promoteValues == null
      ? db.s.options.promoteValues
      : options.promoteValues;
  const promoteBuffers =
    options == null || options.promoteBuffers == null
      ? db.s.options.promoteBuffers
      : options.promoteBuffers;
  let readPreference = null;
  const collectionHint = null;
  const namespace = `${dbName}.${name}`;
  const promiseLibrary = options.promiseLibrary || Promise;
  if (options && options.readPreference) {
    readPreference = options.readPreference;
  } else if (db.options.readPreference) {
    readPreference = db.options.readPreference;
  }
  pkFactory = pkFactory == null ? ObjectID : pkFactory;
  this.s = {
    pkFactory: pkFactory,
    db: db,
    topology: topology,
    dbName: dbName,
    options: options,
    namespace: namespace,
    readPreference: readPreference,
    slaveOk: slaveOk,
    serializeFunctions: serializeFunctions,
    raw: raw,
    promoteLongs: promoteLongs,
    promoteValues: promoteValues,
    promoteBuffers: promoteBuffers,
    internalHint: internalHint,
    collectionHint: collectionHint,
    name: name,
    promiseLibrary: promiseLibrary,
    readConcern: options.readConcern,
    writeConcern: options.writeConcern
  };
}
Object.defineProperty(Collection.prototype, 'dbName', {
  enumerable: true,
  get: function() {
    return this.s.dbName;
  }
});
Object.defineProperty(Collection.prototype, 'collectionName', {
  enumerable: true,
  get: function() {
    return this.s.name;
  }
});
Object.defineProperty(Collection.prototype, 'namespace', {
  enumerable: true,
  get: function() {
    return this.s.namespace;
  }
});
Object.defineProperty(Collection.prototype, 'readConcern', {
  enumerable: true,
  get: function() {
    return this.s.readConcern || { level: 'local' };
  }
});
Object.defineProperty(Collection.prototype, 'writeConcern', {
  enumerable: true,
  get: function() {
    let ops = {};
    if (this.s.writeConcern) {
      return this.s.writeConcern;
    }
    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  }
});
Object.defineProperty(Collection.prototype, 'hint', {
  enumerable: true,
  get: function() {
    return this.s.collectionHint;
  },
  set: function(v) {
    this.s.collectionHint = normalizeHintField(v);
  }
});
const DEPRECATED_FIND_OPTIONS = ['maxScan', 'fields', 'snapshot'];
Collection.prototype.find = deprecateOptions(
  {
    name: 'collection.find',
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  },
  function(query, options, callback) {
    if (typeof callback === 'object') {
      console.warn('Third parameter to `find()` must be a callback or undefined');
    }
    let selector = query;
    if (typeof callback !== 'function') {
      if (typeof options === 'function') {
        callback = options;
        options = undefined;
      } else if (options == null) {
        callback = typeof selector === 'function' ? selector : undefined;
        selector = typeof selector === 'object' ? selector : undefined;
      }
    }
    selector = selector == null ? {} : selector;
    const object = selector;
    if (Buffer.isBuffer(object)) {
      const object_size = object[0] | (object[1] << 8) | (object[2] << 16) | (object[3] << 24);
      if (object_size !== object.length) {
        const error = new Error(
          'query selector raw message size does not match message header size [' +
            object.length +
            '] != [' +
            object_size +
            ']'
        );
        error.name = 'MongoError';
        throw error;
      }
    }
    if (selector != null && selector._bsontype === 'ObjectID') {
      selector = { _id: selector };
    }
    if (!options) options = {};
    let projection = options.projection || options.fields;
    if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
      projection = projection.length
        ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          }, {})
        : { _id: 1 };
    }
    let newOptions = Object.assign({}, options);
    for (let key in this.s.options) {
      if (mergeKeys.indexOf(key) !== -1) {
        newOptions[key] = this.s.options[key];
      }
    }
    newOptions.skip = options.skip ? options.skip : 0;
    newOptions.limit = options.limit ? options.limit : 0;
    newOptions.raw = typeof options.raw === 'boolean' ? options.raw : this.s.raw;
    newOptions.hint =
      options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
    newOptions.timeout = typeof options.timeout === 'undefined' ? undefined : options.timeout;
    newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
    newOptions.readPreference = resolveReadPreference(newOptions, {
      db: this.s.db,
      collection: this
    });
    if (
      newOptions.readPreference != null &&
      (newOptions.readPreference !== 'primary' || newOptions.readPreference.mode !== 'primary')
    ) {
      newOptions.slaveOk = true;
    }
    if (selector != null && typeof selector !== 'object') {
      throw MongoError.create({ message: 'query selector must be an object', driver: true });
    }
    const findCommand = {
      find: this.s.namespace,
      limit: newOptions.limit,
      skip: newOptions.skip,
      query: selector
    };
    if (typeof newOptions.awaitdata === 'boolean') {
      newOptions.awaitData = newOptions.awaitdata;
    }
    if (typeof newOptions.timeout === 'boolean') newOptions.noCursorTimeout = newOptions.timeout;
    decorateCommand(findCommand, newOptions, ['session', 'collation']);
    if (projection) findCommand.fields = projection;
    newOptions.db = this.s.db;
    newOptions.promiseLibrary = this.s.promiseLibrary;
    if (newOptions.raw == null && typeof this.s.raw === 'boolean') newOptions.raw = this.s.raw;
    if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === 'boolean')
      newOptions.promoteLongs = this.s.promoteLongs;
    if (newOptions.promoteValues == null && typeof this.s.promoteValues === 'boolean')
      newOptions.promoteValues = this.s.promoteValues;
    if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === 'boolean')
      newOptions.promoteBuffers = this.s.promoteBuffers;
    if (findCommand.sort) {
      findCommand.sort = formattedOrderClause(findCommand.sort);
    }
    decorateWithReadConcern(findCommand, this, options);
    try {
      decorateWithCollation(findCommand, this, options);
    } catch (err) {
      if (typeof callback === 'function') return callback(err, null);
      throw err;
    }
    const cursor = this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
    return typeof callback === 'function' ? handleCallback(callback, null, cursor) : cursor;
  }
);
Collection.prototype.insertOne = function(doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, insertOne, [this, doc, options, callback]);
};
Collection.prototype.insertMany = function(docs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options ? Object.assign({}, options) : { ordered: true };
  return executeOperation(this.s.topology, insertMany, [this, docs, options, callback]);
};
Collection.prototype.bulkWrite = function(operations, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || { ordered: true };
  if (!Array.isArray(operations)) {
    throw MongoError.create({ message: 'operations must be an array of documents', driver: true });
  }
  return executeOperation(this.s.topology, bulkWrite, [this, operations, options, callback]);
};
Collection.prototype.insert = deprecate(function(docs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || { ordered: false };
  docs = !Array.isArray(docs) ? [docs] : docs;
  if (options.keepGoing === true) {
    options.ordered = false;
  }
  return this.insertMany(docs, options, callback);
}, 'collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');
Collection.prototype.updateOne = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  }
  options = Object.assign({}, options);
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, updateOne, [this, filter, update, options, callback]);
};
Collection.prototype.replaceOne = function(filter, doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, replaceOne, [this, filter, doc, options, callback]);
};
Collection.prototype.updateMany = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  }
  options = Object.assign({}, options);
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, updateMany, [this, filter, update, options, callback]);
};
Collection.prototype.update = deprecate(function(selector, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, updateDocuments, [
    this,
    selector,
    update,
    options,
    callback
  ]);
}, 'collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');
Collection.prototype.deleteOne = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, deleteOne, [this, filter, options, callback]);
};
Collection.prototype.removeOne = Collection.prototype.deleteOne;
Collection.prototype.deleteMany = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, deleteMany, [this, filter, options, callback]);
};
Collection.prototype.removeMany = Collection.prototype.deleteMany;
Collection.prototype.remove = deprecate(function(selector, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, removeDocuments, [this, selector, options, callback]);
}, 'collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');
Collection.prototype.save = deprecate(function(doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({}, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  return executeOperation(this.s.topology, save, [this, doc, options, callback]);
}, 'collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.');
Collection.prototype.findOne = deprecateOptions(
  {
    name: 'collection.find',
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  },
  function(query, options, callback) {
    if (typeof callback === 'object') {
      console.warn('Third parameter to `findOne()` must be a callback or undefined');
    }
    if (typeof query === 'function') (callback = query), (query = {}), (options = {});
    if (typeof options === 'function') (callback = options), (options = {});
    query = query || {};
    options = options || {};
    return executeOperation(this.s.topology, findOne, [this, query, options, callback]);
  }
);
Collection.prototype.rename = function(newName, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
  return executeOperation(this.s.topology, rename, [this, newName, options, callback]);
};
Collection.prototype.drop = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, this.s.db.dropCollection.bind(this.s.db), [
    this.s.name,
    options,
    callback
  ]);
};
Collection.prototype.options = function(opts, callback) {
  if (typeof opts === 'function') (callback = opts), (opts = {});
  opts = opts || {};
  return executeOperation(this.s.topology, optionsOp, [this, opts, callback]);
};
Collection.prototype.isCapped = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, isCapped, [this, options, callback]);
};
Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, createIndex, [this, fieldOrSpec, options, callback]);
};
Collection.prototype.createIndexes = function(indexSpecs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options ? Object.assign({}, options) : {};
  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;
  return executeOperation(this.s.topology, createIndexes, [this, indexSpecs, options, callback]);
};
Collection.prototype.dropIndex = function(indexName, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};
  options.readPreference = ReadPreference.PRIMARY;
  return executeOperation(this.s.topology, dropIndex, [this, indexName, options, callback]);
};
Collection.prototype.dropIndexes = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options ? Object.assign({}, options) : {};
  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;
  return executeOperation(this.s.topology, dropIndexes, [this, options, callback]);
};
Collection.prototype.dropAllIndexes = deprecate(
  Collection.prototype.dropIndexes,
  'collection.dropAllIndexes is deprecated. Use dropIndexes instead.'
);
Collection.prototype.reIndex = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, reIndex, [this, options, callback]);
};
Collection.prototype.listIndexes = function(options) {
  options = options || {};
  options = Object.assign({}, options);
  options.readPreference = resolveReadPreference(options, { db: this.s.db, collection: this });
  options.cursorFactory = CommandCursor;
  options.promiseLibrary = this.s.promiseLibrary;
  if (!this.s.topology.capabilities()) {
    throw new MongoError('cannot connect to server');
  }
  let cursor = options.batchSize ? { batchSize: options.batchSize } : {};
  if (this.s.topology.capabilities().hasListIndexesCommand) {
    const command = { listIndexes: this.s.name, cursor: cursor };
    cursor = this.s.topology.cursor(`${this.s.dbName}.$cmd`, command, options);
    if (options.readPreference) cursor.setReadPreference(options.readPreference);
    return cursor;
  }
  const ns = `${this.s.dbName}.system.indexes`;
  cursor = this.s.topology.cursor(ns, { find: ns, query: { ns: this.s.namespace } }, options);
  if (options.readPreference) cursor.setReadPreference(options.readPreference);
  if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
  return cursor;
};
Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, ensureIndex, [this, fieldOrSpec, options, callback]);
}, 'collection.ensureIndex is deprecated. Use createIndexes instead.');
Collection.prototype.indexExists = function(indexes, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, indexExists, [this, indexes, options, callback]);
};
Collection.prototype.indexInformation = function(options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, indexInformation, [this, options, callback]);
};
Collection.prototype.count = deprecate(function(query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || {} : {};
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, count, [this, query, options, callback]);
}, 'collection.count is deprecated, and will be removed in a future version.' +
  ' Use collection.countDocuments or collection.estimatedDocumentCount instead');
Collection.prototype.estimatedDocumentCount = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, count, [this, null, options, callback]);
};
Collection.prototype.countDocuments = function(query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || {} : {};
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, countDocuments, [this, query, options, callback]);
};
Collection.prototype.distinct = function(key, query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  const queryOption = args.length ? args.shift() || {} : {};
  const optionsOption = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, distinct, [
    this,
    key,
    queryOption,
    optionsOption,
    callback
  ]);
};
Collection.prototype.indexes = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, indexes, [this, options, callback]);
};
Collection.prototype.stats = function(options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, stats, [this, options, callback]);
};
Collection.prototype.findOneAndDelete = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  return executeOperation(this.s.topology, findOneAndDelete, [this, filter, options, callback]);
};
Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (replacement == null || typeof replacement !== 'object')
    throw toError('replacement parameter must be an object');
  const keys = Object.keys(replacement);
  if (keys[0] && keys[0][0] === '$') {
    throw toError('The replacement document must not contain atomic operators.');
  }
  return executeOperation(this.s.topology, findOneAndReplace, [
    this,
    filter,
    replacement,
    options,
    callback
  ]);
};
Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (update == null || typeof update !== 'object')
    throw toError('update parameter must be an object');
  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  }
  return executeOperation(this.s.topology, findOneAndUpdate, [
    this,
    filter,
    update,
    options,
    callback
  ]);
};
Collection.prototype.findAndModify = deprecate(
  _findAndModify,
  'collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.'
);
Collection.prototype._findAndModify = _findAndModify;
function _findAndModify(query, sort, doc, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  doc = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {} : {};
  options = Object.assign({}, options);
  options.readPreference = ReadPreference.PRIMARY;
  return executeOperation(this.s.topology, findAndModify, [
    this,
    query,
    sort,
    doc,
    options,
    callback
  ]);
}
Collection.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, findAndRemove, [this, query, sort, options, callback]);
}, 'collection.findAndRemove is deprecated. Use findOneAndDelete instead.');
Collection.prototype.aggregate = function(pipeline, options, callback) {
  if (Array.isArray(pipeline)) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (options == null && callback == null) {
      options = {};
    }
  } else {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = args.pop();
    const opts = args[args.length - 1];
    options =
      opts &&
      (opts.readPreference ||
        opts.explain ||
        opts.cursor ||
        opts.out ||
        opts.maxTimeMS ||
        opts.hint ||
        opts.allowDiskUse)
        ? args.pop()
        : {};
    pipeline = args;
  }
  return aggregate(this.s.db, this, pipeline, options, callback);
};
Collection.prototype.watch = function(pipeline, options) {
  pipeline = pipeline || [];
  options = options || {};
  if (!Array.isArray(pipeline)) {
    options = pipeline;
    pipeline = [];
  }
  return new ChangeStream(this, pipeline, options);
};
Collection.prototype.parallelCollectionScan = deprecate(function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = { numCursors: 1 });
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;
  options = Object.assign({}, options);
  options.readPreference = resolveReadPreference(options, { db: this.s.db, collection: this });
  options.promiseLibrary = this.s.promiseLibrary;
  if (options.session) {
    options.session = undefined;
  }
  return executeOperation(this.s.topology, parallelCollectionScan, [this, options, callback], {
    skipSessions: true
  });
}, 'parallelCollectionScan is deprecated in MongoDB v4.1');
Collection.prototype.geoHaystackSearch = function(x, y, options, callback) {
  const args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, geoHaystackSearch, [this, x, y, options, callback]);
};
Collection.prototype.group = deprecate(function(
  keys,
  condition,
  initial,
  reduce,
  finalize,
  command,
  options,
  callback
) {
  const args = Array.prototype.slice.call(arguments, 3);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  reduce = args.length ? args.shift() : null;
  finalize = args.length ? args.shift() : null;
  command = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {} : {};
  if (!(typeof finalize === 'function')) {
    command = finalize;
    finalize = null;
  }
  if (
    !Array.isArray(keys) &&
    keys instanceof Object &&
    typeof keys !== 'function' &&
    !(keys._bsontype === 'Code')
  ) {
    keys = Object.keys(keys);
  }
  if (typeof reduce === 'function') {
    reduce = reduce.toString();
  }
  if (typeof finalize === 'function') {
    finalize = finalize.toString();
  }
  command = command == null ? true : command;
  return executeOperation(this.s.topology, group, [
    this,
    keys,
    condition,
    initial,
    reduce,
    finalize,
    command,
    options,
    callback
  ]);
},
'MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.');
Collection.prototype.mapReduce = function(map, reduce, options, callback) {
  if ('function' === typeof options) (callback = options), (options = {});
  if (null == options.out) {
    throw new Error(
      'the out option parameter must be defined, see mongodb docs for possible values'
    );
  }
  if ('function' === typeof map) {
    map = map.toString();
  }
  if ('function' === typeof reduce) {
    reduce = reduce.toString();
  }
  if ('function' === typeof options.finalize) {
    options.finalize = options.finalize.toString();
  }
  return executeOperation(this.s.topology, mapReduce, [this, map, reduce, options, callback]);
};
Collection.prototype.initializeUnorderedBulkOp = function(options) {
  options = options || {};
  if (options.ignoreUndefined == null) {
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  options.promiseLibrary = this.s.promiseLibrary;
  return unordered(this.s.topology, this, options);
};
Collection.prototype.initializeOrderedBulkOp = function(options) {
  options = options || {};
  if (options.ignoreUndefined == null) {
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  options.promiseLibrary = this.s.promiseLibrary;
  return ordered(this.s.topology, this, options);
};
Collection.prototype.getLogger = function() {
  return this.s.db.s.logger;
};
module.exports = Collection;
