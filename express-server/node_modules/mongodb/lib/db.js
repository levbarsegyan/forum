'use strict';
const EventEmitter = require('events').EventEmitter;
const inherits = require('util').inherits;
const getSingleProperty = require('./utils').getSingleProperty;
const CommandCursor = require('./command_cursor');
const handleCallback = require('./utils').handleCallback;
const filterOptions = require('./utils').filterOptions;
const toError = require('./utils').toError;
const ReadPreference = require('mongodb-core').ReadPreference;
const MongoError = require('mongodb-core').MongoError;
const ObjectID = require('mongodb-core').ObjectID;
const Logger = require('mongodb-core').Logger;
const Collection = require('./collection');
const mergeOptionsAndWriteConcern = require('./utils').mergeOptionsAndWriteConcern;
const executeOperation = require('./utils').executeOperation;
const applyWriteConcern = require('./utils').applyWriteConcern;
const resolveReadPreference = require('./utils').resolveReadPreference;
const ChangeStream = require('./change_stream');
const deprecate = require('util').deprecate;
const deprecateOptions = require('./utils').deprecateOptions;
const CONSTANTS = require('./constants');
const addUser = require('./operations/db_ops').addUser;
const aggregate = require('./operations/aggregate').aggregate;
const collections = require('./operations/db_ops').collections;
const createCollection = require('./operations/db_ops').createCollection;
const createIndex = require('./operations/db_ops').createIndex;
const createListener = require('./operations/db_ops').createListener;
const dropCollection = require('./operations/db_ops').dropCollection;
const dropDatabase = require('./operations/db_ops').dropDatabase;
const ensureIndex = require('./operations/db_ops').ensureIndex;
const evaluate = require('./operations/db_ops').evaluate;
const executeCommand = require('./operations/db_ops').executeCommand;
const executeDbAdminCommand = require('./operations/db_ops').executeDbAdminCommand;
const indexInformation = require('./operations/db_ops').indexInformation;
const listCollectionsTransforms = require('./operations/db_ops').listCollectionsTransforms;
const profilingInfo = require('./operations/db_ops').profilingInfo;
const profilingLevel = require('./operations/db_ops').profilingLevel;
const removeUser = require('./operations/db_ops').removeUser;
const setProfilingLevel = require('./operations/db_ops').setProfilingLevel;
const validateDatabaseName = require('./operations/db_ops').validateDatabaseName;
const legalOptionNames = [
  'w',
  'wtimeout',
  'fsync',
  'j',
  'readPreference',
  'readPreferenceTags',
  'native_parser',
  'forceServerObjectId',
  'pkFactory',
  'serializeFunctions',
  'raw',
  'bufferMaxEntries',
  'authSource',
  'ignoreUndefined',
  'promoteLongs',
  'promiseLibrary',
  'readConcern',
  'retryMiliSeconds',
  'numberOfRetries',
  'parentDb',
  'noListener',
  'loggerLevel',
  'logger',
  'promoteBuffers',
  'promoteLongs',
  'promoteValues',
  'compression',
  'retryWrites'
];
function Db(databaseName, topology, options) {
  options = options || {};
  if (!(this instanceof Db)) return new Db(databaseName, topology, options);
  EventEmitter.call(this);
  const promiseLibrary = options.promiseLibrary || Promise;
  options = filterOptions(options, legalOptionNames);
  options.promiseLibrary = promiseLibrary;
  this.s = {
    databaseName: databaseName,
    dbCache: {},
    children: [],
    topology: topology,
    options: options,
    logger: Logger('Db', options),
    bson: topology ? topology.bson : null,
    readPreference: options.readPreference,
    bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : -1,
    parentDb: options.parentDb || null,
    pkFactory: options.pkFactory || ObjectID,
    nativeParser: options.nativeParser || options.native_parser,
    promiseLibrary: promiseLibrary,
    noListener: typeof options.noListener === 'boolean' ? options.noListener : false,
    readConcern: options.readConcern
  };
  validateDatabaseName(this.s.databaseName);
  getSingleProperty(this, 'serverConfig', this.s.topology);
  getSingleProperty(this, 'bufferMaxEntries', this.s.bufferMaxEntries);
  getSingleProperty(this, 'databaseName', this.s.databaseName);
  if (options.parentDb) return;
  if (this.s.noListener) return;
  topology.on('error', createListener(this, 'error', this));
  topology.on('timeout', createListener(this, 'timeout', this));
  topology.on('close', createListener(this, 'close', this));
  topology.on('parseError', createListener(this, 'parseError', this));
  topology.once('open', createListener(this, 'open', this));
  topology.once('fullsetup', createListener(this, 'fullsetup', this));
  topology.once('all', createListener(this, 'all', this));
  topology.on('reconnect', createListener(this, 'reconnect', this));
}
inherits(Db, EventEmitter);
Object.defineProperty(Db.prototype, 'topology', {
  enumerable: true,
  get: function() {
    return this.s.topology;
  }
});
Object.defineProperty(Db.prototype, 'options', {
  enumerable: true,
  get: function() {
    return this.s.options;
  }
});
Object.defineProperty(Db.prototype, 'slaveOk', {
  enumerable: true,
  get: function() {
    if (
      this.s.options.readPreference != null &&
      (this.s.options.readPreference !== 'primary' ||
        this.s.options.readPreference.mode !== 'primary')
    ) {
      return true;
    }
    return false;
  }
});
Object.defineProperty(Db.prototype, 'writeConcern', {
  enumerable: true,
  get: function() {
    const ops = {};
    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  }
});
Db.prototype.command = function(command, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = Object.assign({}, options);
  return executeOperation(this.s.topology, executeCommand, [this, command, options, callback]);
};
Db.prototype.aggregate = function(pipeline, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  if (options == null && callback == null) {
    options = {};
  }
  return aggregate(this, '1', pipeline, options, callback);
};
Db.prototype.admin = function() {
  const Admin = require('./admin');
  return new Admin(this, this.s.topology, this.s.promiseLibrary);
};
const collectionKeys = [
  'pkFactory',
  'readPreference',
  'serializeFunctions',
  'strict',
  'readConcern',
  'ignoreUndefined',
  'promoteValues',
  'promoteBuffers',
  'promoteLongs'
];
Db.prototype.collection = function(name, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  options = Object.assign({}, options);
  options.promiseLibrary = this.s.promiseLibrary;
  options.readConcern = options.readConcern || this.s.readConcern;
  if (this.s.options.ignoreUndefined) {
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  }
  options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true);
  if (options == null || !options.strict) {
    try {
      const collection = new Collection(
        this,
        this.s.topology,
        this.s.databaseName,
        name,
        this.s.pkFactory,
        options
      );
      if (callback) callback(null, collection);
      return collection;
    } catch (err) {
      if (err instanceof MongoError && callback) return callback(err);
      throw err;
    }
  }
  if (typeof callback !== 'function') {
    throw toError(`A callback is required in strict mode. While getting collection ${name}`);
  }
  if (this.serverConfig && this.serverConfig.isDestroyed()) {
    return callback(new MongoError('topology was destroyed'));
  }
  const listCollectionOptions = Object.assign({}, options, { nameOnly: true });
  this.listCollections({ name: name }, listCollectionOptions).toArray((err, collections) => {
    if (err != null) return handleCallback(callback, err, null);
    if (collections.length === 0)
      return handleCallback(
        callback,
        toError(`Collection ${name} does not exist. Currently in strict mode.`),
        null
      );
    try {
      return handleCallback(
        callback,
        null,
        new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options)
      );
    } catch (err) {
      return handleCallback(callback, err, null);
    }
  });
};
Db.prototype.createCollection = deprecateOptions(
  {
    name: 'Db.createCollection',
    deprecatedOptions: ['autoIndexId'],
    optionsIndex: 1
  },
  function(name, options, callback) {
    if (typeof options === 'function') (callback = options), (options = {});
    options = options || {};
    options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
    return executeOperation(this.s.topology, createCollection, [this, name, options, callback]);
  }
);
Db.prototype.stats = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const commandObject = { dbStats: true };
  if (options['scale'] != null) commandObject['scale'] = options['scale'];
  if (options.readPreference == null && this.s.readPreference) {
    options.readPreference = this.s.readPreference;
  }
  return this.command(commandObject, options, callback);
};
Db.prototype.listCollections = function(filter, options) {
  filter = filter || {};
  options = options || {};
  options = Object.assign({}, options);
  options.promiseLibrary = this.s.promiseLibrary;
  options.readPreference = resolveReadPreference(options, {
    db: this,
    default: ReadPreference.primary
  });
  let cursor = options.batchSize ? { batchSize: options.batchSize } : {};
  if (this.serverConfig.capabilities().hasListCollectionsCommand) {
    const nameOnly = typeof options.nameOnly === 'boolean' ? options.nameOnly : false;
    const command = { listCollections: true, filter, cursor, nameOnly };
    options.cursorFactory = CommandCursor;
    cursor = this.s.topology.cursor(`${this.s.databaseName}.$cmd`, command, options);
    if (options.readPreference) {
      cursor.setReadPreference(options.readPreference);
    }
    return cursor;
  }
  if (!this.serverConfig.capabilities().hasListCollectionsCommand) {
    if (
      typeof filter.name === 'string' &&
      !new RegExp('^' + this.databaseName + '\\.').test(filter.name)
    ) {
      filter = Object.assign({}, filter);
      filter.name = `${this.s.databaseName}.${filter.name}`;
    }
  }
  if (filter == null) {
    filter.name = `/${this.s.databaseName}/`;
  }
  if (filter.name) {
    filter = { $and: [{ name: filter.name }, { name: /^((?!\$).)*$/ }] };
  } else {
    filter = { name: /^((?!\$).)*$/ };
  }
  const _options = { transforms: listCollectionsTransforms(this.s.databaseName) };
  cursor = this.collection(CONSTANTS.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
  if (options.readPreference) cursor.setReadPreference(options.readPreference);
  if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
  return cursor;
};
Db.prototype.eval = deprecate(function(code, parameters, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  parameters = args.length ? args.shift() : parameters;
  options = args.length ? args.shift() || {} : {};
  return executeOperation(this.s.topology, evaluate, [this, code, parameters, options, callback]);
}, 'Db.eval is deprecated as of MongoDB version 3.2');
Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  options.new_collection = true;
  const collection = this.collection(fromCollection);
  return executeOperation(this.s.topology, collection.rename.bind(collection), [
    toCollection,
    options,
    callback
  ]);
};
Db.prototype.dropCollection = function(name, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const cmd = { drop: name };
  applyWriteConcern(cmd, { db: this }, options);
  const opts = Object.assign({}, this.s.options, { readPreference: ReadPreference.PRIMARY });
  if (options.session) opts.session = options.session;
  return executeOperation(this.s.topology, dropCollection, [this, cmd, opts, callback]);
};
Db.prototype.dropDatabase = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  const cmd = { dropDatabase: 1 };
  applyWriteConcern(cmd, { db: this }, options);
  const finalOptions = Object.assign({}, this.s.options, {
    readPreference: ReadPreference.PRIMARY
  });
  if (options.session) {
    finalOptions.session = options.session;
  }
  return executeOperation(this.s.topology, dropDatabase, [this, cmd, finalOptions, callback]);
};
Db.prototype.collections = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, collections, [this, options, callback]);
};
Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  options.readPreference = resolveReadPreference(options);
  return executeOperation(this.s.topology, executeDbAdminCommand, [
    this,
    selector,
    options,
    callback
  ]);
};
Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options ? Object.assign({}, options) : {};
  return executeOperation(this.s.topology, createIndex, [
    this,
    name,
    fieldOrSpec,
    options,
    callback
  ]);
};
Db.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, ensureIndex, [
    this,
    name,
    fieldOrSpec,
    options,
    callback
  ]);
}, 'Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0');
Db.prototype.addChild = function(db) {
  if (this.s.parentDb) return this.s.parentDb.addChild(db);
  this.s.children.push(db);
};
Db.prototype.addUser = function(username, password, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, addUser, [this, username, password, options, callback]);
};
Db.prototype.removeUser = function(username, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, removeUser, [this, username, options, callback]);
};
Db.prototype.setProfilingLevel = function(level, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, setProfilingLevel, [this, level, options, callback]);
};
Db.prototype.profilingInfo = deprecate(function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, profilingInfo, [this, options, callback]);
}, 'Db.profilingInfo is deprecated. Query the system.profile collection directly.');
Db.prototype.profilingLevel = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, profilingLevel, [this, options, callback]);
};
Db.prototype.indexInformation = function(name, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {});
  options = options || {};
  return executeOperation(this.s.topology, indexInformation, [this, name, options, callback]);
};
Db.prototype.unref = function() {
  this.s.topology.unref();
};
Db.prototype.watch = function(pipeline, options) {
  pipeline = pipeline || [];
  options = options || {};
  if (!Array.isArray(pipeline)) {
    options = pipeline;
    pipeline = [];
  }
  return new ChangeStream(this, pipeline, options);
};
Db.prototype.getLogger = function() {
  return this.s.logger;
};
Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
module.exports = Db;
