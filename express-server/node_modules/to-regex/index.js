'use strict';
var safe = require('safe-regex');
var define = require('define-property');
var extend = require('extend-shallow');
var not = require('regex-not');
var MAX_LENGTH = 1024 * 64;
var cache = {};
module.exports = function(patterns, options) {
  if (!Array.isArray(patterns)) {
    return makeRe(patterns, options);
  }
  return makeRe(patterns.join('|'), options);
};
function makeRe(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }
  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }
  var key = pattern;
  if (!options || (options && options.cache !== false)) {
    key = createKey(pattern, options);
    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
  }
  var opts = extend({}, options);
  if (opts.contains === true) {
    if (opts.negate === true) {
      opts.strictNegate = false;
    } else {
      opts.strict = false;
    }
  }
  if (opts.strict === false) {
    opts.strictOpen = false;
    opts.strictClose = false;
  }
  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var flags = opts.flags || '';
  var regex;
  if (opts.nocase === true && !/i/.test(flags)) {
    flags += 'i';
  }
  try {
    if (opts.negate || typeof opts.strictNegate === 'boolean') {
      pattern = not.create(pattern, opts);
    }
    var str = open + '(?:' + pattern + ')' + close;
    regex = new RegExp(str, flags);
    if (opts.safe === true && safe(regex) === false) {
      throw new Error('potentially unsafe regular expression: ' + regex.source);
    }
  } catch (err) {
    if (opts.strictErrors === true || opts.safe === true) {
      err.key = key;
      err.pattern = pattern;
      err.originalOptions = options;
      err.createdOptions = opts;
      throw err;
    }
    try {
      regex = new RegExp('^' + pattern.replace(/(\W)/g, '\\$1') + '$');
    } catch (err) {
      regex = /.^/; 
    }
  }
  if (opts.cache !== false) {
    memoize(regex, key, pattern, opts);
  }
  return regex;
}
function memoize(regex, key, pattern, options) {
  define(regex, 'cached', true);
  define(regex, 'pattern', pattern);
  define(regex, 'options', options);
  define(regex, 'key', key);
  cache[key] = regex;
}
function createKey(pattern, options) {
  if (!options) return pattern;
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
}
module.exports.makeRe = makeRe;
