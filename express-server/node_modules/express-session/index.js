'use strict';
var Buffer = require('safe-buffer').Buffer
var cookie = require('cookie');
var crypto = require('crypto')
var debug = require('debug')('express-session');
var deprecate = require('depd')('express-session');
var onHeaders = require('on-headers')
var parseUrl = require('parseurl');
var signature = require('cookie-signature')
var uid = require('uid-safe').sync
var Cookie = require('./session/cookie')
var MemoryStore = require('./session/memory')
var Session = require('./session/session')
var Store = require('./session/store')
var env = process.env.NODE_ENV;
exports = module.exports = session;
exports.Store = Store;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;
var warning = 'Warning: connect.session() MemoryStore is not\n'
  + 'designed for a production environment, as it will leak\n'
  + 'memory, and will not scale past a single process.';
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
function session(options) {
  var opts = options || {}
  var cookieOptions = opts.cookie || {}
  var generateId = opts.genid || generateSessionId
  var name = opts.name || opts.key || 'connect.sid'
  var store = opts.store || new MemoryStore()
  var trustProxy = opts.proxy
  var resaveSession = opts.resave;
  var rollingSessions = Boolean(opts.rolling)
  var saveUninitializedSession = opts.saveUninitialized
  var secret = opts.secret
  if (typeof generateId !== 'function') {
    throw new TypeError('genid option must be a function');
  }
  if (resaveSession === undefined) {
    deprecate('undefined resave option; provide resave option');
    resaveSession = true;
  }
  if (saveUninitializedSession === undefined) {
    deprecate('undefined saveUninitialized option; provide saveUninitialized option');
    saveUninitializedSession = true;
  }
  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {
    throw new TypeError('unset option must be "destroy" or "keep"');
  }
  var unsetDestroy = opts.unset === 'destroy'
  if (Array.isArray(secret) && secret.length === 0) {
    throw new TypeError('secret option array must contain one or more strings');
  }
  if (secret && !Array.isArray(secret)) {
    secret = [secret];
  }
  if (!secret) {
    deprecate('req.secret; provide secret option');
  }
  if (env === 'production' && store instanceof MemoryStore) {
    console.warn(warning);
  }
  store.generate = function(req){
    req.sessionID = generateId(req);
    req.session = new Session(req);
    req.session.cookie = new Cookie(cookieOptions);
    if (cookieOptions.secure === 'auto') {
      req.session.cookie.secure = issecure(req, trustProxy);
    }
  };
  var storeImplementsTouch = typeof store.touch === 'function';
  var storeReady = true
  store.on('disconnect', function ondisconnect() {
    storeReady = false
  })
  store.on('connect', function onconnect() {
    storeReady = true
  })
  return function session(req, res, next) {
    if (req.session) {
      next()
      return
    }
    if (!storeReady) {
      debug('store is disconnected')
      next()
      return
    }
    var originalPath = parseUrl.original(req).pathname || '/'
    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next();
    if (!secret && !req.secret) {
      next(new Error('secret option required for sessions'));
      return;
    }
    var secrets = secret || [req.secret];
    var originalHash;
    var originalId;
    var savedHash;
    var touched = false
    req.sessionStore = store;
    var cookieId = req.sessionID = getcookie(req, name, secrets);
    onHeaders(res, function(){
      if (!req.session) {
        debug('no session');
        return;
      }
      if (!shouldSetCookie(req)) {
        return;
      }
      if (req.session.cookie.secure && !issecure(req, trustProxy)) {
        debug('not secured');
        return;
      }
      if (!touched) {
        req.session.touch()
        touched = true
      }
      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);
    });
    var _end = res.end;
    var _write = res.write;
    var ended = false;
    res.end = function end(chunk, encoding) {
      if (ended) {
        return false;
      }
      ended = true;
      var ret;
      var sync = true;
      function writeend() {
        if (sync) {
          ret = _end.call(res, chunk, encoding);
          sync = false;
          return;
        }
        _end.call(res);
      }
      function writetop() {
        if (!sync) {
          return ret;
        }
        if (chunk == null) {
          ret = true;
          return ret;
        }
        var contentLength = Number(res.getHeader('Content-Length'));
        if (!isNaN(contentLength) && contentLength > 0) {
          chunk = !Buffer.isBuffer(chunk)
            ? Buffer.from(chunk, encoding)
            : chunk;
          encoding = undefined;
          if (chunk.length !== 0) {
            debug('split response');
            ret = _write.call(res, chunk.slice(0, chunk.length - 1));
            chunk = chunk.slice(chunk.length - 1, chunk.length);
            return ret;
          }
        }
        ret = _write.call(res, chunk, encoding);
        sync = false;
        return ret;
      }
      if (shouldDestroy(req)) {
        debug('destroying');
        store.destroy(req.sessionID, function ondestroy(err) {
          if (err) {
            defer(next, err);
          }
          debug('destroyed');
          writeend();
        });
        return writetop();
      }
      if (!req.session) {
        debug('no session');
        return _end.call(res, chunk, encoding);
      }
      if (!touched) {
        req.session.touch()
        touched = true
      }
      if (shouldSave(req)) {
        req.session.save(function onsave(err) {
          if (err) {
            defer(next, err);
          }
          writeend();
        });
        return writetop();
      } else if (storeImplementsTouch && shouldTouch(req)) {
        debug('touching');
        store.touch(req.sessionID, req.session, function ontouch(err) {
          if (err) {
            defer(next, err);
          }
          debug('touched');
          writeend();
        });
        return writetop();
      }
      return _end.call(res, chunk, encoding);
    };
    function generate() {
      store.generate(req);
      originalId = req.sessionID;
      originalHash = hash(req.session);
      wrapmethods(req.session);
    }
    function inflate (req, sess) {
      store.createSession(req, sess)
      originalId = req.sessionID
      originalHash = hash(sess)
      if (!resaveSession) {
        savedHash = originalHash
      }
      wrapmethods(req.session)
    }
    function wrapmethods(sess) {
      var _reload = sess.reload
      var _save = sess.save;
      function reload(callback) {
        debug('reloading %s', this.id)
        _reload.call(this, function () {
          wrapmethods(req.session)
          callback.apply(this, arguments)
        })
      }
      function save() {
        debug('saving %s', this.id);
        savedHash = hash(this);
        _save.apply(this, arguments);
      }
      Object.defineProperty(sess, 'reload', {
        configurable: true,
        enumerable: false,
        value: reload,
        writable: true
      })
      Object.defineProperty(sess, 'save', {
        configurable: true,
        enumerable: false,
        value: save,
        writable: true
      });
    }
    function isModified(sess) {
      return originalId !== sess.id || originalHash !== hash(sess);
    }
    function isSaved(sess) {
      return originalId === sess.id && savedHash === hash(sess);
    }
    function shouldDestroy(req) {
      return req.sessionID && unsetDestroy && req.session == null;
    }
    function shouldSave(req) {
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }
      return !saveUninitializedSession && cookieId !== req.sessionID
        ? isModified(req.session)
        : !isSaved(req.session)
    }
    function shouldTouch(req) {
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }
      return cookieId === req.sessionID && !shouldSave(req);
    }
    function shouldSetCookie(req) {
      if (typeof req.sessionID !== 'string') {
        return false;
      }
      return cookieId !== req.sessionID
        ? saveUninitializedSession || isModified(req.session)
        : rollingSessions || req.session.cookie.expires != null && isModified(req.session);
    }
    if (!req.sessionID) {
      debug('no SID sent, generating session');
      generate();
      next();
      return;
    }
    debug('fetching %s', req.sessionID);
    store.get(req.sessionID, function(err, sess){
      if (err && err.code !== 'ENOENT') {
        debug('error %j', err);
        next(err)
        return
      }
      try {
        if (err || !sess) {
          debug('no session found')
          generate()
        } else {
          debug('session found')
          inflate(req, sess)
        }
      } catch (e) {
        next(e)
        return
      }
      next()
    });
  };
};
function generateSessionId(sess) {
  return uid(24);
}
function getcookie(req, name, secrets) {
  var header = req.headers.cookie;
  var raw;
  var val;
  if (header) {
    var cookies = cookie.parse(header);
    raw = cookies[name];
    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);
        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned')
      }
    }
  }
  if (!val && req.signedCookies) {
    val = req.signedCookies[name];
    if (val) {
      deprecate('cookie should be available in req.headers.cookie');
    }
  }
  if (!val && req.cookies) {
    raw = req.cookies[name];
    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);
        if (val) {
          deprecate('cookie should be available in req.headers.cookie');
        }
        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned')
      }
    }
  }
  return val;
}
function hash(sess) {
  var str = JSON.stringify(sess, function (key, val) {
    if (this === sess && key === 'cookie') {
      return
    }
    return val
  })
  return crypto
    .createHash('sha1')
    .update(str, 'utf8')
    .digest('hex')
}
function issecure(req, trustProxy) {
  if (req.connection && req.connection.encrypted) {
    return true;
  }
  if (trustProxy === false) {
    return false;
  }
  if (trustProxy !== true) {
    return req.secure === true
  }
  var header = req.headers['x-forwarded-proto'] || '';
  var index = header.indexOf(',');
  var proto = index !== -1
    ? header.substr(0, index).toLowerCase().trim()
    : header.toLowerCase().trim()
  return proto === 'https';
}
function setcookie(res, name, val, secret, options) {
  var signed = 's:' + signature.sign(val, secret);
  var data = cookie.serialize(name, signed, options);
  debug('set-cookie %s', data);
  var prev = res.getHeader('Set-Cookie') || []
  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];
  res.setHeader('Set-Cookie', header)
}
function unsigncookie(val, secrets) {
  for (var i = 0; i < secrets.length; i++) {
    var result = signature.unsign(val, secrets[i]);
    if (result !== false) {
      return result;
    }
  }
  return false;
}
