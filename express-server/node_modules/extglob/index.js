'use strict';
var extend = require('extend-shallow');
var unique = require('array-unique');
var toRegex = require('to-regex');
var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Extglob = require('./lib/extglob');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;
function extglob(pattern, options) {
  return extglob.create(pattern, options).output;
}
extglob.match = function(list, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }
  list = utils.arrayify(list);
  var isMatch = extglob.matcher(pattern, options);
  var len = list.length;
  var idx = -1;
  var matches = [];
  while (++idx < len) {
    var ele = list[idx];
    if (isMatch(ele)) {
      matches.push(ele);
    }
  }
  if (typeof options === 'undefined') {
    return unique(matches);
  }
  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }
  return options.nodupes !== false ? unique(matches) : matches;
};
extglob.isMatch = function(str, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  if (pattern === str) {
    return true;
  }
  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }
  var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);
  return isMatch(str);
};
extglob.contains = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }
  var opts = extend({}, options, {contains: true});
  opts.strictClose = false;
  opts.strictOpen = false;
  return extglob.isMatch(str, pattern, opts);
};
extglob.matcher = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }
  function matcher() {
    var re = extglob.makeRe(pattern, options);
    return function(str) {
      return re.test(str);
    };
  }
  return utils.memoize('matcher', pattern, options, matcher);
};
extglob.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }
  function create() {
    var ext = new Extglob(options);
    var ast = ext.parse(pattern, options);
    return ext.compile(ast, options);
  }
  return utils.memoize('create', pattern, options, create);
};
extglob.capture = function(pattern, str, options) {
  var re = extglob.makeRe(pattern, extend({capture: true}, options));
  function match() {
    return function(string) {
      var match = re.exec(string);
      if (!match) {
        return null;
      }
      return match.slice(1);
    };
  }
  var capture = utils.memoize('capture', pattern, options, match);
  return capture(str);
};
extglob.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }
  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }
  function makeRe() {
    var opts = extend({strictErrors: false}, options);
    if (opts.strictErrors === true) opts.strict = true;
    var res = extglob.create(pattern, opts);
    return toRegex(res.output, opts);
  }
  var regex = utils.memoize('makeRe', pattern, options, makeRe);
  if (regex.source.length > MAX_LENGTH) {
    throw new SyntaxError('potentially malicious regex detected');
  }
  return regex;
};
extglob.cache = utils.cache;
extglob.clearCache = function() {
  extglob.cache.__data__ = {};
};
extglob.Extglob = Extglob;
extglob.compilers = compilers;
extglob.parsers = parsers;
module.exports = extglob;
