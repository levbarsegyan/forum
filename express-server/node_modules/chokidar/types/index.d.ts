import * as fs from "fs";
import { EventEmitter } from "events";
export interface WatchedPaths {
  [directory: string]: string[];
}
export class FSWatcher extends EventEmitter implements fs.FSWatcher {
  constructor(options?: WatchOptions);
  add(paths: string | string[]): void;
  unwatch(paths: string | string[]): void;
  getWatched(): WatchedPaths;
  close(): void;
  on(event: 'add'|'addDir'|'change', listener: (path: string, stats?: fs.Stats) => void): this;
  on(event: 'all', listener: (eventName: 'add'|'addDir'|'change'|'unlink'|'unlinkDir', path: string, stats?: fs.Stats) => void): this;
  on(event: 'error', listener: (error: Error) => void): this;
  on(event: 'raw', listener: (eventName: string, path: string, details: any) => void): this;
  on(event: 'ready', listener: () => void): this;
  on(event: 'unlink'|'unlinkDir', listener: (path: string) => void): this;
  on(event: string, listener: (...args: any[]) => void): this;
}
export interface WatchOptions {
  persistent?: boolean;
  ignored?: any;
  ignoreInitial?: boolean;
  followSymlinks?: boolean;
  cwd?: string;
  disableGlobbing?: boolean;
  usePolling?: boolean;
  useFsEvents?: boolean;
  alwaysStat?: boolean;
  depth?: number;
  interval?: number;
  binaryInterval?: number;
  ignorePermissionErrors?: boolean;
  atomic?: boolean | number;
  awaitWriteFinish?: AwaitWriteFinishOptions | boolean;
}
export interface AwaitWriteFinishOptions {
  stabilityThreshold?: number;
  pollInterval?: number;
}
export function watch(
  paths: string | string[],
  options?: WatchOptions
): FSWatcher;
