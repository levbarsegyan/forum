"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var fs = require("fs"),
    abs = require("abs"),
    ExecLimiter = require("exec-limiter"),
    ul = require("ul");
var el = new ExecLimiter();
var Gry = function () {
    function Gry(options) {
        _classCallCheck(this, Gry);
        if (typeof options === "string") {
            options = {
                path: options
            };
        }
        options = ul.merge(options, {
            limit: 30
        });
        options.path = abs(options.path);
        this.options = options;
        this.cwd = options.path;
    }
    _createClass(Gry, [{
        key: "exec",
        value: function exec(command, args, callback) {
            var eargs = [];
            if (typeof args === "function") {
                callback = args;
                args = null;
            }
            if (Array.isArray(args)) {
                eargs.push("git", [command].concat(args));
            } else {
                eargs.push("git " + command.trim());
            }
            eargs.push({ cwd: this.cwd });
            eargs.push(function (err, stdout) {
                if (err) {
                    return callback(err);
                }
                callback(null, stdout.trimRight());
            });
            el.add.apply(el, eargs);
            return this;
        }
    }, {
        key: "init",
        value: function init(callback) {
            return this.exec("init", callback);
        }
    }, {
        key: "create",
        value: function create(callback) {
            var _this = this;
            fs.mkdir(this.cwd, function (err) {
                if (err) {
                    return callback(err);
                }
                _this.init(callback);
            });
            return this;
        }
    }, {
        key: "commit",
        value: function commit(message, options, callback) {
            message = message.replace(/\"/g, "\\");
            if (typeof options === "function") {
                callback = options;
                options = "";
            }
            return this.exec("commit -m \"" + message + "\" " + options, callback);
        }
    }, {
        key: "pull",
        value: function pull(options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = "";
            }
            return this.exec("pull " + options, callback);
        }
    }, {
        key: "add",
        value: function add(options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = ".";
            }
            return this.exec("add " + options, callback);
        }
    }, {
        key: "branch",
        value: function branch(options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = "";
            }
            return this.exec("branch " + options, callback);
        }
    }, {
        key: "checkout",
        value: function checkout(options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = "";
            }
            return this.exec("checkout " + options, callback);
        }
    }, {
        key: "clone",
        value: function clone(gitUrl, options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = "";
            }
            return this.exec("clone " + gitUrl + " " + options, callback);
        }
    }]);
    return Gry;
}();
Gry.limiter = el;
module.exports = Gry;
