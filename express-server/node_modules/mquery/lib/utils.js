'use strict';
var Buffer = require('safe-buffer').Buffer;
var RegExpClone = require('regexp-clone');
var clone = exports.clone = function clone(obj, options) {
  if (obj === undefined || obj === null)
    return obj;
  if (Array.isArray(obj))
    return exports.cloneArray(obj, options);
  if (obj.constructor) {
    if (/ObjectI[dD]$/.test(obj.constructor.name)) {
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.id);
    }
    if (obj.constructor.name === 'ReadPreference') {
      return new obj.constructor(obj.mode, clone(obj.tags, options));
    }
    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {
      return 'function' == typeof obj.clone
        ? obj.clone()
        : new obj.constructor(obj.value(true), obj.sub_type);
    }
    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
      return new obj.constructor(+obj);
    if ('RegExp' === obj.constructor.name)
      return RegExpClone(obj);
    if ('Buffer' === obj.constructor.name)
      return exports.cloneBuffer(obj);
  }
  if (isObject(obj))
    return exports.cloneObject(obj, options);
  if (obj.valueOf)
    return obj.valueOf();
};
exports.cloneObject = function cloneObject(obj, options) {
  var minimize = options && options.minimize;
  var ret = {};
  var hasKeys;
  var val;
  var k;
  for (k in obj) {
    val = clone(obj[k], options);
    if (!minimize || ('undefined' !== typeof val)) {
      hasKeys || (hasKeys = true);
      ret[k] = val;
    }
  }
  return minimize
    ? hasKeys && ret
    : ret;
};
exports.cloneArray = function cloneArray(arr, options) {
  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++)
    ret.push(clone(arr[i], options));
  return ret;
};
exports.tick = function tick(callback) {
  if ('function' !== typeof callback) return;
  return function() {
    var args = arguments;
    soon(function() {
      callback.apply(this, args);
    });
  };
};
exports.merge = function merge(to, from) {
  var keys = Object.keys(from),
      i = keys.length,
      key;
  while (i--) {
    key = keys[i];
    if ('undefined' === typeof to[key]) {
      to[key] = from[key];
    } else {
      if (exports.isObject(from[key])) {
        merge(to[key], from[key]);
      } else {
        to[key] = from[key];
      }
    }
  }
};
exports.mergeClone = function mergeClone(to, from) {
  var keys = Object.keys(from),
      i = keys.length,
      key;
  while (i--) {
    key = keys[i];
    if ('undefined' === typeof to[key]) {
      to[key] = clone(from[key]);
    } else {
      if (exports.isObject(from[key])) {
        mergeClone(to[key], from[key]);
      } else {
        to[key] = clone(from[key]);
      }
    }
  }
};
exports.readPref = function readPref(pref) {
  switch (pref) {
    case 'p':
      pref = 'primary';
      break;
    case 'pp':
      pref = 'primaryPreferred';
      break;
    case 's':
      pref = 'secondary';
      break;
    case 'sp':
      pref = 'secondaryPreferred';
      break;
    case 'n':
      pref = 'nearest';
      break;
  }
  return pref;
};
exports.readConcern = function readConcern(concern) {
  if ('string' === typeof concern) {
    switch (concern) {
      case 'l':
        concern = 'local';
        break;
      case 'a':
        concern = 'available';
        break;
      case 'm':
        concern = 'majority';
        break;
      case 'lz':
        concern = 'linearizable';
        break;
      case 's':
        concern = 'snapshot';
        break;
    }
    concern = { level: concern };
  }
  return concern;
};
var _toString = Object.prototype.toString;
exports.toString = function(arg) {
  return _toString.call(arg);
};
var isObject = exports.isObject = function(arg) {
  return '[object Object]' == exports.toString(arg);
};
exports.isArray = function(arg) {
  return Array.isArray(arg) ||
    'object' == typeof arg && '[object Array]' == exports.toString(arg);
};
exports.keys = Object.keys || function(obj) {
  var keys = [];
  for (var k in obj) if (obj.hasOwnProperty(k)) {
    keys.push(k);
  }
  return keys;
};
exports.create = 'function' == typeof Object.create
  ? Object.create
  : create;
function create(proto) {
  if (arguments.length > 1) {
    throw new Error('Adding properties is not supported');
  }
  function F() {}
  F.prototype = proto;
  return new F;
}
exports.inherits = function(ctor, superCtor) {
  ctor.prototype = exports.create(superCtor.prototype);
  ctor.prototype.constructor = ctor;
};
var soon = exports.soon = 'function' == typeof setImmediate
  ? setImmediate
  : process.nextTick;
exports.cloneBuffer = function(buff) {
  var dupe = Buffer.alloc(buff.length);
  buff.copy(dupe, 0, 0, buff.length);
  return dupe;
};
exports.isArgumentsObject = function(v) {
  return Object.prototype.toString.call(v) === '[object Arguments]';
};
